<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/</link>
    <description>Recent content on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Mon, 25 Jan 2016 19:41:59 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>MetalのGPGPUによるPerlinノイズ</title>
      <link>https://mike-neko.github.io/blog/metal%E3%81%AEgpgpu%E3%81%AB%E3%82%88%E3%82%8Bperlin%E3%83%8E%E3%82%A4%E3%82%BA/</link>
      <pubDate>Mon, 25 Jan 2016 19:41:59 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal%E3%81%AEgpgpu%E3%81%AB%E3%82%88%E3%82%8Bperlin%E3%83%8E%E3%82%A4%E3%82%BA/</guid>
      <description>

&lt;h2 id=&#34;概要:c76c02a9716918700fc6ffc19450c1da&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;GPGPUでリアルタイムにパーリンノイズを生成しテクスチャに書き込んで表示するデモ。&lt;/p&gt;

&lt;p&gt;パーリンノイズはGPU Gems2の改良パーリンノイズで、それを元にした数種類を選択可能。
デモでは3次元ノイズを生成し、z値だけを時間で加算していきノイズを変化させている。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-captioned data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&#34; margin:8px 0 0 0; padding:0 4px;&#34;&gt; &lt;a href=&#34;https://www.instagram.com/p/BBATaXDFQW1/&#34; style=&#34; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&#34; target=&#34;_blank&#34;&gt;ノイズ生成デモ&lt;/a&gt;&lt;/p&gt; &lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;@m_ike__が投稿した動画 - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-01-26T13:57:16+00:00&#34;&gt;2016 1月 26 5:57午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;ソース自体はGPUGemsのサンプルをほぼほぼ書き換えただけなので、ノイズ生成のアルゴリズムなどは参考サイトの方で。。。&lt;/p&gt;

&lt;h3 id=&#34;ノイズ生成の流れ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ノイズ生成の流れ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初期化時に順列テーブル&lt;code&gt;permBuffer&lt;/code&gt;を生成&lt;br /&gt;
初回のみなのでCPU側で生成&lt;br /&gt;
実行時毎にノイズの模様が変化する様にランダムに並び替えを行う&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;毎フレームごと、ComputeShaderでノイズを生成&lt;br /&gt;
シェーダは各種パラメータ&lt;code&gt;NoiseParameter&lt;/code&gt;や順列テーブルなどを受け取って、生成した結果をテクスチャに書き込んで返却する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2のテクスチャを板ポリに貼って描画する&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;computeshader用の設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ComputeShader用の設定&lt;/h3&gt;

&lt;h4 id=&#34;mtkviewの設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;MTKViewの設定&lt;/h4&gt;

&lt;p&gt;ComputeShaderを利用する場合は、&lt;code&gt;MTKView&lt;/code&gt;の&lt;code&gt;framebufferOnly&lt;/code&gt;を&lt;code&gt;false&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただし、パフォーマンスに影響を与えるので、利用しない時は触らないこと。&lt;/p&gt;

&lt;h4 id=&#34;waituntilcompleted:c76c02a9716918700fc6ffc19450c1da&#34;&gt;waitUntilCompleted()&lt;/h4&gt;

&lt;p&gt;各種コマンドの実行の終了するまで待機するメソッド。&lt;br /&gt;
以下のように&lt;code&gt;commandBuffer.commit()&lt;/code&gt;より後に置く。&lt;br /&gt;
描画時のような毎フレームごとの呼び出しの時は、別途 &lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;で処理を待機するので不要だが、
初期化時の1回のみ実行するような場合は、これを使って待機させる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* ~~ （ここでGPGPUのコマンド処理） ~~ */
commandBuffer.commit()
commandBuffer.waitUntilCompleted()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;スレッド:c76c02a9716918700fc6ffc19450c1da&#34;&gt;スレッド&lt;/h3&gt;

&lt;p&gt;GPGPUは大量のスレッドを並列動作させて圧倒的な処理を行うのが特徴だが、モバイルのGPUのため、スレッドグループ毎の最大のスレッド数は512までになっている(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/MetalFeatureSetTables/MetalFeatureSetTables.html&#34;&gt;公式&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;なお、スレッド数は32の倍数にするのが良い。nVIDIAの資料(URL忘れた…)によると64−192ぐらいが一番パフォーマンス的に良いらしいがA系チップに当てはまるかは不明。&lt;/p&gt;

&lt;p&gt;今回は以下のように、スレッドグループは1つのみだが、グループのサイズをテクスチャのサイズと同じにしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// スレッドグループの事前設定
threadgroupSize = MTLSize(width: TexSize, height: TexSize, depth: 1)
threadgroupCount = MTLSize(width: 1, height: 1, depth: 1)

// コマンドバッファへスレッドグループの設定
computeEncoder.dispatchThreadgroups(threadgroupSize, threadsPerThreadgroup: threadgroupCount)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;ここでの注意ポイントは、スレッドの&lt;strong&gt;&lt;em&gt;次元&lt;/em&gt;&lt;/strong&gt;に合わせてシェーダ側の引数も変更が必要なこと。
今回はサイズが2次元(width * height * 1)なので、シェーダ側は&lt;code&gt;uint2 id [[ thread_position_in_grid ]]&lt;/code&gt;と、
&lt;code&gt;uint2&lt;/code&gt;で受け取ることになる(間違えるとシェーダのコンパイルが通らない親切?仕様)。1次元なら&lt;code&gt;uint&lt;/code&gt;で受け取れば良い。&lt;/p&gt;

&lt;p&gt;また、グループが複数だったり1次元のバッファで2次元のグループサイズを指定している様な場合は、&lt;code&gt;threads_per_grid&lt;/code&gt;や&lt;code&gt;thread_position_in_threadgroup&lt;/code&gt;を追加で受け取る必要がある。詳細は公式の&lt;a href=&#34;https://developer.apple.com/library/tvos/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html&#34;&gt;Attribute Qualifiers for Kernel Function Input&lt;/a&gt;の項目を参照。&lt;/p&gt;

&lt;p&gt;同じスレッドグループ内であれば、メモリの共有ができたりするのだが、そのあたりも公式のサンプル&lt;a href=&#34;https://developer.apple.com/library/ios/samplecode/Metal_NBody_Simulation/Introduction/Intro.html&#34;&gt;Metal N-Body&lt;/a&gt;が参考になる。&lt;/p&gt;

&lt;h3 id=&#34;デバッグ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;デバッグ&lt;/h3&gt;

&lt;p&gt;Xcodeの&lt;code&gt;Capture GPU Frame&lt;/code&gt;がとても便利。&lt;/p&gt;

&lt;p&gt;これを使うと、実行中の各バッファやテクスチャのイメージの様子をキャプチャしてくれる。
バッファのバイナリも見れるので、例えば構造体のアライメントが崩れたりしているのを簡単に見つけることができる。&lt;/p&gt;

&lt;p&gt;また、プロファイル機能も充実していてどこがボトルネックがわかりやすい。&lt;/p&gt;

&lt;h2 id=&#34;感想:c76c02a9716918700fc6ffc19450c1da&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;Metalの発表を聞いて一番ワクワクして触りたかったのが、このGPGPUだった。これまでMacでは統合開発環境でGPGPUが組めなかった（普通のシェーダだけならUnityがあった）ので、使い慣れたXcodeで触れるのは楽しみだった。&lt;/p&gt;

&lt;p&gt;元々ソース自体はGemsのものや参考サイトのものがあったので、移植しただけ。実際にはパラメータやノイズの加工を工夫すれば、雲になったり地形になったりしていくが、パラメータの調整はどうも苦手というか時間がものすごくかかるので、とりあえず今回はここまでで。&lt;/p&gt;

&lt;p&gt;並列化によってどれくらい高速化するのかとか、モバイルのGPGPUでどのくらいパフォーマンスが上がるのか（もちろんバッファの転送が無いだけでも効果は大きいだろうけど）とかが気になったのだけど、それもまた別の機会に・・・&lt;/p&gt;

&lt;p&gt;にしても、シェーダ関係は環境毎に用語が微妙に変わるのは何とかしてほしい。。。&lt;/p&gt;

&lt;h1 id=&#34;参考サイト:c76c02a9716918700fc6ffc19450c1da&#34;&gt;参考サイト&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;日本語の解説：&lt;a href=&#34;http://postd.cc/understanding-perlin-noise/&#34;&gt;パーリンノイズを理解する(POSTD)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本家：&lt;a href=&#34;http://mrl.nyu.edu/~perlin/&#34;&gt;Ken Perlin&amp;rsquo;s homepage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems Chapter5：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems/gpugems_ch05.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems2 Chapter26：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FragmentShaderで実装や応用例：&lt;a href=&#34;http://www.sci.utah.edu/~leenak/IndStudy_reportfall/Perlin%20Noise%20on%20GPU.html&#34;&gt;Perlin Noise on GPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:c76c02a9716918700fc6ffc19450c1da&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalCompute&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalKitのSwift版サンプル</title>
      <link>https://mike-neko.github.io/blog/metalkit%E3%81%AEswift%E7%89%88%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB/</link>
      <pubDate>Fri, 22 Jan 2016 00:23:56 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metalkit%E3%81%AEswift%E7%89%88%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB/</guid>
      <description>

&lt;h2 id=&#34;概要:6a6245d2d174e54873361b2ccb73e605&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;元ネタのApple公式の&lt;a href=&#34;https://developer.apple.com/library/mac/samplecode/MetalKitEssentials/Introduction/Intro.html&#34;&gt;MetalKitEssentials&lt;/a&gt;をSwiftで書き直し＋αしたもの。
内容は主にMetalKitを使って、obj形式のモデルをテクスチャありで表示させるだけ。
シェーダもいたってシンプルでライトもなし。&lt;br /&gt;
ちなみに、MetalKitは&lt;strong&gt;iOS9以降&lt;/strong&gt;でしか使えないので注意。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:6a6245d2d174e54873361b2ccb73e605&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;はじめに:6a6245d2d174e54873361b2ccb73e605&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;一番最初につまずいたのは、ビルド自体が通らず、Metalのフレームワークのインポートでエラーになる！ってこと。当然、コードを書く時にも自動補完は効かないしエラーでまくるし・・・&lt;br /&gt;
で、原因はターゲットでシュミレータを選択していたこと。実行できないのは知っていたけど、まさかビルドすら通らないのは予想外。。。&lt;/p&gt;

&lt;h3 id=&#34;バッファへのアクセス:6a6245d2d174e54873361b2ccb73e605&#34;&gt;バッファへのアクセス&lt;/h3&gt;

&lt;p&gt;今回、一番書き方が判らなくて苦労したのがこれ。単にVertexBufferへのポインタを取得して、中のデータを読み書きしたいだけなのだが、当然、Swiftがメモリへの直アクセスを許してくれるわけはなく・・・&lt;/p&gt;

&lt;p&gt;上がObjective-Cで書いた場合で下がSwiftの場合：&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/1a7595b9b8cbe769a74d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Swiftでは、まずポインタ&lt;code&gt;p&lt;/code&gt;を明示的に取得し、それから&lt;code&gt;memory()&lt;/code&gt;で&lt;code&gt;VertexUniforms&lt;/code&gt;の型へ変換し、それを通して中のデータへアクセスするという手間が必要。やはりSwiftは型にうるさい。&lt;/p&gt;

&lt;p&gt;なお、このサンプルでは配列ではないので&lt;code&gt;p.memory()&lt;/code&gt;だが、バッファの内容が配列になっていてインデックスでアクセスしたい場合は、&lt;code&gt;p.advancedBy(i).memory()&lt;/code&gt;(iがインデックス)とする。&lt;/p&gt;

&lt;p&gt;ちょっと面倒だけど、暗黙的な「わかる人にはわかる」といった曖昧さを排除し、ポインタの状態やメモリにアクセスしていることを明示させているのは、Swiftの良さの一つだと思う。&lt;/p&gt;

&lt;h3 id=&#34;シェーダ用の構造体:6a6245d2d174e54873361b2ccb73e605&#34;&gt;シェーダ用の構造体&lt;/h3&gt;

&lt;p&gt;今回、シェーダにデータを渡す時の型（構造体）を、シェーダのファイルとSwift上でそれぞれ同じ宣言をしている。これは、Swiftから直接Cのファイルを見に行けない為。ブリッジヘッダを使ったりすれば重複して宣言しなくてよさそうだけど、未検証。Swift上ではSwiftの構造体を使えた方が便利かなと思ったので（結局使わなかったけど）&lt;/p&gt;

&lt;p&gt;なお、当然ながら&lt;strong&gt;メモリのアライメントには注意が必要&lt;/strong&gt;(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html#//apple_ref/doc/uid/TP40014364-CH2-SW15&#34;&gt;公式:アライメント一覧&lt;/a&gt;)なので、必要に応じてパディングすること。ちなみに忘れると画面が心霊現象みたくなったり表示されなかったり・・・&lt;/p&gt;

&lt;h3 id=&#34;simd:6a6245d2d174e54873361b2ccb73e605&#34;&gt;SIMD&lt;/h3&gt;

&lt;p&gt;Xcode7からようやくSIMDがサポート。これでvectorやmatrixのベタなコードを書く or 持ってくる必要がなくなった。（でも移動や回転とかはやっぱり自前が必要）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import simd&lt;/code&gt;で使えるようになる。&lt;code&gt;MetalKit&lt;/code&gt;のインポートでも良い。&lt;/p&gt;

&lt;h2 id=&#34;感想:6a6245d2d174e54873361b2ccb73e605&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;正直なところ、Unityとかに慣れてしまった身にとって、Metalは結構大変だった。。。日本語の資料も少ないし、公式の資料もまだまだObjective-Cが多い感じ。&lt;br /&gt;
といっても、DirectXのダラダラとした初期化とかに比べると、機種依存がなく簡潔で楽。久々に3Dの基礎を振り返る良い機会になったと思う。&lt;br /&gt;
結局まあ、Unityとかが偉大すぎるという当たり前の結論に到達。&lt;/p&gt;

&lt;p&gt;触っていて、良い！と思ったのは、バグで描画がおかしくなったりしても、影響が端末だけに限られて作業しているMacは無事なこと。&lt;br /&gt;
昔々のDirectXでしょっちゅうブルースクリーンを出してしまい、コードが消えたりPC不安定になっていた人なので、これはとても助かった。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:6a6245d2d174e54873361b2ccb73e605&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:6a6245d2d174e54873361b2ccb73e605&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalModel&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo利用方法メモ</title>
      <link>https://mike-neko.github.io/blog/hugo%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E3%83%A1%E3%83%A2/</link>
      <pubDate>Wed, 20 Jan 2016 22:48:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/hugo%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E3%83%A1%E3%83%A2/</guid>
      <description>

&lt;p&gt;初めはOctopressを使ってたものの、シンタックスハイライトがどうもうまく好みにならなかったので、結局、１週間ほどでHugoに乗り換え。Octopressに比べると構成もわかりやすいし、最新の資料が多くてよかった。&lt;br /&gt;
テーマはなるべくシンプル、かつ、スマホでも見やすい&lt;a href=&#34;http://themes.gohugo.io/hyde-x/&#34;&gt;Hyde-X&lt;/a&gt;を選定。以下はHyde-Xの場合の設定なので、他のテーマでは変わるので注意。&lt;/p&gt;

&lt;h2 id=&#34;初期設定:8d244dac89903f7d90007c69acaf707d&#34;&gt;初期設定&lt;/h2&gt;

&lt;h3 id=&#34;ローカルにディレクトリ作成:8d244dac89903f7d90007c69acaf707d&#34;&gt;ローカルにディレクトリ作成&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo new site &amp;lt;site-name&amp;gt;&lt;/code&gt;で作業用のローカルディレクトリを作成&lt;/li&gt;
&lt;li&gt;公開用ディレクトリを作成してGitを設定
&lt;code&gt;
cd &amp;lt;site-name&amp;gt;
mkdir public
git remote add origin https://github.com/&amp;lt;github name&amp;gt;/&amp;lt;github name&amp;gt;.github.io.git
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitignore&lt;/code&gt;を&lt;a href=&#34;https://github.com/github/gitignore&#34;&gt;https://github.com/github/gitignore&lt;/a&gt; から落としてきて、2の&lt;code&gt;public&lt;/code&gt;の中に置く。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;記事のテンプレを作成:8d244dac89903f7d90007c69acaf707d&#34;&gt;記事のテンプレを作成&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;site-name&amp;gt;/archetypes&lt;/code&gt;に&lt;code&gt;default.md&lt;/code&gt;を作成する。&lt;br /&gt;
内容は以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date = &amp;quot;now()&amp;quot;
draft = true
slug = &amp;quot;&amp;quot;
title = &amp;quot;&amp;quot;
categories = []
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configを編集:8d244dac89903f7d90007c69acaf707d&#34;&gt;configを編集&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;site-name&amp;gt;/config.toml&lt;/code&gt;を環境に合わせて編集する。&lt;br /&gt;
（設定方法はテーマのREADME.mdを参照）&lt;/p&gt;

&lt;h3 id=&#34;highlight-jsをカスタマイズ:8d244dac89903f7d90007c69acaf707d&#34;&gt;highlight.jsをカスタマイズ&lt;/h3&gt;

&lt;p&gt;デフォルトで入っていた分ではSwiftが未対応。。。まぁ基本的にはGistを使う予定だけど、一応使えるように。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlightjs公式&lt;/a&gt;で使いそうなものだけを選択してカスタムパッケージをDL&lt;/li&gt;
&lt;li&gt;DLしたものの中から&lt;code&gt;highlight.pack.js&lt;/code&gt;を&lt;code&gt;&amp;lt;site-name&amp;gt;/themes/hyde-x/static/js/highlight.pack.js&lt;/code&gt;と丸ごと置き換え&lt;/li&gt;
&lt;li&gt;カラースタイルもついでにXcodeにしたいので、DLしたものの中から&lt;code&gt;xcode.css&lt;/code&gt;を&lt;code&gt;&amp;lt;site-name&amp;gt;/themes/hyde-x/static/css/highlight&lt;/code&gt;に追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config.toml&lt;/code&gt;の中の&lt;code&gt;highlight&lt;/code&gt;を&lt;code&gt;xcode&lt;/code&gt;に変更&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これで、無事Swiftもハイライトされるようになった。&lt;/p&gt;

&lt;h3 id=&#34;gist埋め込みコードを設定:8d244dac89903f7d90007c69acaf707d&#34;&gt;Gist埋め込みコードを設定&lt;/h3&gt;

&lt;p&gt;普通にリンクをコピペしても良いのだけれども（&lt;del&gt;GistBoxを使い出したら逆にハッシュだけコピペするのが面倒だったり&lt;/del&gt;）、せっかくMarkdownで書いているのだから、あまりタグを入れて表記が揺らぐのも微妙なので。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;site-name&amp;gt;/layouts/shortcodes/gist.html&lt;/code&gt;を作成&lt;/li&gt;
&lt;li&gt;1のファイルに
&lt;code&gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://gist.github.com/{{ .Get 0 }}.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
を貼り付けて保存&lt;/li&gt;
&lt;li&gt;使いたい場所で&lt;br /&gt;
&lt;code&gt;
{{ &amp;lt; gist gist_sha1_hash &amp;gt; }}
&lt;/code&gt;&lt;br /&gt;
とすると、
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5526bee6ee5efd2fc5a7.js&#34;&gt;&lt;/script&gt;
といった感じで埋め込まれる&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;記事の作成:8d244dac89903f7d90007c69acaf707d&#34;&gt;記事の作成&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;site-name&amp;gt;&lt;/code&gt;直下で&lt;code&gt;hugo new post/&amp;lt;file-name&amp;gt;.md&lt;/code&gt;を実行する。&lt;/p&gt;

&lt;p&gt;プレビューは&lt;code&gt;hugo server -t Hyde-X -D -w&lt;/code&gt;を実行した後に、&lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; へアクセス。&lt;/p&gt;

&lt;h2 id=&#34;公開手順:8d244dac89903f7d90007c69acaf707d&#34;&gt;公開手順&lt;/h2&gt;

&lt;h3 id=&#34;流れ:8d244dac89903f7d90007c69acaf707d&#34;&gt;流れ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hugo -t Hyde-X&lt;/code&gt;でサイトを生成&lt;br /&gt;
(データ一式がpublicに格納される)&lt;/li&gt;
&lt;li&gt;1のデータをGitで&lt;code&gt;commit&lt;/code&gt;して&lt;code&gt;push&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ただ、毎回これをやるのは面倒なので、シェルスクリプトにしておく&lt;/p&gt;

&lt;h3 id=&#34;デプロイ用スクリプト:8d244dac89903f7d90007c69acaf707d&#34;&gt;デプロイ用スクリプト&lt;/h3&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/3159af7dd05c6278a778.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;githubでの書き方:8d244dac89903f7d90007c69acaf707d&#34;&gt;GitHubでの書き方&lt;/h1&gt;

&lt;p&gt;参考リンク
&lt;a href=&#34;https://help.github.com/articles/github-flavored-markdown/&#34;&gt;GitHub専用(公式)&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考サイト:8d244dac89903f7d90007c69acaf707d&#34;&gt;参考サイト&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotazi.com/blog/post/2015111301/&#34;&gt;【Hugo】Hosting on GitHub Pages【翻訳】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tanksuzuki.com/post/hugo-github-pages-1/&#34;&gt;Hugoでブログ作成 第一部：Hugoでブログを作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.cronally.com/embed-gists-with-hugo/&#34;&gt;Hugo Shortcode for Embedded Gists&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>