<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Metal on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/categories/metal/</link>
    <description>Recent content in Metal on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sun, 10 Jul 2016 18:28:58 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/categories/metal/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SceneKitでMetalのシェーダを利用する</title>
      <link>https://mike-neko.github.io/blog/metalshader-scenekit/</link>
      <pubDate>Sun, 10 Jul 2016 18:28:58 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metalshader-scenekit/</guid>
      <description>

&lt;h2 id=&#34;概要:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Metal&lt;/code&gt;を使いたい場合にネックとなるのが、シーンの構築とかモデル・テクスチャの管理。
なので、その面倒な部分を&lt;code&gt;SceneKit&lt;/code&gt;に任せたいという時の話。&lt;/p&gt;

&lt;p&gt;今回は描画周りに&lt;code&gt;Metal&lt;/code&gt;のシェーダを使うパターン。&lt;/p&gt;

&lt;p&gt;主に&lt;code&gt;SceneKit&lt;/code&gt;でカスタムシェーダを使いたい場合は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SCNProgram&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCNShadable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCNTechnique&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった辺りがあるみたい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SCNTechnique&lt;/code&gt;はマルチパスのレンダリングに使うのがメインっぽい。
&lt;del&gt;（これも試したけどシェーダへカスタム変数を渡す辺りでつまずいて放置）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SCNShadable&lt;/code&gt;は&lt;code&gt;Metal&lt;/code&gt;での使えそうなサンプルがなかったので断念。&lt;/p&gt;

&lt;p&gt;という訳で、WWDCのセッションの資料にあった&lt;code&gt;SCNProgram&lt;/code&gt;を使って実装。&lt;/p&gt;

&lt;h2 id=&#34;下準備:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;下準備&lt;/h2&gt;

&lt;p&gt;プロジェクトはXcodeのデフォルトのテンプレートの&lt;code&gt;Game&lt;/code&gt;を流用している。
作成時の&lt;code&gt;Game Technology&lt;/code&gt;では&lt;code&gt;SceneKit&lt;/code&gt;を選択する。&lt;/p&gt;

&lt;h3 id=&#34;scenekitの設定:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;SceneKitの設定&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Main.storeyboard&lt;/code&gt;を開き、&lt;code&gt;Game View Controller&lt;/code&gt;の&lt;code&gt;SceneKit View&lt;/code&gt;の
&lt;code&gt;Rendering API&lt;/code&gt;を&lt;code&gt;Metal&lt;/code&gt;にする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;GameViewController&lt;/code&gt;の&lt;code&gt;viewDidLoad&lt;/code&gt;の中のライト周りのコードを削除&lt;br /&gt;
（今回のシェーダはライトを使わないもので不必要なので消す）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scnprogramの作成:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;SCNProgramの作成&lt;/h3&gt;

&lt;p&gt;以下のようにして&lt;code&gt;SCNProgram&lt;/code&gt;を生成してシェーダの関数名を設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let program = SCNProgram()
program.vertexFunctionName = &amp;quot;textureVertex&amp;quot;
program.fragmentFunctionName = &amp;quot;textureFragment&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成した&lt;code&gt;SCNProgram&lt;/code&gt;を適用させたいマテリアルに設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let material = ship.childNodes.first?.geometry?.firstMaterial!
material.program = program
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;シェーダの準備:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;シェーダの準備&lt;/h3&gt;

&lt;p&gt;通常どおり&lt;code&gt;Metal&lt;/code&gt;のファイルを追加した後に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;SceneKit/scn_metal&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする。
これは後述の&lt;code&gt;SceneKit&lt;/code&gt;とデータのやりとりに必要。&lt;/p&gt;

&lt;h2 id=&#34;データの渡し方:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;データの渡し方&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SceneKit&lt;/code&gt;から描画に必要なデータ（座標や変換行列、テクスチャなど）を
シェーダへ渡す方法&lt;/p&gt;

&lt;h3 id=&#34;vertexshader側:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;VertexShader側&lt;/h3&gt;

&lt;h4 id=&#34;頂点属性-位置とか法線とかuv座標とか:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;頂点属性（位置とか法線とかuv座標とか）&lt;/h4&gt;

&lt;p&gt;まずは、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct VertexInput {
    float3 position [[ attribute(SCNVertexSemanticPosition) ]];
    float2 texcoord [[ attribute(SCNVertexSemanticTexcoord0) ]];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じで、頂点属性の中で必要なものを構造体で定義する。
すると、変数名の後ろの&lt;code&gt;Attribute Qualifier&lt;/code&gt;(&amp;rdquo;[[]]&amp;ldquo;で囲まれた部分)で指定したものが
&lt;code&gt;[[stage_in]]&lt;/code&gt;にバインドされて自動で渡されてくる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;指定できるものはドキュメントの&lt;code&gt;Table 1 
SceneKit Vertex Attribute Qualifiers for Metal Shaders&lt;/code&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;フレーム定数-ビューの変換行列など:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;フレーム定数（ビューの変換行列など）&lt;/h4&gt;

&lt;p&gt;あらかじめ&lt;code&gt;SCNSceneBuffer&lt;/code&gt;という構造体が用意されており、これらはその中に入っている。
このデータは&lt;code&gt;[[buffer(0)]]&lt;/code&gt;にバインドされて渡されてくる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;構造体の定義はドキュメントの&lt;code&gt;Frame-Constant Data&lt;/code&gt;の項目を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;ノード毎のデータ-モデルの変換行列など:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;ノード毎のデータ（モデルの変換行列など）&lt;/h4&gt;

&lt;p&gt;これは、あらかじめ用意された構造体がなく、代わりに必要なものをピックアップして
以下のように自分で構造体を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NodeBuffer {
    float4x4 modelViewProjectionTransform;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、そのデータが&lt;code&gt;[[buffer(1)]]&lt;/code&gt;にバインドされてシェーダに渡される。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ピックアップできるものはドキュメントの&lt;code&gt;Listing 1 
Available Fields for Per-Node Shader Data&lt;/code&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;カスタム変数:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;カスタム変数&lt;/h4&gt;

&lt;p&gt;上記以外の変数は構造体として定義が必要。定義自体は通常通りに行う。
ただし、バインドされるバッファは2以降になる。&lt;/p&gt;

&lt;h4 id=&#34;実装:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;実装&lt;/h4&gt;

&lt;p&gt;まとめると、&lt;code&gt;VertexShader&lt;/code&gt;の宣言部分は以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vertex output myVertex(input in [[ stage_in ]],
                       constant SCNSceneBuffer&amp;amp; scn_frame [[ buffer(0) ]],
                       constant NodeBuffer&amp;amp; scn_node [[ buffer(1) ]],
                       constant CustomBuffer&amp;amp; custom [[ buffer(2) ]]) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでの重要なポイントは&lt;strong&gt;引数名&lt;/strong&gt;。
- &lt;code&gt;scn_frame&lt;/code&gt;と&lt;code&gt;scn_node&lt;/code&gt;は固定&lt;br /&gt;
（違う名前にすると正しくバインドされない）
- カスタム変数の引数名&lt;code&gt;custom&lt;/code&gt;は&lt;code&gt;SceneKit&lt;/code&gt;からデータを渡す時に使う&lt;/p&gt;

&lt;p&gt;中での処理は必要な計算をして、それを&lt;code&gt;FragmentShader&lt;/code&gt;に渡すという、
通常の&lt;code&gt;Metal&lt;/code&gt;のシェーダと同じ実装を行う。&lt;/p&gt;

&lt;h3 id=&#34;fragmentshader側:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;FragmentShader側&lt;/h3&gt;

&lt;h4 id=&#34;テクスチャ:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;テクスチャ&lt;/h4&gt;

&lt;p&gt;テクスチャを利用したい場合は、特に事前の定義などは不要で通常通り宣言する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fragment half4 textureFragment(outout in [[ stage_in ]],
                               texture2d&amp;lt;float&amp;gt; texture [[ texture(0) ]]) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただしここでも重要なポイントは&lt;strong&gt;引数名&lt;/strong&gt;（詳細は後述）。&lt;/p&gt;

&lt;h3 id=&#34;scenekit側:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;SceneKit側&lt;/h3&gt;

&lt;p&gt;カスタム変数とテクスチャ以外は自動でバインドされる&lt;br /&gt;
（＝SceneKit側の処理は特にない）&lt;/p&gt;

&lt;h4 id=&#34;カスタム変数-1:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;カスタム変数&lt;/h4&gt;

&lt;p&gt;シェーダ側と同じ構造体のデータを準備する辺りは通常通り。&lt;/p&gt;

&lt;p&gt;そのデータをシェーダ側にバインドするのは以下のように&lt;code&gt;setValue&lt;/code&gt;を利用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var custom = CustomBuffer(color: float4(0, 0, 0, 1))
material.setValue(NSData(bytes: &amp;amp;custom, length:sizeof(CustomBuffer)),
                  forKey: &amp;quot;custom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setValue&lt;/code&gt;は&lt;code&gt;SCNProgram&lt;/code&gt;をセットしたのと同じ対象（今回は&lt;code&gt;material&lt;/code&gt;）に行う。&lt;br /&gt;
また、&lt;code&gt;value&lt;/code&gt;は&lt;code&gt;NSData&lt;/code&gt;としてバイナリで渡し、&lt;code&gt;key&lt;/code&gt;はシェーダでの宣言と同じ名前にする。&lt;/p&gt;

&lt;h4 id=&#34;テクスチャ-1:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;テクスチャ&lt;/h4&gt;

&lt;p&gt;今回のモデルではマテリアルの&lt;code&gt;diffuse&lt;/code&gt;にテクスチャが設定されているので、まずそれを取得する。
その後、&lt;code&gt;SCNMaterialProperty&lt;/code&gt;の形式にしてから変数と同様に&lt;code&gt;setValue&lt;/code&gt;する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let contents = material.diffuse.contents else { return }
material.setValue(SCNMaterialProperty(contents: contents),
                  forKey: &amp;quot;texture&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは、&lt;code&gt;SCNMaterialProperty&lt;/code&gt;を生成しなおしてからセットすること。&lt;br /&gt;
直接&lt;code&gt;diffuse&lt;/code&gt;の中のデータを&lt;code&gt;setValue&lt;/code&gt;すると正しくデータが渡されない。&lt;/p&gt;

&lt;h4 id=&#34;命名の注意点:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;命名の注意点&lt;/h4&gt;

&lt;p&gt;シェーダの引数名と&lt;code&gt;SceneKit&lt;/code&gt;側で&lt;code&gt;setValue&lt;/code&gt;の&lt;code&gt;key&lt;/code&gt;は一致させる必要がある。&lt;/p&gt;

&lt;p&gt;さらに大事な点として、&lt;code&gt;setValue&lt;/code&gt;は&lt;code&gt;KVO&lt;/code&gt;を利用しているので、
命名時にはオブジェクトのプロパティとかぶる様な名前をつけてはいけない。&lt;br /&gt;
（例えば&lt;code&gt;color&lt;/code&gt;などは実行時にエラーログが出て連携ができない）&lt;/p&gt;

&lt;h2 id=&#34;感想:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回はサンプルもなくとても苦戦した。。。特にシェーダとSceneKit間のデータのやりとり辺りは、
ドキュメントにも細かく書いてなくて苦労した。&lt;br /&gt;
妙に親切に頂点属性などをバインドしてくれると思ったら、
引数名固定だったり、テクスチャの再生成が必要だったりと落とし穴もいっぱい・・・&lt;/p&gt;

&lt;p&gt;あと、引数名がスネークケースなのもいただけない。
他がキャメルケースなのでここは統一して欲しかった。&lt;/p&gt;

&lt;p&gt;ただ、Metalのバインドの辺りの仕組みはどうなっているのか興味深いので、
もっといろいろ触ってみたい。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Apple公式ドキュメント(&lt;a href=&#34;https://developer.apple.com/reference/scenekit/scnprogram&#34;&gt;SCNProgram&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:abea6ba6b17ed17b65ca175add2d4d3a&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalShaderSceneKit&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metalによる砂のシミュレーションもどき</title>
      <link>https://mike-neko.github.io/blog/metal-sand/</link>
      <pubDate>Thu, 25 Feb 2016 22:05:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-sand/</guid>
      <description>

&lt;h2 id=&#34;概要:41585ab4c2e78900081a05c039c1f55d&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;MetalのGPGPUによる大量のパーティクル処理能力を活かしたデモ。
パーティクルをそれぞれ砂の一粒に見立てており、上から落下してきた砂粒が山のように積みあがっていく様子をシュミレートしている。&lt;/p&gt;

&lt;p&gt;なお、これも約26万パーティクルで60FPSを維持している。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BCX1ylEFQd_/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-29T13:51:35+00:00&#34;&gt;2016 2月 29 5:51午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;（2色にして拡大してみたけど、動画だとイマイチになってしまった・・・）&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;砂の動き:41585ab4c2e78900081a05c039c1f55d&#34;&gt;砂の動き&lt;/h3&gt;

&lt;p&gt;タイトルに「もどき」とある通り、砂の動きは粒子法などのちゃんとした物理計算をしているわけではないが、GameGems本の中の地形生成の粒子堆積を参考にしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;フラクタル地形生成-粒子堆積:41585ab4c2e78900081a05c039c1f55d&#34;&gt;フラクタル地形生成-粒子堆積&lt;/h4&gt;

&lt;p&gt;&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-25-metal-sand/gems4-19-3.png&#34; /&gt;
&lt;/figure&gt;

出典：Game Programming Gems&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上図にあるように、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子を地面（粒子）にぶつかるまで落下させる&lt;/li&gt;
&lt;li&gt;ぶつかった地点の周囲で最も低い地点を探す&lt;br /&gt;
見つからなければそこに粒子を固定（地面化）させて終了&lt;/li&gt;
&lt;li&gt;2で見つかった地点に粒子を移動させる&lt;/li&gt;
&lt;li&gt;1に戻って落下させ続ける&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをGPUで計算している。&lt;/p&gt;

&lt;h3 id=&#34;コンピュートシェーダのコード:41585ab4c2e78900081a05c039c1f55d&#34;&gt;コンピュートシェーダのコード&lt;/h3&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/c6997165804cbaa25402.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU側で砂の初期位置とy軸への落下速度を設定&lt;/li&gt;
&lt;li&gt;コンピュートシェーダで砂の動きを計算して描画用バッファへ書き出し&lt;/li&gt;
&lt;li&gt;バーテックスシェーダとフラグメントシェーダはシンプルにパーティクルを描画&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;h4 id=&#34;地面との衝突判定:41585ab4c2e78900081a05c039c1f55d&#34;&gt;地面との衝突判定&lt;/h4&gt;

&lt;p&gt;今回は地面との衝突の判定のみで、粒子間の衝突などは考慮しない。よって、512*512のバッファ&lt;code&gt;laminateBuffer&lt;/code&gt;を地面に見立てて、各座標の高さを記録している。ここでテクスチャを使っていないのは、コンピュートシェーダではテクスチャの読み書きを同時に行うことができない為。&lt;/p&gt;

&lt;p&gt;地面にぶつかったら、元の位置からそれぞれ30度+αずつずらした位置の地面の高さを見て、一番低いところを探す。なお、ここで手を抜いてsincosを使わなければ、四角い山ができてしまう・・・&lt;/p&gt;

&lt;p&gt;一番低いところの判定を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = mix((float)min_id, 1.f, not(step(h[1], h[min_id])));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としているが、これは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = (h[1] &amp;lt;= h[min_id]) ? min_id : 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同じである。(Metalの座標系のy軸は上が-になる)&lt;/p&gt;

&lt;p&gt;現在位置が一番低い場所であれば、y軸の速度を0にして粒子を固定する。同時に地面の高さも更新し、次回参照時からはそこが地面の扱いとなる。&lt;/p&gt;

&lt;p&gt;あとはこれをひたすら繰り返していくと山のように積み重なっていく。&lt;/p&gt;

&lt;h2 id=&#34;感想:41585ab4c2e78900081a05c039c1f55d&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;パラメータの調整とかバッファへの書き込みの精度を上げたりするなど、まだまだ改良の余地はありそう。。。&lt;/p&gt;

&lt;p&gt;なんにしても単純な方法を力任せに処理してもちゃんと動くあたり、GPGPUは頼もしい。&lt;/p&gt;

&lt;p&gt;あと、GameGemsの1以外も電子書籍で出ないかなぁ。内容的には古くても色々参考になるし、紙版は置く場所考えるとどうしても買いづらいので&lt;/p&gt;

&lt;h1 id=&#34;開発環境:41585ab4c2e78900081a05c039c1f55d&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:41585ab4c2e78900081a05c039c1f55d&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalSand&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalのGPGPUによるパーティクルデモ</title>
      <link>https://mike-neko.github.io/blog/metal-image/</link>
      <pubDate>Thu, 11 Feb 2016 09:20:27 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-image/</guid>
      <description>

&lt;h2 id=&#34;概要:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;読み込んだテクスチャをパーティクルに分解して動かすデモ。動きは滝のように画像がパーティクルに分解して落下していくのをイメージ。&lt;/p&gt;

&lt;p&gt;画像サイズが512*512、1ピクセル=1パーティクルに分解するので、約26万個のパーティクルを動かしているが、60FPSを維持している。約100万まで増やすとiPhone6+で30FPSぐらいとなる。&lt;/p&gt;

&lt;p&gt;そんなに複雑な計算をさせていないとはいえ、さすがGPGPUといったところ。なお、処理時間のほとんどはGPGPUの部分でCPUは余力がある様子。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:62.3366013072% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BBn2nSclQZi/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-10T22:35:15+00:00&#34;&gt;2016  2月 10 2:35午後 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちなみに実機で見るともっとキレイ&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;処理はおおまかにわけて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事前処理として、テクスチャを読み込んで、ピクセル数分のバッファを確保&lt;/li&gt;
&lt;li&gt;テクスチャからパーティクルを生成&lt;/li&gt;
&lt;li&gt;生成したパーティクルを動かす&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。事前処理はCPU側で行い、以降はそれぞれ専用のシェーダを準備して、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成用シェーダ&lt;code&gt;fallImageSetup&lt;/code&gt;をセットしてパーティクルを生成&lt;/li&gt;
&lt;li&gt;実行用シェーダ&lt;code&gt;fallImageCompute&lt;/code&gt;へ切り替えてパーティクルを動かす&lt;/li&gt;
&lt;li&gt;動き終われば1へ戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れでループする。&lt;/p&gt;

&lt;p&gt;注意点として、画像の座標とMetalでの座標軸は違うので、x軸とy軸に−1のスケールをかけて補正している。テクスチャ読み込み時に何かできるかは未調査だが、そもそもこういうテクスチャの使い方は普通しないと思うのでそのまま。&lt;/p&gt;

&lt;h3 id=&#34;テクスチャからパーティクルを生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;テクスチャからパーティクルを生成&lt;/h3&gt;

&lt;h4 id=&#34;パーティクルの位置の計算:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルの位置の計算&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// ImagePiece* particles [[ buffer(0) ]]
// uint2 id [[ thread_position_in_grid ]]
// uint2 size [[ threads_per_grid ]]
// uint index = id.x + id.y * size.x;
particles[index].position = float4(id.x / (float)size.x, id.y / (float)size.y, 0, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージとしては1*1の板ポリの中にすべてのパーティクルを配置する感じで、各パーティクルのローカル座標が(0, 0)から(1, 1)の中に収まるようにする。&lt;/p&gt;

&lt;h4 id=&#34;画像の対応するピクセルの色を取得:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;画像の対応するピクセルの色を取得&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// texture2d&amp;lt;float, access::read&amp;gt; image [[ texture(0) ]]
particles[index].color = image.read(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は1ピクセル=1パーティクル、スレッドも同じように分割しているので、テクスチャの対応するピクセルの座標は、そのままグリッド内のスレッド位置と同じになる。&lt;/p&gt;

&lt;h4 id=&#34;動きのパラメータの初期設定:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動きのパラメータの初期設定&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// param.time.w : y方向のdelay
// rnd : 乱数
float rnd_d = param.time.w * (1 - (float)rnd / UINT_MAX * 0.1);  // 1

// param.delta : 各軸の1フレーム毎の移動量
particles[index].acc = float4(param.delta.x, param.delta.y, param.delta.z, rnd_d * id.y);  // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下の方から順にパーティクルが落ちるように、画像の上の方ほど遅れて落ち始めるようにで遅延を設定する(2の&lt;code&gt;rnd_d * id.y&lt;/code&gt;部分)。また落ち方がそれっぽく見えるように、遅延時間は元の指定の100%〜90%の間でばらつくように乱数を使う(1の部分)。&lt;/p&gt;

&lt;h3 id=&#34;パーティクルに動きをつける:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルに動きをつける&lt;/h3&gt;

&lt;h4 id=&#34;位置の更新:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;位置の更新&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// particles[index].acc.w : delay
// param.time.x : スタートからの経過時間
// param.time.y : 前フレームからの経過時間
float t = fmax(0.f, param.time.x - particles[index].acc.w) * param.time.y * rnd_d;
particles[index].position += t * particles[index].acc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パーティクルの位置は、スムーズに見えるように&lt;code&gt;前回からの経過時間*時間あたりの移動量&lt;/code&gt;で計算する。ただし、各パーティクルには遅延時間があるので、それを経過するまでは経過時間は0として動かないようにする(&lt;code&gt;fmax(0.f, param.time.x - particles[index].acc.w)&lt;/code&gt;の部分)。さらに、こちらも乱数で落ち方にばらつきを与える。&lt;/p&gt;

&lt;h4 id=&#34;消滅処理:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;消滅処理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;float4 f = step(param.delta.w, particles[index].position + t * particles[index].acc);
particles[index].color.a -= (1 - f.x * f.y * f.z) * 0.1 * rnd_d * 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定距離落ちれば徐々に消滅したように見せる為に、まず&lt;code&gt;step()&lt;/code&gt;で指定した距離を超えていないかチェックする。超えていれば、該当の要素が0になるのでαが減算されて消えたように見せかける（パーティクル自体は生きている）。ここも乱数で消え方にばらつきを与える。&lt;/p&gt;

&lt;p&gt;ここでハマったのが、アルファブレンドをONにするのを忘れていて全然消えてくれなかったこと・・・&lt;br /&gt;
デフォルトではフラグメントシェーダでどれだけαを変更しても無視されるので、&lt;code&gt;pipelineDescriptor.alphaToCoverageEnabled = true&lt;/code&gt;でαの指定を有効にする。&lt;/p&gt;

&lt;p&gt;ポイントとなるのは、フラグメントシェーダ内の&lt;code&gt;if (in.color.a &amp;lt; 0.1) discard_fragment();&lt;/code&gt;という見えなくなったピクセルの破棄処理。なくてもパーティクルは消えてくれるが、この処理を行うことで若干フレームレートが改善するので入れた（&lt;del&gt;単に使ってみたかっただけ&lt;/del&gt;）。&lt;/p&gt;

&lt;h3 id=&#34;乱数の生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;乱数の生成&lt;/h3&gt;

&lt;p&gt;Metalではシェーダ上で使える乱数の関数は準備されていない為、使いたい場合はシェーダ上で自前で実装するかCPU側で生成したものを渡して使うかになる。今回はCPU側でほとんど処理しないので、シェーダ上で実装する方を選択した。&lt;/p&gt;

&lt;p&gt;乱数のアルゴリズムは幾つかあるし、このデモでの利用方法なら前回作ったようなノイズ関数を用いても良いが、ちょうど少し前に面白い記事(参考リンク参照)を見つけたので、&lt;code&gt;xorshift&lt;/code&gt;を採用することにした。32bitにしたのは、もしCPU側とやりとりする場合（シードの初期値など）に、64bit以上の型は直接渡せない為。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/b1c006b69ccb57261f7d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;今回はシードの初期値に&lt;code&gt;2463534242&lt;/code&gt;の値を直で指定している。もし本当にランダムにしたいならCPU側から現在のミリ秒あたりを渡して設定すればよい。&lt;/p&gt;

&lt;p&gt;ポイントは、生成された乱数が次回のシードになるので、アドレス空間に&lt;code&gt;threadgroup&lt;/code&gt;を指定していること。これにより同じスレッドグループ内のスレッドでこのシードが共有されるようになる。（指定しないと毎回初期値が設定されてしまう。）&lt;/p&gt;

&lt;p&gt;しかし、GPGPUでは同時にスレッドが並列で幾つも実行される為、単にシードを共有するだけでは同じシードを複数のスレッドを使うことになり、結果が偏ったものになってしまう。そこで、シードを渡す時に&lt;code&gt;rotate(rnd, id.x)&lt;/code&gt;として値をばらつかせている（フローの起きないrotateが標準で使えるのは、ほんと助かる）。&lt;/p&gt;

&lt;p&gt;得られる結果は&lt;code&gt;uint&lt;/code&gt;なので、実際のコード内では使いやすいよう&lt;code&gt;(float)rnd / UINT_MAX&lt;/code&gt;として正規化してから使っている。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;乱数のアルゴリズムの解説記事&lt;br /&gt;
&lt;a href=&#34;https://blog.visvirial.com/articles/575&#34;&gt;Google Chromeが採用した、擬似乱数生成アルゴリズム「xorshift」の数理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalImage&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metal組み込み関数</title>
      <link>https://mike-neko.github.io/blog/metal-function/</link>
      <pubDate>Thu, 28 Jan 2016 22:32:26 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-function/</guid>
      <description>

&lt;h2 id=&#34;metalのシェーダで利用できる関数のまとめ:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;Metalのシェーダで利用できる関数のまとめ&lt;/h2&gt;

&lt;h4 id=&#34;hlsl-glslは各言語との対比:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;HLSL/GLSLは各言語との対比&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(空白) : 同じ&lt;/li&gt;
&lt;li&gt;ー : 該当なし&lt;/li&gt;
&lt;li&gt;△ : 同等の関数があるが詳細が異なる&lt;/li&gt;
&lt;li&gt;(関数名) : 挙動は同じだが、名前が別の関数がある&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;共通関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;共通関数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;T は浮動小数点数のスカラーかベクター&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T clamp(T x, T min, T max)&lt;/td&gt;
&lt;td&gt;x を [min, max] の範囲にクランプする&lt;br&gt;fmin(fmax(x, min), max) を返す&lt;br&gt;min &amp;gt; maxは&lt;strong&gt;不定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T mix(T x, T y, T a)&lt;/td&gt;
&lt;td&gt;[x, y] の間の a で線形補間&lt;br&gt;x + (y – x) * a を返す&lt;br&gt;a は 0.0 から 1.0。それ以外は&lt;strong&gt;不定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;lerp&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T saturate(T x)&lt;/td&gt;
&lt;td&gt;x を [0.0, 1.0] の範囲にクランプして返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sign(T x)&lt;/td&gt;
&lt;td&gt;x &amp;gt; 0 で 1.0, x &amp;lt; 0 で -1.0,&lt;br&gt;x = -0.0 で -0.0, x = +0.0 で +0.0,&lt;br&gt;x = NaN で 0.0 を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T smoothstep(T e0, T e1, T x)&lt;/td&gt;
&lt;td&gt;x &amp;lt;= e0 で 0.0, x &amp;gt;= e1 で 1.0&lt;BR&gt;それ以外は [0.0, 1.0] の範囲でエルミート補間した値を返す&lt;br&gt;スムーズなトランジションに便利&lt;br&gt;t = clamp((x – e0)/(e1 – e0), 0, 1);&lt;br&gt;return t * t * (3 – 2 * t);と等価&lt;br&gt;e0 &amp;gt;= e1 または&lt;br&gt; x, e0, e1 のいずれかが NaN は&lt;strong&gt;不定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T step(T edge, T x)&lt;/td&gt;
&lt;td&gt;x &amp;lt; edge で 0.0&lt;br&gt;それ以外は 1.0 を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;整数関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;整数関数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;T は整数のスカラーかベクター&lt;/li&gt;
&lt;li&gt;Tu は符号なし整数のスカラーかベクター&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T abs(T x)&lt;br&gt;T fabs(T x)&lt;/td&gt;
&lt;td&gt;x の絶対値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tu absdiff(T x, T y)&lt;/td&gt;
&lt;td&gt;オーバーフローなしで x - y の絶対値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T clz(T x)&lt;/td&gt;
&lt;td&gt;x の先頭ビットから連続する 0 の個数&lt;br&gt;x = 0 で x の型のビットのサイズを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T ctz(T x)&lt;/td&gt;
&lt;td&gt;x の末尾ビットから連続する 0 の個数&lt;br&gt;x = 0 で x の型のビットのサイズを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T hadd(T x, T y)&lt;/td&gt;
&lt;td&gt;(x + y) &amp;gt;&amp;gt; 1 を返す&lt;br&gt;中間合計はオーバーフローしない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T madhi(T a, T b, T c)&lt;/td&gt;
&lt;td&gt;mulhi(a, b) + c を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T madsat(T a, T b, T c)&lt;/td&gt;
&lt;td&gt;saturate(a * b + c) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T max(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の最大値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T min(T x, T x)&lt;/td&gt;
&lt;td&gt;x と y の最小値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T mulhi(T x, T y)&lt;/td&gt;
&lt;td&gt;x * y の結果の上位半分のビットを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T popcount(T x)&lt;/td&gt;
&lt;td&gt;x の 0 ではないビットの数を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T rhadd(T x, T y)&lt;/td&gt;
&lt;td&gt;(x + y + 1) &amp;gt;&amp;gt; 1 を返す&lt;br&gt;中間合計はオーバーフローしない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T rotate(T v, T i)&lt;/td&gt;
&lt;td&gt;v の各要素に対し対応する i の要素の値のビット数分左へシフトした値を返す&lt;br&gt;あふれたビットは右端から挿入される&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T subsat(T x, T y)&lt;/td&gt;
&lt;td&gt;saturate(x - y) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;関係関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;関係関数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;T は浮動小数点数のスカラーかベクター&lt;/li&gt;
&lt;li&gt;Ti は整数かブーリアン型のスカラーかベクター&lt;/li&gt;
&lt;li&gt;Tb はブーリアン型のスカラーかベクター&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool all(Tb x)&lt;/td&gt;
&lt;td&gt;x の全ての要素が true の時に true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bool any(Tb x)&lt;/td&gt;
&lt;td&gt;x のいずれかの要素が true の時に true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isfinite(T x)&lt;/td&gt;
&lt;td&gt;x が有限の場合は true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isinf(T x)&lt;/td&gt;
&lt;td&gt;x が無限大(+/-)であれば true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isnan(T x)&lt;/td&gt;
&lt;td&gt;x がNanであれば true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isnormal(T x)&lt;/td&gt;
&lt;td&gt;x が正規化数であれば true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isordered(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の引数が順序付けられているか&lt;br&gt;(x == x) &amp;amp;&amp;amp; (y == y) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb isunordered(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の引数が順序付けられていないか&lt;br&gt;x か y が NaN であれば true を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T select(T a, T b, Tb c)&lt;/td&gt;
&lt;td&gt;result[i] = c[i] ? b[i] : a[i] を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ti select(Ti a, Ti b, Tb c)&lt;/td&gt;
&lt;td&gt;result = c ? b : a　を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Tb signbit(T x)&lt;/td&gt;
&lt;td&gt;符号ビットをテストする&lt;br&gt;x に浮動小数点数がセットされている場合は true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;数学関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;数学関数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;T は浮動小数点数のスカラーかベクター&lt;/li&gt;
&lt;li&gt;Ti は整数のスカラーかベクター&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T acos(T x)&lt;/td&gt;
&lt;td&gt;x のアークコサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T acosh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックアークコサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T asin(T x)&lt;/td&gt;
&lt;td&gt;x のアークサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T asinh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックアークサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T atan(T x)&lt;/td&gt;
&lt;td&gt;x のアークタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T atan2(T y, T x)&lt;/td&gt;
&lt;td&gt;y と x のアークタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T atanh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックアークタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T ceil(T x)&lt;/td&gt;
&lt;td&gt;x を正の無限大に近いほうの整数に丸めた値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T copysign(T x, T y)&lt;/td&gt;
&lt;td&gt;y の符号に変えた x を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T cos(T x)&lt;/td&gt;
&lt;td&gt;x のコサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T cosh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックコサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T cospi(T x)&lt;/td&gt;
&lt;td&gt;pi * x のコサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T exp(T x)&lt;/td&gt;
&lt;td&gt;e ^ x を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T exp2(T x)&lt;/td&gt;
&lt;td&gt;2 ^ x を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T exp10(T x)&lt;/td&gt;
&lt;td&gt;10 ^ x を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fdim(T x, T y)&lt;/td&gt;
&lt;td&gt;x &amp;gt; y で x - y,&lt;br&gt;x &amp;lt;= y で +0 を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T floor(T x)&lt;/td&gt;
&lt;td&gt;x を負の無限大に近いほうの整数に丸めた値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fma(T a, T b, T c)&lt;/td&gt;
&lt;td&gt;a * b + c を返す&lt;br&gt;融合積和演算(IEEE 754-2008準拠)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fmod(T x, T y)&lt;/td&gt;
&lt;td&gt;x - y * trunc(x / y) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fract(T x)&lt;/td&gt;
&lt;td&gt;x の小数部を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;frac&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T frexp(T x, Ti &amp;amp;exp)&lt;/td&gt;
&lt;td&gt;x = [返り値] * 2 ^ exp となる&lt;br&gt;返り値は[&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, 1]の範囲か 0 となる&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ti ilogb(T x)&lt;/td&gt;
&lt;td&gt;x の指数を整数で返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T ldexp(T x, Ti k)&lt;/td&gt;
&lt;td&gt;x * 2 ^ k を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T log(T x)&lt;/td&gt;
&lt;td&gt;x の自然対数を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T log2(T x)&lt;/td&gt;
&lt;td&gt;x の 2 を底とする対数を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T log10(T x)&lt;/td&gt;
&lt;td&gt;x の 10 を底とする対数を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fmax(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の最大値を返す&lt;br&gt;片方の引数が NaN なら NaN では無い方の値を返す&lt;br&gt;両方が NaN なら NaN を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fmin(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の最小値を返す&lt;br&gt;片方の引数が NaN なら NaN では無い方の値を返す&lt;br&gt;両方が NaN なら NaN を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T modf(T x, T &amp;amp;intval)&lt;/td&gt;
&lt;td&gt;x を同じ符号を持つ整数部と少数部に分ける&lt;br&gt;少数部を返り値で、整数部を intval で返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T pow(T x, T y)&lt;/td&gt;
&lt;td&gt;x ^ y を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T powr(T x, T y)&lt;/td&gt;
&lt;td&gt;x &amp;gt;= 0 の x ^ y を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T rint(T x)&lt;/td&gt;
&lt;td&gt;x を最近接偶数へ丸めた整数値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T round(T x)&lt;/td&gt;
&lt;td&gt;x を直近の整数値に丸めて返す&lt;br&gt;半分の場合は 0 に近い方となる&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;△&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T rsqrt(T x)&lt;/td&gt;
&lt;td&gt;x の平方根の逆数を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sin(T x)&lt;/td&gt;
&lt;td&gt;x のサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sincos(T x, T &amp;amp;cosval)&lt;/td&gt;
&lt;td&gt;x のサインとコサインを計算する&lt;br&gt;サインを返り値で、コサインを cosval で返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sinh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sinpi(T x)&lt;/td&gt;
&lt;td&gt;pi * x のサインを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T sqrt(T x)&lt;/td&gt;
&lt;td&gt;x の平方根を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T tan(T x)&lt;/td&gt;
&lt;td&gt;x のタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T tanh(T x)&lt;/td&gt;
&lt;td&gt;x のハイパボリックタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T tanpi(T x)&lt;/td&gt;
&lt;td&gt;pi * x のタンジェントを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T trunc(T x)&lt;/td&gt;
&lt;td&gt;x を 0 に近い方向へ丸めた値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;行列関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;行列関数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;float determinant(floatnxn)&lt;br&gt;half determinant(halfnxn)&lt;/td&gt;
&lt;td&gt;行列式を返す&lt;br&gt;行列は正方行列でなければならない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;floatmxn transpose(floatnxm)&lt;br&gt;halfmxn transpose(halfnxm)&lt;/td&gt;
&lt;td&gt;転置行列を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;幾何関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;幾何関数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;T は浮動小数点数(floatn / halfn)のベクター&lt;/li&gt;
&lt;li&gt;Ts はベクターに対応するスカラー&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T cross(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の外積を返す&lt;br&gt;T は3次元ベクトルでなければならない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ts distance(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の距離を求める&lt;br&gt;length(x - y) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ts distance_squared(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の距離の平方を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ts dot(T x, T y)&lt;/td&gt;
&lt;td&gt;x と y の内積を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T faceforward(T N, T I, T Nref)&lt;/td&gt;
&lt;td&gt;dot(Nref, I) &amp;lt; 0.0 で N&lt;br&gt;それ以外は -N を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ts length(T x)&lt;/td&gt;
&lt;td&gt;x のベクトルの長さを返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ts length_squared(T x)&lt;/td&gt;
&lt;td&gt;x のベクトルの長さの平方を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T normalize(T x)&lt;/td&gt;
&lt;td&gt;x の正規化した値を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T reflect(T I, T N)&lt;/td&gt;
&lt;td&gt;入射ベクトル I と面の法線ベクトル N から、反射ベクトル I – 2 * dot(N, I) * N を返す&lt;br&gt;N は正規されていなければならない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T refract(T I, T N, Ts eta)&lt;/td&gt;
&lt;td&gt;入射ベクトル I と面の法線ベクトル N と屈折率 eta から、屈折ベクトルを返す&lt;br&gt;I と N  は正規されていなければならない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;グラフィック関数:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;グラフィック関数&lt;/h2&gt;

&lt;h3 id=&#34;フラグメントシェーダ:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;フラグメントシェーダ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;T はfloat, float2, float3, float4, half, half2, half3, half4&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Metal&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;HLSL&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;GLSL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T dfdx(T p)&lt;/td&gt;
&lt;td&gt;スクリーン空間の指定された x 座標に対する高精度の偏微分を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ddx&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;dFdxFine&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T dfdy(T p)&lt;/td&gt;
&lt;td&gt;スクリーン空間の指定された y 座標に対する高精度の偏微分を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ddy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;dFdyFine&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T fwidth(T p)&lt;/td&gt;
&lt;td&gt;fabs(dfdx(p)) + fabs(dfdy(p)) を返す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;感想:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;さすが後発なだけあって、全部入り。GLSLをベースにHLSLやらOpenCLからありったけ詰め込んだような感じ。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:4dfc7da6cd3b1c47c8c108751f0fee0c&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/std-lib/std-lib.html&#34;&gt;Metal Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OpenGL4.5：&lt;a href=&#34;https://www.opengl.org/sdk/docs/reference_card/opengl45-reference-card.pdf&#34;&gt;API Reference Card&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DirectX：&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/bb509611.aspx&#34;&gt;組み込み関数 (DirectX HLSL)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MetalのGPGPUによるPerlinノイズ</title>
      <link>https://mike-neko.github.io/blog/metal-noise/</link>
      <pubDate>Mon, 25 Jan 2016 19:41:59 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-noise/</guid>
      <description>

&lt;h2 id=&#34;概要:c76c02a9716918700fc6ffc19450c1da&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;GPGPUでリアルタイムにパーリンノイズを生成しテクスチャに書き込んで表示するデモ。&lt;/p&gt;

&lt;p&gt;パーリンノイズはGPU Gems2の改良パーリンノイズで、それを元にした数種類を選択可能。
デモでは3次元ノイズを生成し、z値だけを時間で加算していきノイズを変化させている。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-captioned data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&#34; margin:8px 0 0 0; padding:0 4px;&#34;&gt; &lt;a href=&#34;https://www.instagram.com/p/BBATaXDFQW1/&#34; style=&#34; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&#34; target=&#34;_blank&#34;&gt;ノイズ生成デモ&lt;/a&gt;&lt;/p&gt; &lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;@m_ike__が投稿した動画 - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-01-26T13:57:16+00:00&#34;&gt;2016 1月 26 5:57午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;ソース自体はGPUGemsのサンプルをほぼほぼ書き換えただけなので、ノイズ生成のアルゴリズムなどは参考リンクの方で。。。&lt;/p&gt;

&lt;h3 id=&#34;ノイズ生成の流れ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ノイズ生成の流れ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初期化時に順列テーブル&lt;code&gt;permBuffer&lt;/code&gt;を生成&lt;br /&gt;
初回のみなのでCPU側で生成&lt;br /&gt;
実行時毎にノイズの模様が変化する様にランダムに並び替えを行う&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;毎フレームごと、ComputeShaderでノイズを生成&lt;br /&gt;
シェーダは各種パラメータ&lt;code&gt;NoiseParameter&lt;/code&gt;や順列テーブルなどを受け取って、生成した結果をテクスチャに書き込んで返却する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2のテクスチャを板ポリに貼って描画する&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;computeshader用の設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ComputeShader用の設定&lt;/h3&gt;

&lt;h4 id=&#34;mtkviewの設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;MTKViewの設定&lt;/h4&gt;

&lt;p&gt;ComputeShaderを利用する場合は、&lt;code&gt;MTKView&lt;/code&gt;の&lt;code&gt;framebufferOnly&lt;/code&gt;を&lt;code&gt;false&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただし、パフォーマンスに影響を与えるので、利用しない時は触らないこと。&lt;/p&gt;

&lt;h4 id=&#34;waituntilcompleted:c76c02a9716918700fc6ffc19450c1da&#34;&gt;waitUntilCompleted()&lt;/h4&gt;

&lt;p&gt;各種コマンドの実行の終了するまで待機するメソッド。&lt;br /&gt;
以下のように&lt;code&gt;commandBuffer.commit()&lt;/code&gt;より後に置く。&lt;br /&gt;
描画時のような毎フレームごとの呼び出しの時は、別途 &lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;で処理を待機するので不要だが、
初期化時の1回のみ実行するような場合は、これを使って待機させる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* ~~ （ここでGPGPUのコマンド処理） ~~ */
commandBuffer.commit()
commandBuffer.waitUntilCompleted()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;スレッド:c76c02a9716918700fc6ffc19450c1da&#34;&gt;スレッド&lt;/h3&gt;

&lt;p&gt;GPGPUは大量のスレッドを並列動作させて圧倒的な処理を行うのが特徴だが、モバイルのGPUのため、スレッドグループ毎の最大のスレッド数は512までになっている(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/MetalFeatureSetTables/MetalFeatureSetTables.html&#34;&gt;公式&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;なお、スレッド数は32の倍数にするのが良い。nVIDIAの資料(URL忘れた…)によると64−192ぐらいが一番パフォーマンス的に良いらしいがA系チップに当てはまるかは不明。&lt;/p&gt;

&lt;p&gt;今回は以下のように、スレッドグループは1つのみだが、グループのサイズをテクスチャのサイズと同じにしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// スレッドグループの事前設定
threadgroupSize = MTLSize(width: TexSize, height: TexSize, depth: 1)
threadgroupCount = MTLSize(width: 1, height: 1, depth: 1)

// コマンドバッファへスレッドグループの設定
computeEncoder.dispatchThreadgroups(threadgroupSize, threadsPerThreadgroup: threadgroupCount)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;ここでの注意ポイントは、スレッドの&lt;strong&gt;&lt;em&gt;次元&lt;/em&gt;&lt;/strong&gt;に合わせてシェーダ側の引数も変更が必要なこと。
今回はサイズが2次元(width * height * 1)なので、シェーダ側は&lt;code&gt;uint2 id [[ thread_position_in_grid ]]&lt;/code&gt;と、
&lt;code&gt;uint2&lt;/code&gt;で受け取ることになる(間違えるとシェーダのコンパイルが通らない親切?仕様)。1次元なら&lt;code&gt;uint&lt;/code&gt;で受け取れば良い。&lt;/p&gt;

&lt;p&gt;また、グループが複数だったり1次元のバッファで2次元のグループサイズを指定している様な場合は、&lt;code&gt;threads_per_grid&lt;/code&gt;や&lt;code&gt;thread_position_in_threadgroup&lt;/code&gt;を追加で受け取る必要がある。詳細は公式の&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html&#34;&gt;Attribute Qualifiers for Kernel Function Input&lt;/a&gt;の項目を参照。&lt;/p&gt;

&lt;p&gt;同じスレッドグループ内であれば、メモリの共有ができたりするのだが、そのあたりも公式のサンプル&lt;a href=&#34;https://developer.apple.com/library/ios/samplecode/Metal_NBody_Simulation/Introduction/Intro.html&#34;&gt;Metal N-Body&lt;/a&gt;が参考になる。&lt;/p&gt;

&lt;h3 id=&#34;デバッグ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;デバッグ&lt;/h3&gt;

&lt;p&gt;Xcodeの&lt;code&gt;Capture GPU Frame&lt;/code&gt;がとても便利。&lt;/p&gt;

&lt;p&gt;これを使うと、実行中の各バッファやテクスチャのイメージの様子をキャプチャしてくれる。
バッファのバイナリも見れるので、例えば構造体のアライメントが崩れたりしているのを簡単に見つけることができる。&lt;/p&gt;

&lt;p&gt;また、プロファイル機能も充実していてどこがボトルネックがわかりやすい。&lt;/p&gt;

&lt;h2 id=&#34;感想:c76c02a9716918700fc6ffc19450c1da&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;Metalの発表を聞いて一番ワクワクして触りたかったのが、このGPGPUだった。これまでMacでは統合開発環境でGPGPUが組めなかった（普通のシェーダだけならUnityがあった）ので、使い慣れたXcodeで触れるのは楽しみだった。&lt;/p&gt;

&lt;p&gt;元々ソース自体はGemsのものや参考リンクのものがあったので、移植しただけ。実際にはパラメータやノイズの加工を工夫すれば、雲になったり地形になったりしていくが、パラメータの調整はどうも苦手というか時間がものすごくかかるので、とりあえず今回はここまでで。&lt;/p&gt;

&lt;p&gt;並列化によってどれくらい高速化するのかとか、モバイルのGPGPUでどのくらいパフォーマンスが上がるのか（もちろんバッファの転送が無いだけでも効果は大きいだろうけど）とかが気になったのだけど、それもまた別の機会に・・・&lt;/p&gt;

&lt;p&gt;にしても、シェーダ関係は環境毎に用語が微妙に変わるのは何とかしてほしい。。。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:c76c02a9716918700fc6ffc19450c1da&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;日本語の解説：&lt;a href=&#34;http://postd.cc/understanding-perlin-noise/&#34;&gt;パーリンノイズを理解する(POSTD)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本家：&lt;a href=&#34;http://mrl.nyu.edu/~perlin/&#34;&gt;Ken Perlin&amp;rsquo;s homepage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems Chapter5：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems/gpugems_ch05.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems2 Chapter26：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FragmentShaderで実装や応用例：&lt;a href=&#34;http://www.sci.utah.edu/~leenak/IndStudy_reportfall/Perlin%20Noise%20on%20GPU.html&#34;&gt;Perlin Noise on GPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:c76c02a9716918700fc6ffc19450c1da&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalCompute&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalKitのSwift版サンプル</title>
      <link>https://mike-neko.github.io/blog/metal-model/</link>
      <pubDate>Fri, 22 Jan 2016 00:23:56 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-model/</guid>
      <description>

&lt;h2 id=&#34;概要:6a6245d2d174e54873361b2ccb73e605&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;元ネタのApple公式の&lt;a href=&#34;https://developer.apple.com/library/mac/samplecode/MetalKitEssentials/Introduction/Intro.html&#34;&gt;MetalKitEssentials&lt;/a&gt;をSwiftで書き直し＋αしたもの。
内容は主にMetalKitを使って、obj形式のモデルをテクスチャありで表示させるだけ。
シェーダもいたってシンプルでライトもなし。&lt;br /&gt;
ちなみに、MetalKitは&lt;strong&gt;iOS9以降&lt;/strong&gt;でしか使えないので注意。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:6a6245d2d174e54873361b2ccb73e605&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;はじめに:6a6245d2d174e54873361b2ccb73e605&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;一番最初につまずいたのは、ビルド自体が通らず、Metalのフレームワークのインポートでエラーになる！ってこと。当然、コードを書く時にも自動補完は効かないしエラーでまくるし・・・&lt;br /&gt;
で、原因はターゲットでシュミレータを選択していたこと。実行できないのは知っていたけど、まさかビルドすら通らないのは予想外。。。&lt;/p&gt;

&lt;h3 id=&#34;バッファへのアクセス:6a6245d2d174e54873361b2ccb73e605&#34;&gt;バッファへのアクセス&lt;/h3&gt;

&lt;p&gt;今回、一番書き方が判らなくて苦労したのがこれ。単にVertexBufferへのポインタを取得して、中のデータを読み書きしたいだけなのだが、当然、Swiftがメモリへの直アクセスを許してくれるわけはなく・・・&lt;/p&gt;

&lt;p&gt;上がObjective-Cで書いた場合で下がSwiftの場合：&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/1a7595b9b8cbe769a74d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Swiftでは、まずポインタ&lt;code&gt;p&lt;/code&gt;を明示的に取得し、それから&lt;code&gt;memory()&lt;/code&gt;で&lt;code&gt;VertexUniforms&lt;/code&gt;の型へ変換し、それを通して中のデータへアクセスするという手間が必要。やはりSwiftは型にうるさい。&lt;/p&gt;

&lt;p&gt;なお、このサンプルでは配列ではないので&lt;code&gt;p.memory()&lt;/code&gt;だが、バッファの内容が配列になっていてインデックスでアクセスしたい場合は、&lt;code&gt;p.advancedBy(i).memory()&lt;/code&gt;(iがインデックス)とする。&lt;/p&gt;

&lt;p&gt;ちょっと面倒だけど、暗黙的な「わかる人にはわかる」といった曖昧さを排除し、ポインタの状態やメモリにアクセスしていることを明示させているのは、Swiftの良さの一つだと思う。&lt;/p&gt;

&lt;h3 id=&#34;シェーダ用の構造体:6a6245d2d174e54873361b2ccb73e605&#34;&gt;シェーダ用の構造体&lt;/h3&gt;

&lt;p&gt;今回、シェーダにデータを渡す時の型（構造体）を、シェーダのファイルとSwift上でそれぞれ同じ宣言をしている。これは、Swiftから直接Cのファイルを見に行けない為。ブリッジヘッダを使ったりすれば重複して宣言しなくてよさそうだけど、未検証。Swift上ではSwiftの構造体を使えた方が便利かなと思ったので（結局使わなかったけど）&lt;/p&gt;

&lt;p&gt;なお、当然ながら&lt;strong&gt;メモリのアライメントには注意が必要&lt;/strong&gt;(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html#//apple_ref/doc/uid/TP40014364-CH2-SW15&#34;&gt;公式:アライメント一覧&lt;/a&gt;)なので、必要に応じてパディングすること。ちなみに忘れると画面が心霊現象みたくなったり表示されなかったり・・・&lt;/p&gt;

&lt;h3 id=&#34;simd:6a6245d2d174e54873361b2ccb73e605&#34;&gt;SIMD&lt;/h3&gt;

&lt;p&gt;Xcode7からようやくSIMDがサポート。これでvectorやmatrixのベタなコードを書く or 持ってくる必要がなくなった。（でも移動や回転とかはやっぱり自前が必要）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import simd&lt;/code&gt;で使えるようになる。&lt;code&gt;MetalKit&lt;/code&gt;のインポートでも良い。&lt;/p&gt;

&lt;h2 id=&#34;感想:6a6245d2d174e54873361b2ccb73e605&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;正直なところ、Unityとかに慣れてしまった身にとって、Metalは結構大変だった。。。日本語の資料も少ないし、公式の資料もまだまだObjective-Cが多い感じ。&lt;br /&gt;
といっても、DirectXのダラダラとした初期化とかに比べると、機種依存がなく簡潔で楽。久々に3Dの基礎を振り返る良い機会になったと思う。&lt;br /&gt;
結局まあ、Unityとかが偉大すぎるという当たり前の結論に到達。&lt;/p&gt;

&lt;p&gt;触っていて、良い！と思ったのは、バグで描画がおかしくなったりしても、影響が端末だけに限られて作業しているMacは無事なこと。&lt;br /&gt;
昔々のDirectXでしょっちゅうブルースクリーンを出してしまい、コードが消えたりPC不安定になっていた人なので、これはとても助かった。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:6a6245d2d174e54873361b2ccb73e605&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:6a6245d2d174e54873361b2ccb73e605&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalModel&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>