<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/categories/code/</link>
    <description>Recent content in Code on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Wed, 15 Jun 2016 22:52:40 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/categories/code/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>QRコードの読み取りサンプル(Swift)　その1</title>
      <link>https://mike-neko.github.io/blog/code-reader/</link>
      <pubDate>Wed, 15 Jun 2016 22:52:40 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/code-reader/</guid>
      <description>

&lt;h2 id=&#34;概要:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のカメラでQRコードを読み取り、認識されたコードを枠線で強調表示するサンプル。&lt;/p&gt;

&lt;p&gt;なお、QRコードに限らず、他のバーコードや顔認識にも対応。対応形式は&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/AVFoundation/Reference/AVMetadataMachineReadableCodeObject_Class/index.html#//apple_ref/doc/constant_group/Machine_Readable_Object_Types&#34;&gt;公式&lt;/a&gt;を参照。地味にiOS8から対応形式が増えている。&lt;/p&gt;

&lt;p&gt;あと、2次元なら同時認識できたりするが、その辺りの詳細は参考リンクの公式FAQが詳しい。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;シリアルキューの利用:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;シリアルキューの利用&lt;/h3&gt;

&lt;p&gt;カメラの起動や画像認識は処理が重いので、それぞれ専用のシリアルキューを作成して利用している。&lt;/p&gt;

&lt;p&gt;カメラの設定周りはフリーズ状態になるのを防ぐためだが、最近の端末は起動が早いらしく、キューを使わなくても特に問題無い感じ。&lt;/p&gt;

&lt;h3 id=&#34;avmetadatamachinereadablecodeobject:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;AVMetadataMachineReadableCodeObject&lt;/h3&gt;

&lt;p&gt;認識されたコードは&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;のオブジェクトの配列で渡される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：認識されたコードのフォーマットが逆DNS形式で返ってくる&lt;br /&gt;
(QRの場合は&lt;code&gt;org.iso.QRCode&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringValue&lt;/code&gt;：コードに含まれるデータ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;プレビュー画面上に認識したコードの枠を表示する:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;プレビュー画面上に認識したコードの枠を表示する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;の中の&lt;code&gt;corners&lt;/code&gt;にコードの座標位置が含まれているが、これはプレビューのViewの座標系とは異なるので、そのままでは使えない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の&lt;code&gt;transformedMetadataObjectForMetadataObject&lt;/code&gt;で変換後の座標が入った&lt;code&gt;AVMetadataObject&lt;/code&gt;が取得できるので、その中の&lt;code&gt;bounds&lt;/code&gt;を使って枠線を描画している。&lt;/p&gt;

&lt;p&gt;（以前は手動でちゃんとプレビュー画面上の座標に変換していたが、今回、この簡単に変換できるメソッドを発見！&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の方もちゃんと調べていれば・・・）&lt;/p&gt;

&lt;h2 id=&#34;感想:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;昔iOS7で使えるようになった時に試したものを、Swiftで書き直し＋αしたコード。やはりSwiftはわかりやすく、かつエラー処理もしっかり書いても、Objective-Cよりコードが少ないので良い。&lt;/p&gt;

&lt;p&gt;以前は結構カメラの起動もコードの読み取りも時間がかかっていたのだが、今回はかなりスピードアップした感じがした。iPhoneのカメラの進化もすごいということか。ただ、バッテリーには優しくないので常に使うのは厳しそう・・・&lt;/p&gt;

&lt;p&gt;&lt;del&gt;あと、カメラをわざわざ起動しなくても画像を直接認識してくれるようになって欲しい。&lt;/del&gt;
(6/14追記：方法が判ったのでその2を作成予定)&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/technotes/tn2325/_index.html&#34;&gt;AV Foundation iOS Machine Readable Code Detection FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/CodeReader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UnityからOpenCVを利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/unity-opencv/</link>
      <pubDate>Tue, 07 Jun 2016 00:56:50 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/unity-opencv/</guid>
      <description>

&lt;h2 id=&#34;概要:571ed67a2af601d4cff30db4980e4e99&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;UnityからiOSのネイティブプラグイン経由で&lt;code&gt;OpenCV&lt;/code&gt;でカメラを利用するサンプル。&lt;/p&gt;

&lt;p&gt;内容としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OpenCV経由で端末のカメラ画像を取得&lt;/li&gt;
&lt;li&gt;取得した画像をOpenCVで処理（シンプルにグレースケールへ変換）&lt;/li&gt;
&lt;li&gt;ネイティブプラグイン経由でUnity側(C#)へ渡す&lt;/li&gt;
&lt;li&gt;Unity側でテクスチャを生成して表示する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れになる。&lt;/p&gt;

&lt;h2 id=&#34;手順:571ed67a2af601d4cff30db4980e4e99&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;opencvのフレームワークの準備:571ed67a2af601d4cff30db4980e4e99&#34;&gt;OpenCVのフレームワークの準備&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://opencv.org/downloads.html&#34;&gt;公式のダウンロードページ&lt;/a&gt;から&lt;code&gt;for iOS&lt;/code&gt;の&lt;strong&gt;Ver.2系&lt;/strong&gt;をダウンロードする&lt;br /&gt;
（サンプルでは&lt;a href=&#34;https://sourceforge.net/projects/opencvlibrary/files/opencv-ios/2.4.13/opencv2.framework.zip/download&#34;&gt;Ver.2.4.13&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ダウンロードしたファイルを解凍して&lt;code&gt;opencv2.framework&lt;/code&gt;を取り出しておく&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、Ver.2を利用したのは、作成時点ではVer.3だとエラーが出てしまったので。
多分ソースからビルドするかバージョン上がれば、Ver.3系でも問題ないかと。&lt;/p&gt;

&lt;h3 id=&#34;iosネイティブ部分のソースを作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;iOSネイティブ部分のソースを作成&lt;/h3&gt;

&lt;p&gt;OpenCVがC++なので、言語は&lt;code&gt;Objective-C++&lt;/code&gt;を利用する。&lt;br /&gt;
(残念ながらSwiftはC++を扱うことができないのでObjC一択)&lt;/p&gt;

&lt;p&gt;それに伴い、忘れずにファイルの拡張子を&lt;code&gt;.mm&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただその場合、ヘッダファイル（&lt;code&gt;.hpp&lt;/code&gt;）はUnityがプラグインのファイルとして認識してくれないので、
今回は一つのファイルに収まるように書いている。&lt;br /&gt;
（通常の&lt;code&gt;.h&lt;/code&gt;はちゃんと認識してくれるのに・・・）&lt;/p&gt;

&lt;p&gt;プラグインの呼び出しは以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[iOS]
OpenCV(C++)での処理
 |
ObjC++のクラスでラップ
 |
Cの関数でラッパークラスをエクスポート
 |
[Unity]
C#でDLLimportして呼び出し
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ObjC++で一旦ラップしているのは、OpenCV部分の開発は別にXCode上で行う為。
ただ、場合によってはメソッド呼び出しが遅いのでそこは注意。&lt;/p&gt;

&lt;p&gt;ネイティブ側のソースの全文は以下の通り。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/bf258536e5414e25b1e147c8b5e7834d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h4 id=&#34;通常のopencv周りの処理-4-51行目あたり:571ed67a2af601d4cff30db4980e4e99&#34;&gt;通常のOpenCV周りの処理（4〜51行目あたり）&lt;/h4&gt;

&lt;p&gt;ややこしいのが、C++はARC管理外の為、手動でメモリ管理が必要。
今回はメモリの確保/破棄をラッパークラスの初期化/破棄と合わせて、
ラッパークラスの生存期間とOpenCVのオブジェクトの生存期間が一致するようにしてある。&lt;/p&gt;

&lt;p&gt;カメラの画像の取得は、初期化と同時に&lt;code&gt;cv::VideoCapture&lt;/code&gt;を生成し、
その後は毎フレーム&lt;code&gt;*camera &amp;gt;&amp;gt; img&lt;/code&gt;で画像を読み込んでいる。&lt;/p&gt;

&lt;p&gt;この時、取得された画像のフォーマットは&lt;code&gt;BGR&lt;/code&gt;なのがポイント。
最終的にUnityのテクスチャのサイズとフォーマット&lt;code&gt;RGBA&lt;/code&gt;に変換してUnity側へ渡す。&lt;br /&gt;
（Unity側では&lt;code&gt;ARGB&lt;/code&gt;の表記なので、最初それで変換してハマってた・・・）&lt;/p&gt;

&lt;h4 id=&#34;プラグインのエントリポイントを用意-54-77行目あたり:571ed67a2af601d4cff30db4980e4e99&#34;&gt;プラグインのエントリポイントを用意（54〜77行目あたり）&lt;/h4&gt;

&lt;p&gt;用意するのはラッパークラス&lt;code&gt;VideoCapture&lt;/code&gt;の生成、毎フレーム呼び出す用、破棄の3つのCの関数。&lt;/p&gt;

&lt;p&gt;これを55〜59行目のように宣言してC#へエクスポートする。
このファイルはC++の扱いになっているので&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;が必要。&lt;br /&gt;
（逆に言うと、C#からはこれ以外が見えない状態となっている）&lt;/p&gt;

&lt;p&gt;関数の本体は61行目以降にあるように、単純にブリッジしているだけ。&lt;/p&gt;

&lt;h3 id=&#34;unityでネイティブプラグイン作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;Unityでネイティブプラグイン作成&lt;/h3&gt;

&lt;h4 id=&#34;unityにネイティブのソース類を組み込む:571ed67a2af601d4cff30db4980e4e99&#34;&gt;Unityにネイティブのソース類を組み込む&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Assets&lt;/code&gt;直下に&lt;code&gt;Plugins&lt;/code&gt;フォルダを作る&lt;/li&gt;
&lt;li&gt;作成した&lt;code&gt;Plugins&lt;/code&gt;フォルダにiOSネイティブ用のソースファイルを入れる&lt;br /&gt;
Unityのエディタ上のインスペクタの設定を念のため確認

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Select platforms for plugin&lt;/code&gt;：iOS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Platform settings&lt;/code&gt;：チェック不要&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;Plugins&lt;/code&gt;フォルダにダウンロードしておいた&lt;code&gt;opencv2.framework&lt;/code&gt;を丸ごと入れる&lt;br /&gt;
Unity上ではフォルダとして認識されて、中にいろいろあればOK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;コンポーネントの作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;コンポーネントの作成&lt;/h4&gt;

&lt;p&gt;ネイティブの画像データからテクスチャを生成し、
そのテクスチャを指定した&lt;code&gt;Renderer&lt;/code&gt;のマテリアルにセットするコンポーネントを作成。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5ea8d851f18b163ae6a70f6a05ccd4d1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;当然、ネイティブプラグイン部分は、iOS上での実行時しか動かないので、
該当部分は&lt;code&gt;#if UNITY_IOS&lt;/code&gt;〜&lt;code&gt;#endif&lt;/code&gt;でエディタ実行時にエラーにならないようにしておく。&lt;/p&gt;

&lt;p&gt;ネイティブ側で準備したエントリポイントを利用する為にインポートの宣言（16〜26行目あたり）が必要。&lt;/p&gt;

&lt;p&gt;Cの関数宣言をそのままC#での宣言にするが、同じデータ型がC#にない場合は対応するデータ型を代わりに指定する。
（今回だと&lt;code&gt;void*&lt;/code&gt;が&lt;code&gt;IntPtr&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;なお、構造体をやりとりするような場合は&lt;code&gt;マーシャリング&lt;/code&gt;が必要となるので結構面倒。&lt;/p&gt;

&lt;p&gt;宣言すれば後は通常のメソッドと同じ様に利用できる。ただし、C側と引数などが異なっていた場合は、
実行時にエラーとなるので注意。&lt;/p&gt;

&lt;p&gt;後は、コンポーネントのライフサイクルと、キャプチャ用とテクスチャのオブジェクトのライフサイクルを一致させればOK。&lt;/p&gt;

&lt;h4 id=&#34;シーン作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;シーン作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;キャプチャしたテクスチャ用の&lt;code&gt;Material&lt;/code&gt;を作成

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shader&lt;/code&gt;で&lt;code&gt;Unlit/Texture&lt;/code&gt;を選択&lt;br /&gt;
（キャプチャ画像にライトが反映して光らないように）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quad&lt;/code&gt;でテクスチャを貼るオブジェクトを作成

&lt;ul&gt;
&lt;li&gt;Scaleを&lt;code&gt;X:3, Y:4, Z:1&lt;/code&gt;にする&lt;br /&gt;
（数値はキャプチャ画像のアスペクト比と合わせる）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Material&lt;/code&gt;に1で作成したマテリアルをセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プラグインのコンポーネントを追加

&lt;ul&gt;
&lt;li&gt;プラグインの&lt;code&gt;renderTarget&lt;/code&gt;に自身をセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;感想:571ed67a2af601d4cff30db4980e4e99&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;サンプルでは出てこないけど、C#のアンマネージドの辺りが、ObjCやSwiftに比べると結構大変な気がした。
慣れてないからかも知れないけど、特にメモリ周りやマーシャリングはいずれちゃんと勉強しないと。&lt;/p&gt;

&lt;p&gt;あと、OpenCV周りの細かい挙動もまだ把握しきれていないので調べたい。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:571ed67a2af601d4cff30db4980e4e99&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Unity 5.3.4f1&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:571ed67a2af601d4cff30db4980e4e99&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/UnityOpenCV&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただし、上記ソースには&lt;code&gt;opencv2.framework&lt;/code&gt;が含まれていない。&lt;br /&gt;
（Githubの100MB制限にかかってしまったので）&lt;br /&gt;
動かすには、&lt;code&gt;OpenCVのフレームワークの準備&lt;/code&gt;の項目で準備した
&lt;code&gt;opencv2.framework&lt;/code&gt;を手動で&lt;code&gt;UnityOpenCV/Assets/Plugins/&lt;/code&gt;直下に追加する必要がある。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perfect APNs編</title>
      <link>https://mike-neko.github.io/blog/perfect-push/</link>
      <pubDate>Mon, 11 Apr 2016 19:45:28 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-push/</guid>
      <description>

&lt;h2 id=&#34;概要:895c24bcebc238bc55d3833602dde15b&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその3&lt;/p&gt;

&lt;p&gt;今回はiOSのプッシュ通知を送信する方法について&lt;/p&gt;

&lt;p&gt;Perfectは最新のAPNsの通信形式に対応していて、細かなエラーレスポンスを取れるのがメリット。
なので、開発用としては大変使いやすい。&lt;/p&gt;

&lt;h2 id=&#34;手順:895c24bcebc238bc55d3833602dde15b&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;Push通知はサーバ側で微妙に必要とされる証明書が変わったりするのがややこしいところ。
PerfectでPush通知を送るのに必要なものは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サーバ

&lt;ul&gt;
&lt;li&gt;APNs用証明書と秘密鍵&lt;/li&gt;
&lt;li&gt;CAルート証明書&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;クライアント

&lt;ul&gt;
&lt;li&gt;プロビジョニングプロファイル&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;登録-プロビジョニングプロファイルと証明書の作成:895c24bcebc238bc55d3833602dde15b&#34;&gt;登録〜プロビジョニングプロファイルと証明書の作成&lt;/h3&gt;

&lt;p&gt;証明書の取得には&lt;code&gt;AppID&lt;/code&gt;の登録やら結構手順があって大変だが、まずは以下のリンク先の通りに作業をすればOK。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Qiita:&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb#7-apns%E7%94%A8%E8%A8%BC%E6%98%8E%E6%9B%B8p12%E3%81%AE%E4%BD%9C%E6%88%90&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なお、最後の手順の&lt;code&gt;APNs用証明書(.p12)&lt;/code&gt;を書き出す時のファイル名は&lt;code&gt;apns.p12&lt;/code&gt;とする&lt;/p&gt;

&lt;h3 id=&#34;サーバ用の証明書の準備:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバ用の証明書の準備&lt;/h3&gt;

&lt;h4 id=&#34;apns用証明書-pem:895c24bcebc238bc55d3833602dde15b&#34;&gt;APNs用証明書(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_cert.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -clcerts -nokeys -out apns_dev_cert.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;秘密鍵-pem:895c24bcebc238bc55d3833602dde15b&#34;&gt;秘密鍵(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_key.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -nocerts -out apns_dev_key.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enter PEM pass phrase:&lt;/code&gt;と秘密鍵のパスフレーズを聞かれるので、適当なものを入れる。
後でサーバに設定するので忘れないように・・・&lt;/p&gt;

&lt;h4 id=&#34;caルート証明書:895c24bcebc238bc55d3833602dde15b&#34;&gt;CAルート証明書&lt;/h4&gt;

&lt;p&gt;APNsとサーバで接続する為に&lt;code&gt;Entrust&lt;/code&gt;の証明書が必要なので、以下からダウンロードする。&lt;/p&gt;

&lt;p&gt;Entrust.net Certificate Authority (2048)：
&lt;a href=&#34;https://www.entrust.com/root-certificates/entrust_2048_ca.cer&#34;&gt;entrust_2048_ca.cer&lt;/a&gt;&lt;br /&gt;
（&lt;a href=&#34;https://www.entrust.com/get-support/ssl-certificate-support/root-certificate-downloads/&#34;&gt;Entrustの証明書DLページ&lt;/a&gt; - Entrust.net Certificate Authority (2048) - Download）&lt;/p&gt;

&lt;h3 id=&#34;iosアプリの作成:895c24bcebc238bc55d3833602dde15b&#34;&gt;iOSアプリの作成&lt;/h3&gt;

&lt;p&gt;とりあえず、必要最低限でPush通知を受信できる状態にする。
デバイストークンの更新等には未対応なので注意。&lt;/p&gt;

&lt;h4 id=&#34;プロジェクトの設定:895c24bcebc238bc55d3833602dde15b&#34;&gt;プロジェクトの設定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ダウンロードしたプロビジョニングプロファイルをダブルクリックしてインストール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bundle Identifier&lt;/code&gt;を&lt;code&gt;AppID&lt;/code&gt;取得時のものと一緒にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Provisioning Profile&lt;/code&gt;をインストールしたプロビジョニングプロファイルにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;アプリの実装:895c24bcebc238bc55d3833602dde15b&#34;&gt;アプリの実装&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;AppDelegate&lt;/code&gt;に以下の実装をする&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;でPush通知の登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRegisterForRemoteNotificationsWithDeviceToken&lt;/code&gt;でデバイストークンを受信&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;コードにすると以下の通り
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/8000f2d8dc5b37773323065e867e2e4d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これを実機上で実行すると、端末のデバイストークンがログ出力される。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;デバッグ実行を停止させると、Push通知が届かない場合があるので、デバッグ実行したままにするか
再度実機上からアクティブにしてバックグラウンドに落としておく。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;また、マルチタスクから終了させても届かない場合があるので、注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;サーバへ証明書の設置:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバへ証明書の設置&lt;/h3&gt;

&lt;p&gt;基礎編の&lt;a href=&#34;../perfect-2/&#34;&gt;ビルドでファイルを配置する&lt;/a&gt;の方法で証明書を配置する&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対象のファイル

&lt;ul&gt;
&lt;li&gt;apns_dev_cert.pem&lt;/li&gt;
&lt;li&gt;apns_dev_key.pem&lt;/li&gt;
&lt;li&gt;entrust_2048_ca.cer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Copy Files&lt;/code&gt;の設定

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;:Products Directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subpath&lt;/code&gt;:空白&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（&lt;code&gt;webroot&lt;/code&gt;へのドキュメントの配置とは別に&lt;code&gt;Copy Files&lt;/code&gt;を設定する）&lt;/p&gt;

&lt;h3 id=&#34;サーバの実装:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバの実装&lt;/h3&gt;

&lt;p&gt;サーバ側での実装は主に2つ。
ひとつは証明書を&lt;code&gt;NotificationPusher&lt;/code&gt;に初期設定するのと、
もう一つは実際にPush通知を送る実装。&lt;/p&gt;

&lt;p&gt;初期設定は一度だけ行えばOKなので、（実環境では送信毎にチェックした方が良いけど）
今回は&lt;code&gt;PerfectServerModuleInit&lt;/code&gt;で行う。&lt;/p&gt;

&lt;p&gt;Push通知の送信は、&lt;code&gt;IOSNotificationItem&lt;/code&gt;の配列
（ここのenumの使い方は参考になる）で送信内容を作成し、
&lt;code&gt;NotificationPusher().pushIOS&lt;/code&gt;で送信を行う。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/821b3dced86e0eb741563e23c43fed0f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;この実装でサーバにアクセスする度に、Push通知が端末へ送られる。
送信時の結果は、ブラウザに表示される（エラーであればエラー内容）。&lt;/p&gt;

&lt;h2 id=&#34;感想:895c24bcebc238bc55d3833602dde15b&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回の一番大変だったのはEntrustの証明書の置き場が変わっていたこと。。。
逆に言えばそれ以外はとても簡単にPush通知を送れる環境を作れた感じ。&lt;/p&gt;

&lt;p&gt;巷にはたくさんAPNsに対応したフレームワークやサービスがあるけど、
開発用としては、このPerfectが一番手軽で確実だと思う。
なにせ環境構築は不要で、Xcodeでプロジェクトを作って
少し実装すれば良いだけという素晴らしさ！&lt;/p&gt;

&lt;p&gt;もちろん、商用はAWSとかがオススメだけど。。。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:895c24bcebc238bc55d3833602dde15b&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:895c24bcebc238bc55d3833602dde15b&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iPhone 6+&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 基礎編&lt;a href=&#34;../perfect-2/&#34;&gt;その2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect 基礎編</title>
      <link>https://mike-neko.github.io/blog/perfect-2/</link>
      <pubDate>Sun, 10 Apr 2016 23:09:11 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-2/</guid>
      <description>

&lt;h2 id=&#34;概要:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその2&lt;/p&gt;

&lt;p&gt;基礎編ではルーティングやリクエストの処理方法のあたりまで&lt;/p&gt;

&lt;h2 id=&#34;urlルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;URLルーティング&lt;/h2&gt;

&lt;p&gt;サンプルを見ると、ルーティングは大きくわけて&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mustache&lt;/code&gt;テンプレートエンジンのページを&lt;code&gt;PageHandler&lt;/code&gt;に登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Routing&lt;/code&gt;に&lt;code&gt;RequestHandler&lt;/code&gt;を登録&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2種類がある様子。&lt;/p&gt;

&lt;p&gt;設定はいずれも&lt;code&gt;PerfectServerModuleInit()&lt;/code&gt;の中で行う。&lt;/p&gt;

&lt;h3 id=&#34;pagehandlerでのルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;PageHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;Webアプリなどでの固定ページの表示向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/Authenticator/#authenticator&#34;&gt;Authenticator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;http://0.0.0.0:8181/admin/&lt;/code&gt;というページを表示させたい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;表示するページを-mustache-のテンプレートで作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;表示するページを&lt;code&gt;mustache&lt;/code&gt;のテンプレートで作成&lt;/h4&gt;

&lt;p&gt;例だと&lt;code&gt;admin.mustache&lt;/code&gt;というファイル名にし、先頭のところで&lt;code&gt;handler:AdminHandler&lt;/code&gt;と指定する。&lt;br /&gt;
ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先頭の&lt;code&gt;handler:&lt;/code&gt;の部分で対応する&lt;code&gt;PageHandler&lt;/code&gt;の名前を指定&lt;/li&gt;
&lt;li&gt;ファイル名がアクセスする際のディレクトリと対応&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;テンプレートをプロジェクトへ追加:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;テンプレートをプロジェクトへ追加&lt;/h4&gt;

&lt;p&gt;後述の小ネタにある「ドキュメントの配置」の方法で、&lt;code&gt;admin.mustache&lt;/code&gt;がドキュメントルートへ配置されるように設定する。&lt;/p&gt;

&lt;h4 id=&#34;pagehandler-を作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;&lt;code&gt;PageHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;ページにアクセスがあった時の処理を行う為の&lt;code&gt;PageHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;AdminHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;作ったクラスを&lt;code&gt;PageHandlerRegistry.addPageHandler&lt;/code&gt;で登録する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PageHandlerRegistry.addPageHandler(&amp;quot;AdminHandler&amp;quot;) {
// (r: WebResponse) -&amp;gt; PageHandler in
  return AdminHandler()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addPageHandler&lt;/code&gt;の一つ目の引数の文字列は、テンプレートの中で指定したhandlerと同じにする&lt;/li&gt;
&lt;li&gt;リクエストの詳細な情報で分岐させたい時は、コメントアウトを外し&lt;code&gt;WebResponse&lt;/code&gt;の情報を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;PageHandler&lt;/code&gt;の中では、テンプレートに流し込む変数のDictionaryを生成する。&lt;/p&gt;

&lt;h3 id=&#34;requesthandlerでのルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;RequestHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;APIとかブログのような動的なページ向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/URL%20Routing/#url-routing&#34;&gt;URL Routing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、REST APIで&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;の&lt;code&gt;GET&lt;/code&gt;でmikeというユーザの情報を取得したい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;ルーティングを設定:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ルーティングを設定&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing&lt;/code&gt;でルーティングのルール（HTTPのメソッドやURLなど）を&lt;code&gt;RouteMap&lt;/code&gt;を使って設定する。&lt;/p&gt;

&lt;p&gt;例だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Routing.Routes[&amp;quot;GET&amp;quot;, &amp;quot;/user/{id}&amp;quot;] = { _ in return UserHandler() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPのメソッドが指定できる&lt;br /&gt;
（指定する場合は一つ目にする）&lt;/li&gt;
&lt;li&gt;URL部分は配列で複数指定できる&lt;/li&gt;
&lt;li&gt;ルール部分では&lt;code&gt;{}&lt;/code&gt;で囲うと&lt;code&gt;RequestHandler&lt;/code&gt;へ値を渡せる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;が使える&lt;/li&gt;
&lt;li&gt;クロージャで対応する&lt;code&gt;RequestHandler&lt;/code&gt;を指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;requesthandler-を作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;&lt;code&gt;RequestHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;クライアントへ返すレスポンスを生成する為の&lt;code&gt;RequestHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;UserHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;URLで指定されたユーザ名をそのままJSONで返す場合は以下の感じ。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/55c5d91b5b1d7a309289f5d0b2a12edd.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これで、&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;にアクセスすると&lt;code&gt;{ user: &amp;quot;mike&amp;quot; }&lt;/code&gt;と返ってくる。&lt;/p&gt;

&lt;h4 id=&#34;ルーティング設定の確認:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ルーティング設定の確認&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing.Routes.description&lt;/code&gt;で設定をダンプできる。これ、かなり便利！&lt;/p&gt;

&lt;h2 id=&#34;リクエストの処理:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;リクエストの処理&lt;/h2&gt;

&lt;p&gt;URLパラメータやPOSTのボディの中身は、&lt;code&gt;WebRequest&lt;/code&gt;の中に格納されている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://0.0.0.0:8181/hoge?key1=value1&amp;amp;key2=value2&lt;/code&gt;とした場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  request.queryString()  // key1=value1&amp;amp;key2=value2
  request.queryParams    // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.params()       // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.param(&amp;quot;key1&amp;quot;)  // value1
  request.param(&amp;quot;key3&amp;quot;, defaultValue: &amp;quot;value3&amp;quot;)  // value3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POSTで&lt;code&gt;{ &amp;quot;count&amp;quot;=100 }&lt;/code&gt;を送った場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  let body = request.postBodyString
  let json = try! JSONDecoder().decode(body) as! JSONDictionaryType
  json[&amp;quot;count&amp;quot;]  // 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じで取得できる。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;ドキュメントの配置:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ドキュメントの配置&lt;/h3&gt;

&lt;p&gt;Xcode経由で起動している時に、サーバからドキュメントへアクセスできるようにする方法。なお、ドキュメントルートはデフォルトで&lt;code&gt;./webroot/&lt;/code&gt;が設定されている。&lt;/p&gt;

&lt;h4 id=&#34;documentrootのパスを変更する:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;DocumentRootのパスを変更する&lt;/h4&gt;

&lt;p&gt;状況によってはソースから改変するのもアリだが、起動時に立ち上がるGUIから変更するのが手軽。&lt;code&gt;Choose...&lt;/code&gt;でフォルダ位置を選択できる。ただし、注意すべきなのは&lt;code&gt;Document Root&lt;/code&gt;のテキストフィールド内でキー操作(return)しないと変更と認識されずに保存されない点（これにはまってソースまで見てようやく気付いた・・・）。変更後はサーバの再起動が必要（というか勝手にされるはず）。&lt;/p&gt;

&lt;p&gt;この方法だとサーバを起動したままでもドキュメントを変更できるが、一方でパスの設定が必要となる。&lt;/p&gt;

&lt;h4 id=&#34;ビルドでファイルを配置する:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ビルドでファイルを配置する&lt;/h4&gt;

&lt;p&gt;前回の導入編で使った方法で、デフォルトの&lt;code&gt;./webroot/&lt;/code&gt;を使いたい場合用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作成したプロジェクトを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TARGETS&lt;/code&gt;でプロジェクト名と同じもの、&lt;code&gt;Build Phases&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;左上の&lt;code&gt;＋&lt;/code&gt;をクリックして、&lt;code&gt;New Copy Files Phases&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;で&lt;code&gt;Products Directory&lt;/code&gt;を選択&lt;br /&gt;
&lt;code&gt;Subpath&lt;/code&gt;に&lt;code&gt;webroot&lt;/code&gt;と入力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;の下の方にある&lt;code&gt;＋&lt;/code&gt;をクリックし、追加ファイルを選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;
（プロジェクトに未追加のファイルの場合は&lt;code&gt;Add Other...&lt;/code&gt;からで）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;同一lan内からのアクセス:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;同一LAN内からのアクセス&lt;/h3&gt;

&lt;p&gt;例えば同じルータに繋がっているiPhoneから、Mac上で動いているPerfectのサーバに接続する方法。&lt;/p&gt;

&lt;p&gt;起動時に立ち上がるGUIの&lt;code&gt;Server Address&lt;/code&gt;をMacに割り当てられているIPアドレスに変更すればOK。
（変更後にreturnで確定を忘れずに・・・）
ポートも変更できるが、&lt;code&gt;80&lt;/code&gt;とかはroot権限が必要と怒られて変更できないので注意。&lt;/p&gt;

&lt;p&gt;（今回は既に&lt;a href=&#34;../docker/&#34;&gt;Docker+nginxを構築&lt;/a&gt;してあったので、nginxのリバースプロキシの設定でさくっと対応）&lt;/p&gt;

&lt;h1 id=&#34;感想:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;普段、クライアント（iOSアプリ）側で使っている開発環境と全く同じ環境でサーバの開発が出来るというのは、
想像以上に便利というかストレスフリーな感じ。&lt;/p&gt;

&lt;p&gt;もちろん、PerfectではCocoaが使えないというのはあるし、物足りない感じはしなくも無いが。。。&lt;/p&gt;

&lt;p&gt;ただ、そのあたりのカバーを目指しての&lt;code&gt;Perfect&lt;/code&gt;という命名なんだろうと勝手に想像。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chrismanahan.com/creating-a-web-service-swift-perfect&#34;&gt;Creating a Web Service for Your App in Swift with Perfect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Xcode 7.3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect APNs編&lt;a href=&#34;../perfect-push/&#34;&gt;その3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPアドレス取得のサンプル(Swift)</title>
      <link>https://mike-neko.github.io/blog/ipaddress/</link>
      <pubDate>Mon, 07 Mar 2016 23:59:45 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/ipaddress/</guid>
      <description>

&lt;h2 id=&#34;概要:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のIPアドレスを取得するサンプル。Cの関数呼び出し周りも含めてSwiftにて実装。&lt;/p&gt;

&lt;p&gt;一応、Apple公式の方法でIPv6only環境でも動作確認済。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;cの関数呼び出し:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;Cの関数呼び出し&lt;/h3&gt;

&lt;p&gt;端末内部のネットワーク情報を取得する為に、&lt;code&gt;getifaddrs&lt;/code&gt;や&lt;code&gt;inet_ntop&lt;/code&gt;などの関数を呼び出すが、
通常のCであればファイルの頭で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ifaddrs.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするが、Swiftなので&lt;code&gt;Bridging-Header.h&lt;/code&gt;を用意して、そこに&lt;code&gt;include&lt;/code&gt;を書く。&lt;/p&gt;

&lt;p&gt;あと、ヘッダを追加した後にはビルド設定の&lt;code&gt;Objective-C Bridging Header&lt;/code&gt;も忘れずに変更。&lt;/p&gt;

&lt;h3 id=&#34;デバイス:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;デバイス&lt;/h3&gt;

&lt;p&gt;とりあえず今回は、IPアドレスを取りたいだけなので、WiFi(&lt;code&gt;en0&lt;/code&gt;)とCellular(&lt;code&gt;pdp_ip0&lt;/code&gt;)の
デバイスのみチェックしている。&lt;/p&gt;

&lt;h3 id=&#34;swiftの言語的なこと:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;Swiftの言語的なこと&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;がとっても便利。これのおかげでリソースの解放のような後始末が必要なコードが、
とても簡単にかけるし処理漏れもなくなるので素晴らしい！&lt;br /&gt;
(これが無いと今回のように処理の中でエラーで返すような場合はコードが面倒になる)&lt;/p&gt;

&lt;p&gt;ポインタが見えなくなったり、型が厳格になってC系のソースの移植が面倒に思えるけど、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対応する型への変換（特に&lt;code&gt;UnsafePointer&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;C++の&lt;code&gt;-&amp;gt;&lt;/code&gt;に相当するのが&lt;code&gt;memory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;[]&lt;/code&gt;に相当するのが&lt;code&gt;advancedBy&lt;/code&gt;(今回は出てこないけど)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と言ったあたりを押さえておけばOKな気がする。&lt;/p&gt;

&lt;p&gt;確かに冗長な感じは否めないが、型は書かなくても済むことが多いし、
逆に一度正しく変換しておけば後はコンパイラで型チェックが行われるのは安心できる。&lt;/p&gt;

&lt;p&gt;この辺りのバランス感覚がSwiftは絶妙だと思う。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html&#34;&gt;IPv6only環境の確認方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html&#34;&gt;CのAPIをSwiftで使う方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;li&gt;Mac OS 10.11.3(NAT64ネットワーク)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/NetworkInfo&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metalによる砂のシミュレーションもどき</title>
      <link>https://mike-neko.github.io/blog/metal-sand/</link>
      <pubDate>Thu, 25 Feb 2016 22:05:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-sand/</guid>
      <description>

&lt;h2 id=&#34;概要:41585ab4c2e78900081a05c039c1f55d&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;MetalのGPGPUによる大量のパーティクル処理能力を活かしたデモ。
パーティクルをそれぞれ砂の一粒に見立てており、上から落下してきた砂粒が山のように積みあがっていく様子をシュミレートしている。&lt;/p&gt;

&lt;p&gt;なお、これも約26万パーティクルで60FPSを維持している。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BCX1ylEFQd_/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-29T13:51:35+00:00&#34;&gt;2016 2月 29 5:51午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;（2色にして拡大してみたけど、動画だとイマイチになってしまった・・・）&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;砂の動き:41585ab4c2e78900081a05c039c1f55d&#34;&gt;砂の動き&lt;/h3&gt;

&lt;p&gt;タイトルに「もどき」とある通り、砂の動きは粒子法などのちゃんとした物理計算をしているわけではないが、GameGems本の中の地形生成の粒子堆積を参考にしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;フラクタル地形生成-粒子堆積:41585ab4c2e78900081a05c039c1f55d&#34;&gt;フラクタル地形生成-粒子堆積&lt;/h4&gt;

&lt;p&gt;&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-25-metal-sand/gems4-19-3.png&#34; /&gt;
&lt;/figure&gt;

出典：Game Programming Gems&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上図にあるように、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子を地面（粒子）にぶつかるまで落下させる&lt;/li&gt;
&lt;li&gt;ぶつかった地点の周囲で最も低い地点を探す&lt;br /&gt;
見つからなければそこに粒子を固定（地面化）させて終了&lt;/li&gt;
&lt;li&gt;2で見つかった地点に粒子を移動させる&lt;/li&gt;
&lt;li&gt;1に戻って落下させ続ける&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをGPUで計算している。&lt;/p&gt;

&lt;h3 id=&#34;コンピュートシェーダのコード:41585ab4c2e78900081a05c039c1f55d&#34;&gt;コンピュートシェーダのコード&lt;/h3&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/c6997165804cbaa25402.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU側で砂の初期位置とy軸への落下速度を設定&lt;/li&gt;
&lt;li&gt;コンピュートシェーダで砂の動きを計算して描画用バッファへ書き出し&lt;/li&gt;
&lt;li&gt;バーテックスシェーダとフラグメントシェーダはシンプルにパーティクルを描画&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;h4 id=&#34;地面との衝突判定:41585ab4c2e78900081a05c039c1f55d&#34;&gt;地面との衝突判定&lt;/h4&gt;

&lt;p&gt;今回は地面との衝突の判定のみで、粒子間の衝突などは考慮しない。よって、512*512のバッファ&lt;code&gt;laminateBuffer&lt;/code&gt;を地面に見立てて、各座標の高さを記録している。ここでテクスチャを使っていないのは、コンピュートシェーダではテクスチャの読み書きを同時に行うことができない為。&lt;/p&gt;

&lt;p&gt;地面にぶつかったら、元の位置からそれぞれ30度+αずつずらした位置の地面の高さを見て、一番低いところを探す。なお、ここで手を抜いてsincosを使わなければ、四角い山ができてしまう・・・&lt;/p&gt;

&lt;p&gt;一番低いところの判定を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = mix((float)min_id, 1.f, not(step(h[1], h[min_id])));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としているが、これは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = (h[1] &amp;lt;= h[min_id]) ? min_id : 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同じである。(Metalの座標系のy軸は上が-になる)&lt;/p&gt;

&lt;p&gt;現在位置が一番低い場所であれば、y軸の速度を0にして粒子を固定する。同時に地面の高さも更新し、次回参照時からはそこが地面の扱いとなる。&lt;/p&gt;

&lt;p&gt;あとはこれをひたすら繰り返していくと山のように積み重なっていく。&lt;/p&gt;

&lt;h2 id=&#34;感想:41585ab4c2e78900081a05c039c1f55d&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;パラメータの調整とかバッファへの書き込みの精度を上げたりするなど、まだまだ改良の余地はありそう。。。&lt;/p&gt;

&lt;p&gt;なんにしても単純な方法を力任せに処理してもちゃんと動くあたり、GPGPUは頼もしい。&lt;/p&gt;

&lt;p&gt;あと、GameGemsの1以外も電子書籍で出ないかなぁ。内容的には古くても色々参考になるし、紙版は置く場所考えるとどうしても買いづらいので&lt;/p&gt;

&lt;h1 id=&#34;開発環境:41585ab4c2e78900081a05c039c1f55d&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:41585ab4c2e78900081a05c039c1f55d&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalSand&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SwiftでNSExceptionを処理する</title>
      <link>https://mike-neko.github.io/blog/objc-exception/</link>
      <pubDate>Sat, 20 Feb 2016 08:10:44 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/objc-exception/</guid>
      <description>

&lt;h2 id=&#34;概要:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;ObjectiveCで書かれた&lt;code&gt;NSException&lt;/code&gt;を発生させるソースをSwiftから利用したい時の処理方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NSException&lt;/code&gt;は、ObjectiveCの&lt;code&gt;@try ~ @catch ~ @finally&lt;/code&gt;でしか例外処理を行えない。例外処理を書いていない時は、実行時エラーとして処理される。つまり、Swiftから&lt;code&gt;NSException&lt;/code&gt;を発生させるコードを呼び出して例外が起きると、問答無用でアプリが落ちてしまう・・・&lt;/p&gt;

&lt;p&gt;対応策としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;元のコードもSwiftで書き換えてしまう&lt;/li&gt;
&lt;li&gt;そもそも例外は起きるはずがないので&lt;del&gt;落ちていい&lt;/del&gt;無視する&lt;/li&gt;
&lt;li&gt;該当のメソッドを呼び出す部分をブリッジするラッパを作る&lt;/li&gt;
&lt;li&gt;なんとかしてSwiftで&lt;code&gt;NSException&lt;/code&gt;の例外を処理する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった感じになると思うが、サードパーティのライブラリとかだと1や2の方法が取れない場合がある。
3も該当のメソッドが多ければ作業量が多くなるし、ソースの見通しも悪くなる。&lt;/p&gt;

&lt;p&gt;なので、今回は4の方法で例外を処理する方法についてメモしておく。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;基本的な考えた方は3と同じで、ObjectiveCでしか処理できない部分だけラップしてしまえ〜となる。
まずは以下の様なブリッジ用のObjectiveCのクラスを作る。（&lt;code&gt;Bridging-Header&lt;/code&gt;への追加も忘れずに）&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5add082e4f51059161ce.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;中は見ての通り、例外処理のそれぞれの中身をクロージャ（ブロック）でブリッジ用のクラスに渡している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nonnull&lt;/code&gt;や&lt;code&gt;nullable&lt;/code&gt;をつけているのは、Swift側から呼び出す時に&lt;code&gt;Optional&lt;/code&gt;になるかどうかを制御する為。&lt;code&gt;finally&lt;/code&gt;は不要なことも多々あるので&lt;code&gt;nil&lt;/code&gt;を渡せる様に&lt;code&gt;nullable&lt;/code&gt;にしている。&lt;/p&gt;

&lt;p&gt;（意図して処理がないことを明示させる為に空ブロックではなく&lt;code&gt;nil&lt;/code&gt;を渡せる様にしている）&lt;/p&gt;

&lt;h3 id=&#34;使い方:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;Swiftから呼び出す時は以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try({ _ in
  // NSExceptionが起きるかもしれない処理
},

objC_catch: { (NSException) in
  // 例外発生時の処理
},

objC_finally: { _ in
  // 後処理とか...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;finally&lt;/code&gt;が不要であれば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try({ _ in
  // NSExceptionが起きるかもしれない処理
},

objC_catch: { (NSException) in
  // 例外発生時の処理
},

objC_finally: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もし複数の&lt;code&gt;catch&lt;/code&gt;が使いたい場合は、これを元に拡張すればOK。&lt;/p&gt;

&lt;h3 id=&#34;nonnullやnullableのアノテーションについて:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;nonnullやnullableのアノテーションについて&lt;/h3&gt;

&lt;p&gt;ObjectiveC側でアノテーションを指定すると、Swiftとの連携時のメソッドの型にも反映される。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ObjC&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Swift&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;変換前(ObjC)&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;変換後(Swift)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;未指定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)!&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;nonull&lt;br&gt;_Nonnull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge* _Nonnull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;nullable&lt;br&gt;_Nullable&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)?&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge* _Nullable&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;例えば、今回のメソッドをSwiftから呼び出す時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try(objC_try: () -&amp;gt; Void, objC_catch: (NSException) -&amp;gt; Void, objC_finally: (() -&amp;gt; Void)?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形式になっていて、&lt;code&gt;objC_finally&lt;/code&gt;を&lt;code&gt;nullable&lt;/code&gt;にしたので、ちゃんと&lt;code&gt;?&lt;/code&gt;のついた&lt;code&gt;Optional&lt;/code&gt;になっているし、それ以外は&lt;code&gt;nonnull&lt;/code&gt;なので型がそのまま使われている。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/ObjC_Exception&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UnityのSprite用シェーダ(2本)</title>
      <link>https://mike-neko.github.io/blog/sprite-shader/</link>
      <pubDate>Tue, 16 Feb 2016 04:13:47 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/sprite-shader/</guid>
      <description>

&lt;h2 id=&#34;概要:5faa08a3423ea1353ad8985880ae422e&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Unity公式のスプライトシェーダをベースにした、スプライトにエフェクトをつけるシェーダ2本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定色でベタ塗りにするシェーダ：&lt;code&gt;SpriteBetaMask&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定色でアウトラインと影をつけるシェーダ：&lt;code&gt;SpriteOutline&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ベタ塗りシェーダ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;ベタ塗りシェーダ&lt;/h3&gt;

&lt;p&gt;未取得のアイテムをシルエット表示にしておきたいといった場合に、
わざわざ画像を別に用意しなくても良いように作ったシェーダ&lt;/p&gt;

&lt;h4 id=&#34;プロパティ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;プロパティ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mask Color&lt;/code&gt;：ベタ塗りにする時の色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mask On&lt;/code&gt;：&lt;code&gt;true&lt;/code&gt;でベタ塗り状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tint&lt;/code&gt;：乗算する頂点色（SpriteRendererのColorと同じ）&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/beta.gif&#34; /&gt;
&lt;/figure&gt;


&lt;h3 id=&#34;アウトラインシェーダ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;アウトラインシェーダ&lt;/h3&gt;

&lt;p&gt;枠をつけてちょっと目立たせたいとか簡単な影を落としたいといった場合に、
画像を別に用意しなくても良い＆ある程度動的に変化できるように作ったシェーダ&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/outline.gif&#34; /&gt;
&lt;/figure&gt;


&lt;h4 id=&#34;プロパティ-1:5faa08a3423ea1353ad8985880ae422e&#34;&gt;プロパティ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OutLine Spread&lt;/code&gt;：アウトラインの幅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Outline Color&lt;/code&gt;：アウトラインの色&lt;br /&gt;
&lt;em&gt;α値は無視される&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shadow Offset X&lt;/code&gt;/&lt;code&gt;Shadow Offset Y&lt;/code&gt;：影の位置&lt;br /&gt;
&lt;em&gt;アウトラインの幅がある場合は、&lt;code&gt;アウトラインの幅 + 影の位置&lt;/code&gt;を設定&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shadow Color&lt;/code&gt;：影の色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alpha&lt;/code&gt;：全体のα値&lt;br /&gt;
&lt;em&gt;スプライト全体のαを変化させたい時は、SpriteRendererではなくこの値を使って変化させる&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;制約事項:5faa08a3423ea1353ad8985880ae422e&#34;&gt;制約事項&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;本来のスプライトのサイズより小さくなるので注意&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Multiple Spriteでの使用は非推奨&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;キャラのように複雑な形状とかの場合は途切れる可能性あり&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※手抜きしたい時用なので、特に3つ目などの場合は画像自体を作るか2パスとかの正攻法での対応を。。。&lt;/p&gt;

&lt;h4 id=&#34;説明:5faa08a3423ea1353ad8985880ae422e&#34;&gt;説明&lt;/h4&gt;

&lt;p&gt;スプライトにアウトラインや影を簡単につけるには、参考リンクにあるような方法があるが、uGUIでしか使えないのと、太めの線をつけることができなかったので、自作した。&lt;/p&gt;

&lt;p&gt;アウトラインや影も特別なことをしている訳ではなく、フラグメントシェーダで指定された分の幅をずらしてテクスチャを見に行き、画像がある（＝αがしきい値以上）ならアウトラインないし影の色を出力しているだけ。&lt;/p&gt;

&lt;p&gt;0ではなくしきい値（コード内では&lt;code&gt;THRESHOLD&lt;/code&gt;の&lt;code&gt;0.1&lt;/code&gt;）にしたのは、縁取りをキレイにみせる為。固定値にしているが、使う画像によっては値を変えたりプロパティ化しても良いかも。それと、&lt;code&gt;lerp&lt;/code&gt;とか&lt;code&gt;sign&lt;/code&gt;を使っているのは&lt;code&gt;if&lt;/code&gt;などの分岐命令を使いたくなかったからだけど、これぐらいなら素直に分岐を使った方が楽だったかも・・・&lt;/p&gt;

&lt;p&gt;さて、アウトラインシェーダの重要なポイントは、バーテックスシェーダのテクスチャのUV座標を縮小させている（下の13-14行目あたりの）ところ。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/f85e50d1f52d136b8e5f.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これが無いと太めのアウトラインや影をつけた時に途中で切れてしまう。初めはこの理由が判らなくてかなりハマってしまったのだけど、シーンの描画をワイヤフレームにして一目瞭然！Unityの
スプライトは賢いことに、単に板ポリに画像を貼り付けるのではなく、ちゃんと形状に合わせてポリゴン分割をしてくれている。多分、四角形より描画範囲が狭くなるのでパフォーマンスがあがるからだろうけど、逆に余白がほぼ0に近い状態になるので太めの線だと切れてしまっていた。&lt;/p&gt;

&lt;p&gt;なので、ポリゴンはそのままで中に表示する画像を縮小することで、無理やり余白を作っている。（モデルを法線方向へ膨らます通常のアウトラインシェーダとは逆にしてみた）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/comp.png&#34; /&gt;
&lt;/figure&gt;

（左側が余白を作った状態なので、多少太めの線を引いても途切れない。逆に右側の通常のスプライトだと余白がほぼないのですぐに途切れてしまう。縮小する割合&lt;code&gt;1.2&lt;/code&gt;は実際に試して自分の環境でバランスのとれた値なので、必要に応じて調整を）&lt;/p&gt;

&lt;p&gt;ただ、それが逆に制約事項につながってしまっている。Multiple Spriteについては、隣のスプライトとの距離が近すぎるとそれが表示されてしまう場合があるし、ポリゴンがトゲトゲの様な感じの形状だとその部分が途切れてしまう。（が、自分の環境では特に問題にならないので&lt;del&gt;放置&lt;/del&gt;今後の課題に）&lt;/p&gt;

&lt;h2 id=&#34;感想:5faa08a3423ea1353ad8985880ae422e&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回のサンプルに使わせてもらったこのキャラってなんて言うんだろう？？&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:5faa08a3423ea1353ad8985880ae422e&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;http://unity3d.com/jp/get-unity/download/archive&#34;&gt;シェーダ置き場&lt;/a&gt;&lt;br /&gt;
（バージョン毎のダウンロードから「ビルトインシェーダ」を選択）&lt;/li&gt;
&lt;li&gt;お手軽なuGUIでの方法：&lt;a href=&#34;http://tsubakit1.hateblo.jp/entry/2014/09/10/224446&#34;&gt;テラシュールブログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:5faa08a3423ea1353ad8985880ae422e&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Unity 5.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:5faa08a3423ea1353ad8985880ae422e&#34;&gt;ソース&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample&#34;&gt;プロジェクト一式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ベタ塗りシェーダ(&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample/blob/master/Assets/Shaders/SpriteBetaMask.shader&#34;&gt;ソースのみ&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;アウトラインシェーダ(&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample/blob/master/Assets/Shaders/SpriteOutline.shader&#34;&gt;ソースのみ&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div&gt;
	&lt;img src=&#34;http://unity-chan.com/images/imageLicenseLogo.png&#34; alt=&#34;ユニティちゃんライセンス&#34;&gt;
	&lt;p&gt;この作品は&lt;a href=&#34;http://unity-chan.com/contents/license_jp/&#34; target=&#34;_blank&#34;&gt;ユニティちゃんライセンス条項&lt;/a&gt;の元に提供されています&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalのGPGPUによるパーティクルデモ</title>
      <link>https://mike-neko.github.io/blog/metal-image/</link>
      <pubDate>Thu, 11 Feb 2016 09:20:27 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-image/</guid>
      <description>

&lt;h2 id=&#34;概要:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;読み込んだテクスチャをパーティクルに分解して動かすデモ。動きは滝のように画像がパーティクルに分解して落下していくのをイメージ。&lt;/p&gt;

&lt;p&gt;画像サイズが512*512、1ピクセル=1パーティクルに分解するので、約26万個のパーティクルを動かしているが、60FPSを維持している。約100万まで増やすとiPhone6+で30FPSぐらいとなる。&lt;/p&gt;

&lt;p&gt;そんなに複雑な計算をさせていないとはいえ、さすがGPGPUといったところ。なお、処理時間のほとんどはGPGPUの部分でCPUは余力がある様子。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:62.3366013072% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BBn2nSclQZi/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-10T22:35:15+00:00&#34;&gt;2016  2月 10 2:35午後 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちなみに実機で見るともっとキレイ&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;処理はおおまかにわけて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事前処理として、テクスチャを読み込んで、ピクセル数分のバッファを確保&lt;/li&gt;
&lt;li&gt;テクスチャからパーティクルを生成&lt;/li&gt;
&lt;li&gt;生成したパーティクルを動かす&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。事前処理はCPU側で行い、以降はそれぞれ専用のシェーダを準備して、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成用シェーダ&lt;code&gt;fallImageSetup&lt;/code&gt;をセットしてパーティクルを生成&lt;/li&gt;
&lt;li&gt;実行用シェーダ&lt;code&gt;fallImageCompute&lt;/code&gt;へ切り替えてパーティクルを動かす&lt;/li&gt;
&lt;li&gt;動き終われば1へ戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れでループする。&lt;/p&gt;

&lt;p&gt;注意点として、画像の座標とMetalでの座標軸は違うので、x軸とy軸に−1のスケールをかけて補正している。テクスチャ読み込み時に何かできるかは未調査だが、そもそもこういうテクスチャの使い方は普通しないと思うのでそのまま。&lt;/p&gt;

&lt;h3 id=&#34;テクスチャからパーティクルを生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;テクスチャからパーティクルを生成&lt;/h3&gt;

&lt;h4 id=&#34;パーティクルの位置の計算:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルの位置の計算&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// ImagePiece* particles [[ buffer(0) ]]
// uint2 id [[ thread_position_in_grid ]]
// uint2 size [[ threads_per_grid ]]
// uint index = id.x + id.y * size.x;
particles[index].position = float4(id.x / (float)size.x, id.y / (float)size.y, 0, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージとしては1*1の板ポリの中にすべてのパーティクルを配置する感じで、各パーティクルのローカル座標が(0, 0)から(1, 1)の中に収まるようにする。&lt;/p&gt;

&lt;h4 id=&#34;画像の対応するピクセルの色を取得:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;画像の対応するピクセルの色を取得&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// texture2d&amp;lt;float, access::read&amp;gt; image [[ texture(0) ]]
particles[index].color = image.read(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は1ピクセル=1パーティクル、スレッドも同じように分割しているので、テクスチャの対応するピクセルの座標は、そのままグリッド内のスレッド位置と同じになる。&lt;/p&gt;

&lt;h4 id=&#34;動きのパラメータの初期設定:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動きのパラメータの初期設定&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// param.time.w : y方向のdelay
// rnd : 乱数
float rnd_d = param.time.w * (1 - (float)rnd / UINT_MAX * 0.1);  // 1

// param.delta : 各軸の1フレーム毎の移動量
particles[index].acc = float4(param.delta.x, param.delta.y, param.delta.z, rnd_d * id.y);  // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下の方から順にパーティクルが落ちるように、画像の上の方ほど遅れて落ち始めるようにで遅延を設定する(2の&lt;code&gt;rnd_d * id.y&lt;/code&gt;部分)。また落ち方がそれっぽく見えるように、遅延時間は元の指定の100%〜90%の間でばらつくように乱数を使う(1の部分)。&lt;/p&gt;

&lt;h3 id=&#34;パーティクルに動きをつける:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルに動きをつける&lt;/h3&gt;

&lt;h4 id=&#34;位置の更新:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;位置の更新&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// particles[index].acc.w : delay
// param.time.x : スタートからの経過時間
// param.time.y : 前フレームからの経過時間
float t = fmax(0.f, param.time.x - particles[index].acc.w) * param.time.y * rnd_d;
particles[index].position += t * particles[index].acc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パーティクルの位置は、スムーズに見えるように&lt;code&gt;前回からの経過時間*時間あたりの移動量&lt;/code&gt;で計算する。ただし、各パーティクルには遅延時間があるので、それを経過するまでは経過時間は0として動かないようにする(&lt;code&gt;fmax(0.f, param.time.x - particles[index].acc.w)&lt;/code&gt;の部分)。さらに、こちらも乱数で落ち方にばらつきを与える。&lt;/p&gt;

&lt;h4 id=&#34;消滅処理:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;消滅処理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;float4 f = step(param.delta.w, particles[index].position + t * particles[index].acc);
particles[index].color.a -= (1 - f.x * f.y * f.z) * 0.1 * rnd_d * 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定距離落ちれば徐々に消滅したように見せる為に、まず&lt;code&gt;step()&lt;/code&gt;で指定した距離を超えていないかチェックする。超えていれば、該当の要素が0になるのでαが減算されて消えたように見せかける（パーティクル自体は生きている）。ここも乱数で消え方にばらつきを与える。&lt;/p&gt;

&lt;p&gt;ここでハマったのが、アルファブレンドをONにするのを忘れていて全然消えてくれなかったこと・・・&lt;br /&gt;
デフォルトではフラグメントシェーダでどれだけαを変更しても無視されるので、&lt;code&gt;pipelineDescriptor.alphaToCoverageEnabled = true&lt;/code&gt;でαの指定を有効にする。&lt;/p&gt;

&lt;p&gt;ポイントとなるのは、フラグメントシェーダ内の&lt;code&gt;if (in.color.a &amp;lt; 0.1) discard_fragment();&lt;/code&gt;という見えなくなったピクセルの破棄処理。なくてもパーティクルは消えてくれるが、この処理を行うことで若干フレームレートが改善するので入れた（&lt;del&gt;単に使ってみたかっただけ&lt;/del&gt;）。&lt;/p&gt;

&lt;h3 id=&#34;乱数の生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;乱数の生成&lt;/h3&gt;

&lt;p&gt;Metalではシェーダ上で使える乱数の関数は準備されていない為、使いたい場合はシェーダ上で自前で実装するかCPU側で生成したものを渡して使うかになる。今回はCPU側でほとんど処理しないので、シェーダ上で実装する方を選択した。&lt;/p&gt;

&lt;p&gt;乱数のアルゴリズムは幾つかあるし、このデモでの利用方法なら前回作ったようなノイズ関数を用いても良いが、ちょうど少し前に面白い記事(参考リンク参照)を見つけたので、&lt;code&gt;xorshift&lt;/code&gt;を採用することにした。32bitにしたのは、もしCPU側とやりとりする場合（シードの初期値など）に、64bit以上の型は直接渡せない為。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/b1c006b69ccb57261f7d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;今回はシードの初期値に&lt;code&gt;2463534242&lt;/code&gt;の値を直で指定している。もし本当にランダムにしたいならCPU側から現在のミリ秒あたりを渡して設定すればよい。&lt;/p&gt;

&lt;p&gt;ポイントは、生成された乱数が次回のシードになるので、アドレス空間に&lt;code&gt;threadgroup&lt;/code&gt;を指定していること。これにより同じスレッドグループ内のスレッドでこのシードが共有されるようになる。（指定しないと毎回初期値が設定されてしまう。）&lt;/p&gt;

&lt;p&gt;しかし、GPGPUでは同時にスレッドが並列で幾つも実行される為、単にシードを共有するだけでは同じシードを複数のスレッドを使うことになり、結果が偏ったものになってしまう。そこで、シードを渡す時に&lt;code&gt;rotate(rnd, id.x)&lt;/code&gt;として値をばらつかせている（フローの起きないrotateが標準で使えるのは、ほんと助かる）。&lt;/p&gt;

&lt;p&gt;得られる結果は&lt;code&gt;uint&lt;/code&gt;なので、実際のコード内では使いやすいよう&lt;code&gt;(float)rnd / UINT_MAX&lt;/code&gt;として正規化してから使っている。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;乱数のアルゴリズムの解説記事&lt;br /&gt;
&lt;a href=&#34;https://blog.visvirial.com/articles/575&#34;&gt;Google Chromeが採用した、擬似乱数生成アルゴリズム「xorshift」の数理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalImage&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalのGPGPUによるPerlinノイズ</title>
      <link>https://mike-neko.github.io/blog/metal-noise/</link>
      <pubDate>Mon, 25 Jan 2016 19:41:59 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-noise/</guid>
      <description>

&lt;h2 id=&#34;概要:c76c02a9716918700fc6ffc19450c1da&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;GPGPUでリアルタイムにパーリンノイズを生成しテクスチャに書き込んで表示するデモ。&lt;/p&gt;

&lt;p&gt;パーリンノイズはGPU Gems2の改良パーリンノイズで、それを元にした数種類を選択可能。
デモでは3次元ノイズを生成し、z値だけを時間で加算していきノイズを変化させている。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-captioned data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&#34; margin:8px 0 0 0; padding:0 4px;&#34;&gt; &lt;a href=&#34;https://www.instagram.com/p/BBATaXDFQW1/&#34; style=&#34; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&#34; target=&#34;_blank&#34;&gt;ノイズ生成デモ&lt;/a&gt;&lt;/p&gt; &lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;@m_ike__が投稿した動画 - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-01-26T13:57:16+00:00&#34;&gt;2016 1月 26 5:57午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;ソース自体はGPUGemsのサンプルをほぼほぼ書き換えただけなので、ノイズ生成のアルゴリズムなどは参考リンクの方で。。。&lt;/p&gt;

&lt;h3 id=&#34;ノイズ生成の流れ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ノイズ生成の流れ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初期化時に順列テーブル&lt;code&gt;permBuffer&lt;/code&gt;を生成&lt;br /&gt;
初回のみなのでCPU側で生成&lt;br /&gt;
実行時毎にノイズの模様が変化する様にランダムに並び替えを行う&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;毎フレームごと、ComputeShaderでノイズを生成&lt;br /&gt;
シェーダは各種パラメータ&lt;code&gt;NoiseParameter&lt;/code&gt;や順列テーブルなどを受け取って、生成した結果をテクスチャに書き込んで返却する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2のテクスチャを板ポリに貼って描画する&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;computeshader用の設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ComputeShader用の設定&lt;/h3&gt;

&lt;h4 id=&#34;mtkviewの設定:c76c02a9716918700fc6ffc19450c1da&#34;&gt;MTKViewの設定&lt;/h4&gt;

&lt;p&gt;ComputeShaderを利用する場合は、&lt;code&gt;MTKView&lt;/code&gt;の&lt;code&gt;framebufferOnly&lt;/code&gt;を&lt;code&gt;false&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただし、パフォーマンスに影響を与えるので、利用しない時は触らないこと。&lt;/p&gt;

&lt;h4 id=&#34;waituntilcompleted:c76c02a9716918700fc6ffc19450c1da&#34;&gt;waitUntilCompleted()&lt;/h4&gt;

&lt;p&gt;各種コマンドの実行の終了するまで待機するメソッド。&lt;br /&gt;
以下のように&lt;code&gt;commandBuffer.commit()&lt;/code&gt;より後に置く。&lt;br /&gt;
描画時のような毎フレームごとの呼び出しの時は、別途 &lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;で処理を待機するので不要だが、
初期化時の1回のみ実行するような場合は、これを使って待機させる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;/* ~~ （ここでGPGPUのコマンド処理） ~~ */
commandBuffer.commit()
commandBuffer.waitUntilCompleted()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;スレッド:c76c02a9716918700fc6ffc19450c1da&#34;&gt;スレッド&lt;/h3&gt;

&lt;p&gt;GPGPUは大量のスレッドを並列動作させて圧倒的な処理を行うのが特徴だが、モバイルのGPUのため、スレッドグループ毎の最大のスレッド数は512までになっている(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/MetalFeatureSetTables/MetalFeatureSetTables.html&#34;&gt;公式&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;なお、スレッド数は32の倍数にするのが良い。nVIDIAの資料(URL忘れた…)によると64−192ぐらいが一番パフォーマンス的に良いらしいがA系チップに当てはまるかは不明。&lt;/p&gt;

&lt;p&gt;今回は以下のように、スレッドグループは1つのみだが、グループのサイズをテクスチャのサイズと同じにしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// スレッドグループの事前設定
threadgroupSize = MTLSize(width: TexSize, height: TexSize, depth: 1)
threadgroupCount = MTLSize(width: 1, height: 1, depth: 1)

// コマンドバッファへスレッドグループの設定
computeEncoder.dispatchThreadgroups(threadgroupSize, threadsPerThreadgroup: threadgroupCount)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;ここでの注意ポイントは、スレッドの&lt;strong&gt;&lt;em&gt;次元&lt;/em&gt;&lt;/strong&gt;に合わせてシェーダ側の引数も変更が必要なこと。
今回はサイズが2次元(width * height * 1)なので、シェーダ側は&lt;code&gt;uint2 id [[ thread_position_in_grid ]]&lt;/code&gt;と、
&lt;code&gt;uint2&lt;/code&gt;で受け取ることになる(間違えるとシェーダのコンパイルが通らない親切?仕様)。1次元なら&lt;code&gt;uint&lt;/code&gt;で受け取れば良い。&lt;/p&gt;

&lt;p&gt;また、グループが複数だったり1次元のバッファで2次元のグループサイズを指定している様な場合は、&lt;code&gt;threads_per_grid&lt;/code&gt;や&lt;code&gt;thread_position_in_threadgroup&lt;/code&gt;を追加で受け取る必要がある。詳細は公式の&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html&#34;&gt;Attribute Qualifiers for Kernel Function Input&lt;/a&gt;の項目を参照。&lt;/p&gt;

&lt;p&gt;同じスレッドグループ内であれば、メモリの共有ができたりするのだが、そのあたりも公式のサンプル&lt;a href=&#34;https://developer.apple.com/library/ios/samplecode/Metal_NBody_Simulation/Introduction/Intro.html&#34;&gt;Metal N-Body&lt;/a&gt;が参考になる。&lt;/p&gt;

&lt;h3 id=&#34;デバッグ:c76c02a9716918700fc6ffc19450c1da&#34;&gt;デバッグ&lt;/h3&gt;

&lt;p&gt;Xcodeの&lt;code&gt;Capture GPU Frame&lt;/code&gt;がとても便利。&lt;/p&gt;

&lt;p&gt;これを使うと、実行中の各バッファやテクスチャのイメージの様子をキャプチャしてくれる。
バッファのバイナリも見れるので、例えば構造体のアライメントが崩れたりしているのを簡単に見つけることができる。&lt;/p&gt;

&lt;p&gt;また、プロファイル機能も充実していてどこがボトルネックがわかりやすい。&lt;/p&gt;

&lt;h2 id=&#34;感想:c76c02a9716918700fc6ffc19450c1da&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;Metalの発表を聞いて一番ワクワクして触りたかったのが、このGPGPUだった。これまでMacでは統合開発環境でGPGPUが組めなかった（普通のシェーダだけならUnityがあった）ので、使い慣れたXcodeで触れるのは楽しみだった。&lt;/p&gt;

&lt;p&gt;元々ソース自体はGemsのものや参考リンクのものがあったので、移植しただけ。実際にはパラメータやノイズの加工を工夫すれば、雲になったり地形になったりしていくが、パラメータの調整はどうも苦手というか時間がものすごくかかるので、とりあえず今回はここまでで。&lt;/p&gt;

&lt;p&gt;並列化によってどれくらい高速化するのかとか、モバイルのGPGPUでどのくらいパフォーマンスが上がるのか（もちろんバッファの転送が無いだけでも効果は大きいだろうけど）とかが気になったのだけど、それもまた別の機会に・・・&lt;/p&gt;

&lt;p&gt;にしても、シェーダ関係は環境毎に用語が微妙に変わるのは何とかしてほしい。。。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:c76c02a9716918700fc6ffc19450c1da&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;日本語の解説：&lt;a href=&#34;http://postd.cc/understanding-perlin-noise/&#34;&gt;パーリンノイズを理解する(POSTD)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本家：&lt;a href=&#34;http://mrl.nyu.edu/~perlin/&#34;&gt;Ken Perlin&amp;rsquo;s homepage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems Chapter5：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems/gpugems_ch05.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPUGems2 Chapter26：&lt;a href=&#34;http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html&#34;&gt;Implementing Improved Perlin Noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FragmentShaderで実装や応用例：&lt;a href=&#34;http://www.sci.utah.edu/~leenak/IndStudy_reportfall/Perlin%20Noise%20on%20GPU.html&#34;&gt;Perlin Noise on GPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:c76c02a9716918700fc6ffc19450c1da&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:c76c02a9716918700fc6ffc19450c1da&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalCompute&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalKitのSwift版サンプル</title>
      <link>https://mike-neko.github.io/blog/metal-model/</link>
      <pubDate>Fri, 22 Jan 2016 00:23:56 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-model/</guid>
      <description>

&lt;h2 id=&#34;概要:6a6245d2d174e54873361b2ccb73e605&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;元ネタのApple公式の&lt;a href=&#34;https://developer.apple.com/library/mac/samplecode/MetalKitEssentials/Introduction/Intro.html&#34;&gt;MetalKitEssentials&lt;/a&gt;をSwiftで書き直し＋αしたもの。
内容は主にMetalKitを使って、obj形式のモデルをテクスチャありで表示させるだけ。
シェーダもいたってシンプルでライトもなし。&lt;br /&gt;
ちなみに、MetalKitは&lt;strong&gt;iOS9以降&lt;/strong&gt;でしか使えないので注意。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:6a6245d2d174e54873361b2ccb73e605&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;はじめに:6a6245d2d174e54873361b2ccb73e605&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;一番最初につまずいたのは、ビルド自体が通らず、Metalのフレームワークのインポートでエラーになる！ってこと。当然、コードを書く時にも自動補完は効かないしエラーでまくるし・・・&lt;br /&gt;
で、原因はターゲットでシュミレータを選択していたこと。実行できないのは知っていたけど、まさかビルドすら通らないのは予想外。。。&lt;/p&gt;

&lt;h3 id=&#34;バッファへのアクセス:6a6245d2d174e54873361b2ccb73e605&#34;&gt;バッファへのアクセス&lt;/h3&gt;

&lt;p&gt;今回、一番書き方が判らなくて苦労したのがこれ。単にVertexBufferへのポインタを取得して、中のデータを読み書きしたいだけなのだが、当然、Swiftがメモリへの直アクセスを許してくれるわけはなく・・・&lt;/p&gt;

&lt;p&gt;上がObjective-Cで書いた場合で下がSwiftの場合：&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/1a7595b9b8cbe769a74d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Swiftでは、まずポインタ&lt;code&gt;p&lt;/code&gt;を明示的に取得し、それから&lt;code&gt;memory()&lt;/code&gt;で&lt;code&gt;VertexUniforms&lt;/code&gt;の型へ変換し、それを通して中のデータへアクセスするという手間が必要。やはりSwiftは型にうるさい。&lt;/p&gt;

&lt;p&gt;なお、このサンプルでは配列ではないので&lt;code&gt;p.memory()&lt;/code&gt;だが、バッファの内容が配列になっていてインデックスでアクセスしたい場合は、&lt;code&gt;p.advancedBy(i).memory()&lt;/code&gt;(iがインデックス)とする。&lt;/p&gt;

&lt;p&gt;ちょっと面倒だけど、暗黙的な「わかる人にはわかる」といった曖昧さを排除し、ポインタの状態やメモリにアクセスしていることを明示させているのは、Swiftの良さの一つだと思う。&lt;/p&gt;

&lt;h3 id=&#34;シェーダ用の構造体:6a6245d2d174e54873361b2ccb73e605&#34;&gt;シェーダ用の構造体&lt;/h3&gt;

&lt;p&gt;今回、シェーダにデータを渡す時の型（構造体）を、シェーダのファイルとSwift上でそれぞれ同じ宣言をしている。これは、Swiftから直接Cのファイルを見に行けない為。ブリッジヘッダを使ったりすれば重複して宣言しなくてよさそうだけど、未検証。Swift上ではSwiftの構造体を使えた方が便利かなと思ったので（結局使わなかったけど）&lt;/p&gt;

&lt;p&gt;なお、当然ながら&lt;strong&gt;メモリのアライメントには注意が必要&lt;/strong&gt;(&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html#//apple_ref/doc/uid/TP40014364-CH2-SW15&#34;&gt;公式:アライメント一覧&lt;/a&gt;)なので、必要に応じてパディングすること。ちなみに忘れると画面が心霊現象みたくなったり表示されなかったり・・・&lt;/p&gt;

&lt;h3 id=&#34;simd:6a6245d2d174e54873361b2ccb73e605&#34;&gt;SIMD&lt;/h3&gt;

&lt;p&gt;Xcode7からようやくSIMDがサポート。これでvectorやmatrixのベタなコードを書く or 持ってくる必要がなくなった。（でも移動や回転とかはやっぱり自前が必要）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import simd&lt;/code&gt;で使えるようになる。&lt;code&gt;MetalKit&lt;/code&gt;のインポートでも良い。&lt;/p&gt;

&lt;h2 id=&#34;感想:6a6245d2d174e54873361b2ccb73e605&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;正直なところ、Unityとかに慣れてしまった身にとって、Metalは結構大変だった。。。日本語の資料も少ないし、公式の資料もまだまだObjective-Cが多い感じ。&lt;br /&gt;
といっても、DirectXのダラダラとした初期化とかに比べると、機種依存がなく簡潔で楽。久々に3Dの基礎を振り返る良い機会になったと思う。&lt;br /&gt;
結局まあ、Unityとかが偉大すぎるという当たり前の結論に到達。&lt;/p&gt;

&lt;p&gt;触っていて、良い！と思ったのは、バグで描画がおかしくなったりしても、影響が端末だけに限られて作業しているMacは無事なこと。&lt;br /&gt;
昔々のDirectXでしょっちゅうブルースクリーンを出してしまい、コードが消えたりPC不安定になっていた人なので、これはとても助かった。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:6a6245d2d174e54873361b2ccb73e605&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:6a6245d2d174e54873361b2ccb73e605&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalModel&#34;&gt;こちら&lt;/a&gt; (&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>