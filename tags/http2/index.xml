<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Http2 on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/tags/http2/</link>
    <description>Recent content in Http2 on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sat, 29 Oct 2016 22:40:57 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/tags/http2/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Guzzle(PHP)でAPNsの同時配信を行う</title>
      <link>https://mike-neko.github.io/blog/guzzle-apns/</link>
      <pubDate>Sat, 29 Oct 2016 22:40:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle-apns/</guid>
      <description>

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;でiOSのAPNs(Push通知)をお手軽に同時配信する方法&lt;/p&gt;

&lt;p&gt;APNs自体については&lt;a href=&#34;../http2apns/&#34;&gt;APNs Provider API(http2)を利用する(Node.js)&lt;/a&gt;を参照&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;自体は&lt;a href=&#34;../guzzle/&#34;&gt;以前の記事&lt;/a&gt;を参照&lt;/p&gt;

&lt;h3 id=&#34;curlの更新&#34;&gt;curlの更新&lt;/h3&gt;

&lt;p&gt;APNsを使うには&lt;code&gt;http2&lt;/code&gt;が必要かつ非同期で実行したいので、&lt;code&gt;curl&lt;/code&gt;をインストールし直す&lt;/p&gt;

&lt;p&gt;&lt;code&gt;homebrew&lt;/code&gt;を使っている場合は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install curl --with-nghttp2 --with-openssl
brew link curl --force
brew reinstall php56 --with-homebrew-curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、自分で試した時は上記だけでは&lt;code&gt;http2&lt;/code&gt;が有効にならなかったので、
アンイストールした方が確実かもしれない&lt;/p&gt;

&lt;p&gt;更新後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;code&gt;http2&lt;/code&gt;が出ていればOK&lt;/p&gt;

&lt;h2 id=&#34;guzzleの使い方&#34;&gt;Guzzleの使い方&lt;/h2&gt;

&lt;h3 id=&#34;http2で通信する&#34;&gt;http2で通信する&lt;/h3&gt;

&lt;p&gt;オプションで指定するだけでOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;version&#39; =&amp;gt; 2.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post送信&#34;&gt;POST送信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;はリクエスト時のオプションとして以下の感じで指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client();
$response = $client-&amp;gt;request(&#39;POST&#39;, $url, [&#39;body&#39; =&amp;gt; $body]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;の中身を&lt;code&gt;JSON&lt;/code&gt;にしたい時は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;body&#39; =&amp;gt; json_encode($json])]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形にして渡す&lt;/p&gt;

&lt;h3 id=&#34;クライアント証明書をつける&#34;&gt;クライアント証明書をつける&lt;/h3&gt;

&lt;p&gt;これもオプションで指定するだけでOK&lt;/p&gt;

&lt;p&gt;例えば同じ階層内に&lt;code&gt;apns_dev.pem&lt;/code&gt;という証明書（パスフレーズ&lt;code&gt;0000&lt;/code&gt;）に置いた場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;cert&#39; =&amp;gt; [&#39;apns_dev.pem&#39;, &#39;0000&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あえていうなら、&lt;code&gt;pem&lt;/code&gt;形式の証明書を作るのがちょっと面倒&lt;/p&gt;

&lt;h2 id=&#34;apnsの同時配信&#34;&gt;APNsの同時配信&lt;/h2&gt;

&lt;p&gt;APNsは通知内容をJSONで指定することと、前回の並列リクエストを併せると、以下のコードで同時配信が実現できる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/dcc15bedbc4d42e4e8b1c31119f3c63a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;（※配信環境はSandBox向け）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/http2apns-ios/</link>
      <pubDate>Thu, 25 Aug 2016 23:00:38 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns-ios/</guid>
      <description>

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
しかもiOS端末からPush通知を送信する方法。&lt;/p&gt;

&lt;p&gt;前回の&lt;a href=&#34;../http2apns/&#34;&gt;Node.jsからAPNsを使う方法&lt;/a&gt;の派生ネタ。
&lt;code&gt;APNs Provider API&lt;/code&gt;はhttp2とクライアント証明書に対応さえしていればPushを送れるので、
それならiOS端末からでも良けるよね？って試してみた。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;iOSならiOS9から&lt;code&gt;http2&lt;/code&gt;に対応しているので、証明書の準備のみ必要。&lt;/p&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;の手順で&lt;code&gt;apns.p12&lt;/code&gt;を書き出せばOK。
&lt;code&gt;.pem&lt;/code&gt;の作成やCAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;ポイントは&lt;code&gt;https&lt;/code&gt;のクライアント認証を実装すること。
それができれば後はPOST形式でAPIを呼び出すだけなので簡単（APIについては&lt;a href=&#34;../http2apns/&#34;&gt;前回記事&lt;/a&gt;参照）&lt;/p&gt;

&lt;h3 id=&#34;クライアント認証&#34;&gt;クライアント認証&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;NSURLSession&lt;/code&gt;でクライアント認証を実装するには、&lt;code&gt;NSURLSessionDelegate&lt;/code&gt;の
&lt;code&gt;URLSession(_:didReceiveChallenge:completionHandler:)&lt;/code&gt;を実装する。&lt;/p&gt;

&lt;p&gt;サーバからクライアント認証が要求されると、このデリゲートメソッドが呼ばれるので、
クライアント証明書を読み込んで&lt;code&gt;NSURLCredential&lt;/code&gt;にして渡してあげればOK。&lt;/p&gt;

&lt;p&gt;注意点は、他の認証（通常のSSL/TLS認証とかBasic認証）時も全て呼び出されるので、その実装を忘れないこと！&lt;/p&gt;

&lt;p&gt;以上を踏まえると、実装はこんな感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func URLSession(session: NSURLSession, didReceiveChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&amp;gt; Void) {
    switch challenge.protectionSpace.authenticationMethod {
    // 通常のhttpsのSSL/TLS認証
    case NSURLAuthenticationMethodServerTrust:
      // デフォルトの動作をさせる
      completionHandler(.PerformDefaultHandling, nil)
    // httpsのクライアント認証
    case NSURLAuthenticationMethodClientCertificate:
      // clientCredential(あらかじめクライアント証明書から生成した認証情報)を
      // 利用して認証をかける
      completionHandler(.UseCredential, clientCredential)
    // その他の認証
    default:
      completionHandler(.PerformDefaultHandling, nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クライアント証明書の読み込み&#34;&gt;クライアント証明書の読み込み&lt;/h3&gt;

&lt;p&gt;クライアントの証明書は&lt;code&gt;p12&lt;/code&gt;形式を利用する。
証明書からは&lt;code&gt;SecPKCS12Import&lt;/code&gt;を使って認証情報を取り出し、&lt;code&gt;NSURLCredential&lt;/code&gt;を生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// アプリにバンドルされているクライアント証明書(apns.p12)
guard let url = NSBundle.mainBundle().
  URLForResource(&amp;quot;apns&amp;quot;, withExtension: &amp;quot;p12&amp;quot;) else { return }
guard let p12data = NSData(contentsOfURL: p12URL) else { return }

let passphrase = &amp;quot;0000&amp;quot;     // 証明書のパスフレーズ
let options = [kSecImportExportPassphrase as String : passphrase]

var items: CFArray?
guard SecPKCS12Import(p12data, options, &amp;amp;items) == errSecSuccess
  else { return }
guard let cfarr = items else { return }
guard let certEntry = (cfarr as Array).first as? [String: AnyObject]
  else { return }

let identity = certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity
let certificates = certEntry[&amp;quot;chain&amp;quot;] as? [AnyObject]
let clientCredential = NSURLCredential(identity: identity,
                                       certificates: certificates,
                                       persistence: .ForSession)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はサンプルなのでクライアント証明書はアプリにバンドルしているが、通常はキーチェーンにいれておくべき。&lt;/p&gt;

&lt;p&gt;なお、クライアント証明書の中身はPush送信用の一つだけが入っている前提。&lt;/p&gt;

&lt;p&gt;小ネタなのが、&lt;code&gt;certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity&lt;/code&gt;という部分。
&lt;code&gt;AnyObject&lt;/code&gt;から&lt;code&gt;SecIdentity&lt;/code&gt;への変換は常に成功するので&lt;code&gt;as?&lt;/code&gt;にはできないみたい。
詳細は&lt;a href=&#34;https://forums.developer.apple.com/thread/11171&#34;&gt;公式フォーラム&lt;/a&gt;を参照。&lt;/p&gt;

&lt;h3 id=&#34;apnsの送信&#34;&gt;APNsの送信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// デバイストークン
let deviceToken = &amp;quot;00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0&amp;quot;
// 通知内容
let payload = &amp;quot;{\&amp;quot;aps\&amp;quot;:{\&amp;quot;alert\&amp;quot;:\&amp;quot;Hello!\&amp;quot;}}&amp;quot;

// 開発環境向けURL
guard let url = NSURL(string: &amp;quot;https://api.development.push.apple.com/3/device/&amp;quot;)
  else { return }
let request = NSMutableURLRequest(URL: url.URLByAppendingPathComponent(deviceToken))
request.HTTPMethod = &amp;quot;POST&amp;quot;
request.HTTPBody = payload.dataUsingEncoding(NSUTF8StringEncoding)

let config = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: config, delegate: self, delegateQueue: nil)
session.dataTaskWithRequest(request).resume()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;送信時のポイントは、デリゲートを指定しておくことと、&lt;code&gt;completionHandler&lt;/code&gt;形式のメソッドを使わないこと。
使ってしまうとデリゲートが呼び出されなくなり、クライアント認証が通らなくなる。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回は本当にネタ。多分使い道はないと思う。。。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;クライアント証明書を上書きして使う必要があるので注意！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/APNs_iOS&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(Node.js)</title>
      <link>https://mike-neko.github.io/blog/http2apns/</link>
      <pubDate>Thu, 11 Aug 2016 17:16:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns/</guid>
      <description>

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
サーバサイドは&lt;code&gt;Node.js&lt;/code&gt;を利用。&lt;/p&gt;

&lt;h3 id=&#34;apns-provider-api&#34;&gt;APNs Provider API&lt;/h3&gt;

&lt;p&gt;利用するために必要なのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http2のPOST送信&lt;/li&gt;
&lt;li&gt;クライアント認証用の証明書&lt;/li&gt;
&lt;li&gt;CAルート証明書（必要な場合のみ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。
なお、&lt;code&gt;http2&lt;/code&gt;対応が必要なのは送信のみなので、サーバ自体はhttp2対応にしなくてもOK。&lt;/p&gt;

&lt;p&gt;従来のソケット通信経由でAPNsを送信するのと比較すると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;実装が簡単&lt;/li&gt;
&lt;li&gt;1つのデバイストークン毎に結果が取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というのが大きなメリット。&lt;/p&gt;

&lt;p&gt;特に以前は、環境の異なるトークンを送信すると、いきなりソケットの接続自体が切断される・・・
みたいな挙動があって確実に全件送信させるのは結構大変だったけど、API方式ではそういったのはなさそう。&lt;/p&gt;

&lt;p&gt;パフォーマンス的にどうなのかは不明。&lt;/p&gt;

&lt;h3 id=&#34;送信形式&#34;&gt;送信形式&lt;/h3&gt;

&lt;p&gt;環境毎のAppleのサーバへPOSTリクエストを送ることでPush通知が送信される。&lt;br /&gt;
指定する内容自体は従来のものと同じなので、詳細な内容は公式を参照のこと。&lt;/p&gt;

&lt;h4 id=&#34;アドレス&#34;&gt;アドレス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;開発 : &lt;code&gt;https://api.development.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;商用 : &lt;code&gt;https://api.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ヘッダ&#34;&gt;ヘッダ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apns-topic&lt;/code&gt; : 送信対象のアプリのバンドルID&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-id&lt;/code&gt; : 通知ID。指定しなければAPNs側で自動生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-expiration&lt;/code&gt; : 通知が無効になり破棄できるようになる有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-priority&lt;/code&gt; : 優先度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ボディ&#34;&gt;ボディ&lt;/h4&gt;

&lt;p&gt;JSON形式の通知ペイロード&lt;/p&gt;

&lt;h4 id=&#34;レスポンス&#34;&gt;レスポンス&lt;/h4&gt;

&lt;p&gt;送信の受付に成功した場合はステータスコードが&lt;code&gt;200&lt;/code&gt;で返ってくる。&lt;/p&gt;

&lt;p&gt;失敗した場合は、それ以外のステータスコードと、コードに応じてより詳細なエラー内容がボディで返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;もしかすると、&lt;code&gt;OpenSSL&lt;/code&gt;は最新に上げておいた方がいいかも知れない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;は現時点(6.3.1)では&lt;code&gt;http2&lt;/code&gt;には対応していないので、
&lt;a href=&#34;https://www.npmjs.com/package/http2&#34;&gt;http2&lt;/a&gt;というモジュールをインストールしておく。&lt;/p&gt;

&lt;h3 id=&#34;証明書&#34;&gt;証明書&lt;/h3&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;と同じ。
ただし、今回はMacに直接インストールした&lt;code&gt;Node.js&lt;/code&gt;を使うので、CAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/2f2f9f9130ef1d46872894b115a4b0c3.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;クライアント証明書の指定&#34;&gt;クライアント証明書の指定&lt;/h3&gt;

&lt;p&gt;22,23行目にあるように、クライアント証明書と鍵を読み込んで指定する。
（もちろん各ファイルを同じフォルダ内に置いておくのを忘れないように）&lt;/p&gt;

&lt;p&gt;もし、証明書の秘密鍵のパスフレーズを設定している時は、25行目のように設定が必要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（8/24 追記）&lt;/em&gt;&lt;/strong&gt;
&lt;del&gt;証明書の中が送信対象アプリ単独のもの（他の証明書や鍵を含んでいない）であれば、
&lt;code&gt;apns-topic&lt;/code&gt;は指定しなくても送信可能。&lt;br /&gt;
通常の手順で生成した場合は単独のはずなので、指定は不要。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（11/20 追記）&lt;/em&gt;&lt;/strong&gt;
開発環境では上記の通りだが、本番環境では指定がないとエラーが発生する為、必須の様子&lt;/p&gt;

&lt;h3 id=&#34;通知内容の設定&#34;&gt;通知内容の設定&lt;/h3&gt;

&lt;p&gt;送信形式の項目で述べたように、ヘッダにバンドルIDを設定(10−12,21行目)する。&lt;/p&gt;

&lt;p&gt;デバイストークンは、URLの一部として設定する(20行目)。&lt;/p&gt;

&lt;p&gt;通知ペイロードは、44行目にあるようにボディとして書き出す。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html&#34;&gt;APNs Provider API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/jp/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW1&#34;&gt;日本語ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Node.js 6.3.1&lt;/li&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nginxをhttp2に対応させる</title>
      <link>https://mike-neko.github.io/blog/nginx-http2/</link>
      <pubDate>Fri, 03 Jun 2016 21:29:36 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/nginx-http2/</guid>
      <description>

&lt;p&gt;以前に構築したDockerでの開発環境で使ったnginxを&lt;code&gt;http2&lt;/code&gt;に対応させた時のメモ。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;過去の記事（&lt;a href=&#34;../docker/&#34;&gt;Dockerでの開発環境&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;p&gt;ベースは前回構築したnginx+Dockerで通信はオレオレ証明書によるSSLを前提。&lt;/p&gt;

&lt;p&gt;主な変更点は以下の通り&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;li&gt;nginx 1.10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いずれもhttp2対応させる為にバージョンアップが必要。&lt;/p&gt;

&lt;p&gt;なお、iOSは&lt;strong&gt;iOS9&lt;/strong&gt;からhttp2へ対応している。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;事前準備&#34;&gt;事前準備&lt;/h3&gt;

&lt;p&gt;http2での通信かどうかの確認用に以下のChromeのプラグインを入れておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=ja&#34;&gt;HTTP/2 and SPDY indicator&lt;/a&gt;&lt;br /&gt;
（Firefox用もあるみたいなのでお好きな方で）&lt;/p&gt;

&lt;p&gt;http2での通信だと稲妻が青色になるので確認が楽。&lt;/p&gt;

&lt;h3 id=&#34;macでの作業&#34;&gt;Macでの作業&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OpenSSLを最新にあげる&lt;br /&gt;
OpenSSLの更新方法：&lt;a href=&#34;http://qiita.com/Chrowa3/items/b04e772be959cdda9ac3&#34;&gt;Mac OS X の openssl を最新の状態にする&lt;/a&gt;&lt;br /&gt;
ポイントは&lt;code&gt;upgrade&lt;/code&gt;にすること（普段使う&lt;code&gt;update&lt;/code&gt;ではない）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをアンイストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install nginx --with-http2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxのconfを編集&lt;br /&gt;
&lt;code&gt;HTTPS server&lt;/code&gt;の設定が&lt;code&gt;listen  443 ssl;&lt;/code&gt;となっているはずなので、&lt;code&gt;http2&lt;/code&gt;を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
listen  443 ssl http2;
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追加したらnginxを再起動する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChromeからMacへアクセスしてみて青い稲妻になっていれば&lt;code&gt;nginx&lt;/code&gt;の設定は成功&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ios端末での通信&#34;&gt;iOS端末での通信&lt;/h3&gt;

&lt;p&gt;iOS9以降の&lt;code&gt;NSURLSession&lt;/code&gt;での通信であれば、特に設定など不要で自動で&lt;code&gt;http2&lt;/code&gt;になる。&lt;/p&gt;

&lt;p&gt;なお、規格上は&lt;code&gt;http&lt;/code&gt;のみでも対応しているがiOSでどうかは未検証。&lt;/p&gt;

&lt;h3 id=&#34;ログ設定&#34;&gt;ログ設定&lt;/h3&gt;

&lt;p&gt;iOS端末からの通信も&lt;code&gt;http2&lt;/code&gt;になっているかの確認は、&lt;code&gt;nginx&lt;/code&gt;のログで判別する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http2&lt;/code&gt;の場合は、&lt;code&gt;log_format&lt;/code&gt;の&lt;code&gt;$http2&lt;/code&gt;に&lt;code&gt;h2&lt;/code&gt;と入ってくる。&lt;br /&gt;
詳細は以下のページを参考に&lt;br /&gt;
&lt;a href=&#34;http://d.hatena.ne.jp/ASnoKaze/20150818/1439896998&#34;&gt;nginxでアクセスログにhttp2の通信か出力する&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;過去情報&#34;&gt;過去情報&lt;/h2&gt;

&lt;p&gt;標準の&lt;code&gt;nginx&lt;/code&gt;に&lt;code&gt;http2&lt;/code&gt;モジュールがないと思っていたら、
実はちゃんとあったので訂正。&lt;/p&gt;

&lt;p&gt;もったいないので、&lt;code&gt;nginx-full&lt;/code&gt;の情報を残しておく。&lt;/p&gt;

&lt;h3 id=&#34;nginx-full&#34;&gt;nginx-full&lt;/h3&gt;

&lt;p&gt;通常の&lt;code&gt;Homebrew&lt;/code&gt;の&lt;code&gt;nginx&lt;/code&gt;ではオプションのモジュールが少ないので、
標準では足りないモジュールをインストールしたい時は&lt;code&gt;nginx-full&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;p&gt;例） nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew tap homebrew/nginx
brew install nginx-full --with-http2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールの一覧は以下で確認すること。
（&lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_v2_module.html&#34;&gt;公式&lt;/a&gt;のモジュールの情報?とは違うようなのでこれで確認）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew info nginx-full
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kannokanno.hatenablog.com/entry/2014/02/10/134920&#34;&gt;Mac - homebrewでnginxを入れるときはnginx-fullを入れよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>