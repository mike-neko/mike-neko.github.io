<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/tags/ios/</link>
    <description>Recent content in Ios on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Wed, 14 Dec 2016 19:52:13 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GitHubの自作ライブラリを公開する（ライブラリ編）</title>
      <link>https://mike-neko.github.io/blog/library2/</link>
      <pubDate>Wed, 14 Dec 2016 19:52:13 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/library2/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;の自作ライブラリ(&lt;a href=&#34;https://github.com/mike-neko/Kanagata&#34;&gt;Kanagata&lt;/a&gt;)をGitHubに公開するにあたってのメモ。
その2ではマルチプラットフォーム対応とライブラリ管理ツールの導入についての内容&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、作成するフレームワーク名、プロジェクト名は&lt;code&gt;Kanagata&lt;/code&gt;とした場合の手順なので、
他の作業時は適宜読み替えること&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;その1は&lt;a href=&#34;../library1&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;マルチプラットフォーム対応&#34;&gt;マルチプラットフォーム対応&lt;/h2&gt;

&lt;p&gt;元々は&lt;code&gt;iOS&lt;/code&gt;で作成していたが、特にOS依存するコードもないので、&lt;code&gt;macOS&lt;/code&gt;と&lt;code&gt;watchOS&lt;/code&gt;と&lt;code&gt;tvOS&lt;/code&gt;にも対応させる。
また、ソースとテストは全て共通のものを用いることとする&lt;/p&gt;

&lt;h3 id=&#34;既存ターゲット名変更&#34;&gt;既存ターゲット名変更&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;iOS&lt;/code&gt;用のターゲットと判る様にターゲット名を&lt;code&gt;Kanagata&lt;/code&gt;から&lt;code&gt;Kanagata-iOS&lt;/code&gt;へ変更する&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;プロジェクト設定から&lt;code&gt;TARGETS&lt;/code&gt;の中の&lt;code&gt;Kanagata&lt;/code&gt;をクリックして名前を&lt;code&gt;Kanagata-iOS&lt;/code&gt;へ変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Build Settings&lt;/code&gt;の&lt;code&gt;Product Name&lt;/code&gt;を&lt;code&gt;$(TARGET_NAME)&lt;/code&gt;から&lt;code&gt;$(PROJECT_NAME)&lt;/code&gt;へ変更&lt;/li&gt;
&lt;li&gt;スキーム名も&lt;code&gt;Manage Schemes...&lt;/code&gt;から&lt;code&gt;Kanagata&lt;/code&gt;をクリックして名前を&lt;code&gt;Kanagata-iOS&lt;/code&gt;へ変更&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;テスト用のターゲット&lt;code&gt;KanagataTests&lt;/code&gt;も同じ様にターゲット名を&lt;code&gt;KanagataTests-iOS&lt;/code&gt;へ、
&lt;code&gt;Product Name&lt;/code&gt;を`&lt;code&gt;$(PROJECT_NAME)&lt;/code&gt;へ変更する&lt;/p&gt;

&lt;h3 id=&#34;他os用のターゲットを追加&#34;&gt;他OS用のターゲットを追加&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;プロジェクト設定の&lt;code&gt;TARGETS&lt;/code&gt;の下部にある＋からターゲットを追加

&lt;ul&gt;
&lt;li&gt;追加画面の上部でOSを選択してから&lt;code&gt;Framework&lt;/code&gt;を選択&lt;br /&gt;
（各OSで微妙に名前が違うので道具箱とココアのアイコンで見分けること）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product Name&lt;/code&gt;は&lt;code&gt;Kanagata-(OS名)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Include Unit Tests&lt;/code&gt;にチェック(&lt;code&gt;watchOS&lt;/code&gt;以外)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プロジェクトに&lt;code&gt;Kanagata-(OS名)&lt;/code&gt;と&lt;code&gt;KanagataTests-(OS名)&lt;/code&gt;が追加されるのでフォルダごと削除&lt;/li&gt;
&lt;li&gt;追加したターゲットのバンドルIDから&lt;code&gt;-(OS名)&lt;/code&gt;を削除&lt;br /&gt;
（必要に応じて&lt;code&gt;Signing&lt;/code&gt;と&lt;code&gt;Deployment Target&lt;/code&gt;も修正）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Build Settings&lt;/code&gt;を変更

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Info.plist File&lt;/code&gt;のパスから&lt;code&gt;-(OS名)&lt;/code&gt;を削除（共通のplistを指す様に）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product Name&lt;/code&gt;を&lt;code&gt;$(TARGET_NAME)&lt;/code&gt;から&lt;code&gt;$(PROJECT_NAME)&lt;/code&gt;へ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;テスト用のターゲットも同じ様にバンドルID、&lt;code&gt;Signing&lt;/code&gt;、&lt;code&gt;Build Settings&lt;/code&gt;の各項目を修正する&lt;/p&gt;

&lt;p&gt;ここで一旦ビルドとテストを実行して問題なければ次へ&lt;/p&gt;

&lt;h3 id=&#34;travisciへの追加&#34;&gt;travisCIへの追加&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;追加されたOSの各スキームの&lt;code&gt;Shared&lt;/code&gt;をチェック&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt;を修正&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iOS&lt;/code&gt;用のスキーム名を&lt;code&gt;Kanagata&lt;/code&gt;から&lt;code&gt;Kanagata-iOS&lt;/code&gt;へ変更&lt;/li&gt;
&lt;li&gt;追加された&lt;code&gt;macOS&lt;/code&gt;と&lt;code&gt;tvOS&lt;/code&gt;の分のテストを追加（以下の設定）
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;- xcodebuild test -scheme Kanagata-macOS -destination &#39;platform=OS X&#39;
- xcodebuild test -scheme Kanagata-tvOS -destination &#39;platform=tvOS Simulator,name=Apple TV 1080p&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pushしてエラーがなければ次へ&lt;/p&gt;

&lt;h2 id=&#34;ライブラリ管理ツールへの対応&#34;&gt;ライブラリ管理ツールへの対応&lt;/h2&gt;

&lt;p&gt;個人的にはシンプルな&lt;code&gt;Carthage&lt;/code&gt;がお気に入り。
&lt;code&gt;CocoaPods&lt;/code&gt;はプロジェクトの設定がいじられてしまうのが気になるのであまり使っていないが、
周りでは使っている人も多いので対応する&lt;/p&gt;

&lt;p&gt;なお、あらかじめ&lt;code&gt;Carthage&lt;/code&gt;も&lt;code&gt;CocoaPods&lt;/code&gt;もインストール済とする&lt;/p&gt;

&lt;h3 id=&#34;carthage&#34;&gt;Carthage&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Carthage&lt;/code&gt;は&lt;code&gt;CocoaPods&lt;/code&gt;と違って登録などの作業は不要で、
GitHubにリリースすれば良い&lt;/p&gt;

&lt;p&gt;まずは、プロジェクトのカレントディレクトリで以下を実行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;carthage build --no-skip-current
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーなく完了し、&lt;code&gt;Carthage/Build&lt;/code&gt;内に各フレームワークが生成されていればOK&lt;/p&gt;

&lt;p&gt;ビルドに問題なければ&lt;code&gt;GitHub&lt;/code&gt;上のリリースタブからタグをつける&lt;br /&gt;
(この時はバージョンとして&lt;code&gt;0.1.0&lt;/code&gt;の様に数字のみをつけるのが良い。
vを入れたりすると&lt;code&gt;CocoaPods&lt;/code&gt;でうまくいかないことがあるので)&lt;/p&gt;

&lt;h4 id=&#34;参考-インストール&#34;&gt;（参考）インストール&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Cartfile&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github &amp;quot;mike-neko/Kanagata&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じ（&lt;code&gt;アカウント名/リポジトリ名&lt;/code&gt;）で追記するだけで利用できる&lt;/p&gt;

&lt;h3 id=&#34;cocoapods&#34;&gt;CocoaPods&lt;/h3&gt;

&lt;p&gt;今回はデモプロジェクトは同梱しないので直接&lt;code&gt;podspec&lt;/code&gt;を作って対応させる&lt;/p&gt;

&lt;h4 id=&#34;podspecの作成&#34;&gt;podspecの作成&lt;/h4&gt;

&lt;p&gt;プロジェクトのカレントディレクトリで以下を実行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod spec create Kanagata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ひな形の&lt;code&gt;Kanagata.podspec&lt;/code&gt;ができるので内容をプロジェクトに合わせて修正していく。
今回は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pod::Spec.new do |s|
  s.name         = &amp;quot;Kanagata&amp;quot;   // ライブラリ名
  s.version      = &amp;quot;0.1.0&amp;quot;      // バージョン
  s.summary      = &amp;quot;短い説明&amp;quot;
  s.homepage     = &amp;quot;https://github.com/mike-neko/Kanagata&amp;quot;  // GitHub上にしておいた
  s.license      = &amp;quot;MIT&amp;quot;        // ライセンス
  s.author       = { &amp;quot;mike-neko&amp;quot; =&amp;gt; &amp;quot;mike.app.info@gmail.com&amp;quot; } // GitHub上の名前とメール
  s.social_media_url   = &amp;quot;https://twitter.com/m__ike_&amp;quot;          // ツイッターのアドレス
  s.ios.deployment_target = &amp;quot;8.0&amp;quot;           // OS毎のDeployment Targetと合わせる
  s.osx.deployment_target = &amp;quot;10.10&amp;quot;
  s.watchos.deployment_target = &amp;quot;2.0&amp;quot;
  s.tvos.deployment_target = &amp;quot;9.0&amp;quot;
  // GitHubのアドレスとタグの紐付けの設定。tagの方はデフォルトのままが良い
  s.source       = { :git =&amp;gt; &amp;quot;https://github.com/mike-neko/Kanagata.git&amp;quot;, :tag =&amp;gt; &amp;quot;#{s.version}&amp;quot; }
  s.source_files  = &amp;quot;Kanagata/*.swift&amp;quot;      // プロジェクト内でのソースの位置
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本はそのまま埋めていけば良い。ポイントがあるとすると&lt;code&gt;version&lt;/code&gt;の部分は、
数字のみのバージョン(&lt;code&gt;v1.0.0&lt;/code&gt;とかはNG)にして、GitHub上のタグと一致させておくこと。
あとは、忘れずに&lt;code&gt;source_files&lt;/code&gt;を自分のプロジェクトでのソースの位置に合わせること&lt;/p&gt;

&lt;p&gt;一通り作成ができたら、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod spec lint Kanagata.podspec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてみてエラーにならなければOK。pushしておく&lt;/p&gt;

&lt;h4 id=&#34;cocoapodsへ登録&#34;&gt;CocoaPodsへ登録&lt;/h4&gt;

&lt;p&gt;（初回のみ）ユーザを登録する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod trunk register (メールアドレス) &#39;(ユーザ名)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行後に入力したメールアドレスへメールが来るので確認をする。&lt;br /&gt;
確認後は&lt;code&gt;pod trunk me&lt;/code&gt;で登録内容が確認出来る&lt;/p&gt;

&lt;p&gt;ユーザ登録ができれば、&lt;code&gt;podspec&lt;/code&gt;を&lt;code&gt;CocoaPods&lt;/code&gt;へ登録&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod trunk push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、&lt;code&gt;podspec&lt;/code&gt;にTwitterを登録していると、無事完了した時にツイートが飛んでくる&lt;/p&gt;

&lt;h4 id=&#34;ciに設定&#34;&gt;CIに設定&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt;に&lt;code&gt;podspec&lt;/code&gt;の検証を追加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;script:
  - pod lib lint --allow-warnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（今回追加した分のみ記載）&lt;/p&gt;

&lt;h4 id=&#34;参考-インストール-1&#34;&gt;（参考）インストール&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Podfile&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &#39;Kanagata&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加すれば利用可能&lt;/p&gt;

&lt;p&gt;また、生成されたドキュメントは、&lt;code&gt;http://cocoadocs.org/docsets/Kanagata/&lt;/code&gt;で見ることが出来る&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;後はバッジを貼ったり、ライセンスを貼ったりすれば、かなりそれっぽい感じになる。
ライブラリとして公開するとなると敷居が高い気がするが、GitHubを使っていればあまり手間をかけることなく公開できる&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GitHubの自作ライブラリを公開する（CI導入編）</title>
      <link>https://mike-neko.github.io/blog/library1/</link>
      <pubDate>Wed, 14 Dec 2016 19:51:59 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/library1/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;の自作ライブラリ(&lt;a href=&#34;https://github.com/mike-neko/Kanagata&#34;&gt;Kanagata&lt;/a&gt;)をGitHubに公開するにあたってのメモ。
その1ではCIの導入周りについての内容&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、作成するフレームワーク名、プロジェクト名は&lt;code&gt;Kanagata&lt;/code&gt;とした場合の手順なので、
他の作業時は適宜読み替えること&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;その2は&lt;a href=&#34;../library2&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;構成&#34;&gt;構成&lt;/h2&gt;

&lt;p&gt;せっかくなので単なるライブラリの公開だけでなく、以下の感じでそれっぽく公開&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CIの導入(&lt;code&gt;TravisCI&lt;/code&gt;)

&lt;ul&gt;
&lt;li&gt;ユニットテスト(&lt;code&gt;XCTest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;カバレッジ表示(&lt;code&gt;Codecov&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;静的コード解析(&lt;code&gt;SwiftLint&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;ドキュメント生成(&lt;code&gt;juzzy&lt;/code&gt;)&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;マルチプラットフォーム対応(iOS以外も)&lt;/li&gt;
&lt;li&gt;ライブラリ管理ツール

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Carthage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CocoaPods&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ciの導入&#34;&gt;CIの導入&lt;/h2&gt;

&lt;h3 id=&#34;プロジェクトの作成&#34;&gt;プロジェクトの作成&lt;/h3&gt;

&lt;p&gt;今回は既存のプロジェクトの中で使っていたものをフレームワークとして切り出す為、まずは新規プロジェクトを作成&lt;/p&gt;

&lt;p&gt;作成時には、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cocoa Touch Framework&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Include Unit Tests&lt;/code&gt;にチェック&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;をつけて作成する。
既存のソースとテストの各ファイルを移植したら、&lt;code&gt;.h&lt;/code&gt;のファイルを削除
（Swiftのみなのでヘッダは不要）&lt;/p&gt;

&lt;p&gt;ちなみに、ここで一旦ビルドとテストを実行すると&lt;code&gt;module file&#39;s minimum deployment target is ios10.1&lt;/code&gt;のエラー。。。
その時の&lt;code&gt;Deployment Target&lt;/code&gt;はiOS9で問題ないはず。が、iOS10へ変更したりクリーンをしたりしても変わらず。
最後にダメ元でiOS9のシミュレータをDLしてみると、無事完了。
他の環境で試すと再現しなかったりで、結局原因はよく判らなかった・・・・&lt;/p&gt;

&lt;p&gt;さて、無事？テストも通ったのでGitHubへpushしておく&lt;/p&gt;

&lt;h3 id=&#34;travisci&#34;&gt;TravisCI&lt;/h3&gt;

&lt;p&gt;CIツールに&lt;a href=&#34;https://travis-ci.org&#34;&gt;TravisCI&lt;/a&gt;を選択したのは、GitHubと連携できてiOSのビルドができて*タダ*なので&lt;/p&gt;

&lt;h4 id=&#34;登録&#34;&gt;登録&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;トップページから&lt;code&gt;Sign in with GitHub&lt;/code&gt;のボタンを押して、GitHubとの連携を許可&lt;/li&gt;
&lt;li&gt;しばらくすると、GitHubのリポジトリの一覧が表示される&lt;br /&gt;
(表示されない時は再ログインしてみればOK)&lt;/li&gt;
&lt;li&gt;今回のプロジェクトを選んで有効化&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;プロジェクトの修正&#34;&gt;プロジェクトの修正&lt;/h4&gt;

&lt;p&gt;登録が終わればXcodeの&lt;code&gt;Scheme&lt;/code&gt;の設定を変更する&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shared&lt;/code&gt;にチェック&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Test&lt;/code&gt;の中の&lt;code&gt;Gather coverage data&lt;/code&gt;にチェック&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この時のスキーム名はCIの設定で使うので覚えておくこと！&lt;/p&gt;

&lt;h4 id=&#34;設定&#34;&gt;設定&lt;/h4&gt;

&lt;p&gt;リポジトリの直下に&lt;code&gt;.travis.yml&lt;/code&gt;を追加し、CIで行う作業を設定する&lt;/p&gt;

&lt;p&gt;この書き方がよく判らなかったので、いろいろなライブラリのリポジトリを見て
試した結果たどり着いた書き方（テストを実行するだけの最低限）がこちら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;language: objective-c  # Swiftだけどobjective-cを指定
osx_image: xcode8.1    # 使っているXcodeのバージョン
script:
  # テストを実行(schemeにスキーム名を指定する)
  - xcodebuild test -scheme Kanagata -sdk iphonesimulator -destination &#39;platform=iOS Simulator,name=iPhone 5&#39;
notifications:
  email: false         # メール通知はOFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変更が終わればスキームと&lt;code&gt;.travis.yml&lt;/code&gt;の変更分をpushする。&lt;br /&gt;
その後はpushする毎に自動でCIが走るようになる
（だいたい、pushしてから15分程度で開始されることが多い感じ）&lt;/p&gt;

&lt;h3 id=&#34;カバレッジ表示&#34;&gt;カバレッジ表示&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;TravisCI&lt;/code&gt;と&lt;code&gt;Swift&lt;/code&gt;に対応していてバッジが表示できて*タダ*のものということで、
&lt;a href=&#34;https://codecov.io/&#34;&gt;Codecov&lt;/a&gt;を選択&lt;br /&gt;
開発時はXcode内でカバレッジを見るのでどういう詳細表示がされるのかは重視していない&lt;/p&gt;

&lt;h4 id=&#34;登録と設定&#34;&gt;登録と設定&lt;/h4&gt;

&lt;p&gt;こちらも&lt;code&gt;TravisCI&lt;/code&gt;と同じくGitHubとの連携だけで登録完了&lt;/p&gt;

&lt;p&gt;便利なのが、リポジトリを選択すると&lt;code&gt;TravisCI&lt;/code&gt;に設定するコードを表示してくれること。&lt;br /&gt;
表示されたコードを&lt;code&gt;.travis.yml&lt;/code&gt;に追加すればOK&lt;/p&gt;

&lt;h4 id=&#34;ignoreの設定&#34;&gt;ignoreの設定&lt;/h4&gt;

&lt;p&gt;デフォルトの状態ではリポジトリ内全部が対象となるので、テスト用のコードもカウントされてしまい、
正しくないカバレッジが表示されてしまう。それを防ぐため、テスト用のコードは対象外とする様に設定する&lt;/p&gt;

&lt;p&gt;リポジトリ直下に&lt;code&gt;codecov.yml&lt;/code&gt;を追加し、以下を追記する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ignore:
  - &amp;quot;KanagataTests&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;KanagataTests&lt;/code&gt;以下のフォルダは対象外となる&lt;/p&gt;

&lt;h3 id=&#34;swiftlint&#34;&gt;SwiftLint&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/realm/SwiftLint&#34;&gt;SwiftLint&lt;/a&gt;には&lt;code&gt;Auto-correct&lt;/code&gt;というコードフォーマッタの機能があり、
これを使いたいので導入した&lt;/p&gt;

&lt;h4 id=&#34;インストール&#34;&gt;インストール&lt;/h4&gt;

&lt;p&gt;なぜか&lt;code&gt;Sierra&lt;/code&gt;では&lt;code&gt;Homebrew&lt;/code&gt;でインストールできなかったので、パッケージからインストール&lt;/p&gt;

&lt;h4 id=&#34;xcodeに設定&#34;&gt;Xcodeに設定&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Auto-correct&lt;/code&gt;はビルド時に毎回走らせたいので、Xcode上でのビルド設定に追加する&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;フレームワーク用のターゲットの&lt;code&gt;Bulid Phases&lt;/code&gt;を開く&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;New Run Script Phase&lt;/code&gt;で以下のスクリプトを追加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if which swiftlint &amp;gt;/dev/null; then
swiftlint autocorrect
swiftlint
else
echo &amp;quot;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;追加した&lt;code&gt;Run Script&lt;/code&gt;を&lt;code&gt;Compile Sources&lt;/code&gt;より上に移動&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでビルドを試してみて、たくさんエラーとワーニングが出ればOK&lt;/p&gt;

&lt;h4 id=&#34;ルールのカスタマイズ&#34;&gt;ルールのカスタマイズ&lt;/h4&gt;

&lt;p&gt;デフォルトの状態ではかなり厳しい設定で、エラーやワーニングが出まくるので調整する&lt;/p&gt;

&lt;p&gt;リポジトリ直下に&lt;code&gt;.swiftlint.yml&lt;/code&gt;を追加し、無視するルールや変更する基準値を書いていく&lt;/p&gt;

&lt;p&gt;調整内容は各プロジェクトにもよるが、今回は以下の感じに調整した&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;included:
  - Kanagata
variable_name:
  min_length: 0
line_length:
  - 120
  - 150
type_body_length:
  - 350
  - 400
function_body_length:
  - 50
  - 100
cyclomatic_complexity: 25
disabled_rules:
  - nesting
  - file_length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的には1ファイルに詰め込んだ都合上、行数制限をゆるめに設定。
また、JSONの構造上、再起処理や型ごとの処理で複雑性が増しているのでそこもゆるめにした&lt;/p&gt;

&lt;h4 id=&#34;ciに設定&#34;&gt;CIに設定&lt;/h4&gt;

&lt;p&gt;CIの時にはチェックだけされる様に設定を&lt;code&gt;.travis.yml&lt;/code&gt;に追加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before_install:
  - brew update
  - brew install swiftlint
script:
  - swiftlint   # xcodebuild testより前にしておく
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（今回追加した分のみ記載）&lt;/p&gt;

&lt;p&gt;CI環境には&lt;code&gt;SwiftLint&lt;/code&gt;が入っていないので実行前にインストールが必要。
なお、&lt;code&gt;Homebrew&lt;/code&gt;ではなく、パッケージからインストールさせるとCIにかかる時間が減るらしい&lt;/p&gt;

&lt;h3 id=&#34;バッジを貼る&#34;&gt;バッジを貼る&lt;/h3&gt;

&lt;h4 id=&#34;travisci-1&#34;&gt;TravisCI&lt;/h4&gt;

&lt;p&gt;リポジトリのビルド結果の画面の中に表示されているバッジをクリックすると、
貼り付ける用のURLが出てくるので、*マークダウン*形式をコピーして&lt;code&gt;README&lt;/code&gt;に貼り付け&lt;/p&gt;

&lt;h4 id=&#34;codecov&#34;&gt;Codecov&lt;/h4&gt;

&lt;p&gt;リポジトリの画面の中の&lt;code&gt;Settings&lt;/code&gt; - &lt;code&gt;Badge&lt;/code&gt;で貼り付ける用のURLが出てくるので、
こちらも*マークダウン*形式をコピーして&lt;code&gt;README&lt;/code&gt;に貼り付け&lt;/p&gt;

&lt;h2 id=&#34;ドキュメント生成&#34;&gt;ドキュメント生成&lt;/h2&gt;

&lt;p&gt;基本&lt;code&gt;public&lt;/code&gt;になるものにはドキュメントコメントをつけていて、&lt;code&gt;juzzy&lt;/code&gt;でドキュメント生成をしていたが、
&lt;code&gt;CocoaPods&lt;/code&gt;に公開すれば&lt;code&gt;CocoaDocs&lt;/code&gt;が出来上がるので不要に。。。&lt;/p&gt;

&lt;h2 id=&#34;一旦-まとめ&#34;&gt;一旦、まとめ&lt;/h2&gt;

&lt;p&gt;ここまでの手順で、pushすると&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SwiftLint&lt;/code&gt;で静的解析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XCTest&lt;/code&gt;でユニットテスト&lt;/li&gt;
&lt;li&gt;ユニットテストのカバレッジを送信&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といったところまで自動で実行される状態となる&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org&#34;&gt;TravisCI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codecov.io/&#34;&gt;Codecov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/realm/SwiftLint&#34;&gt;SwiftLint&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UIPageViewControllerのエンドレス化などなど</title>
      <link>https://mike-neko.github.io/blog/pageview/</link>
      <pubDate>Tue, 13 Dec 2016 19:33:53 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/pageview/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;UIPageViewController&lt;/code&gt;をエンドレスでページ切り替えする方法とかその他小ネタ&lt;/p&gt;

&lt;p&gt;エンドレスの挙動は、最後のページから次へ進むと最初のページへ、最初のページからさらに戻ると最後のページへ移動する感じ。
詳細はサンプルを参照のこと&lt;/p&gt;

&lt;h2 id=&#34;作成の流れ&#34;&gt;作成の流れ&lt;/h2&gt;

&lt;p&gt;まず、画面の構造は以下の通り。ページ部分は&lt;code&gt;ChildViewController&lt;/code&gt;にしているが、
&lt;code&gt;UIPageViewController&lt;/code&gt;を全画面にしている場合も同じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ViewController
 └─ Container View
     └─ UIPageViewController
         └─ (各ページ)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ページの生成&#34;&gt;ページの生成&lt;/h3&gt;

&lt;p&gt;今回はページ数が固定（5ページ）を想定しているので、&lt;code&gt;viewDidLoad&lt;/code&gt;でページのリストをあらかじめ生成しておく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// var pages = [PageViewController]()
pages = Array(1...5).flatMap {
    guard let vc = storyboard?.instantiateViewController(withIdentifier: &amp;quot;Page&amp;quot;) as? PageViewController else {
        return nil
    }
    // 各ページの設定
    return vc
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リストを生成したら、初期表示するページを設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setViewControllers([pages[0]], direction: .forward, animated: false)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ページングの処理&#34;&gt;ページングの処理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;UIPageViewControllerDataSource&lt;/code&gt;の
&lt;code&gt;viewControllerBefore&lt;/code&gt;と&lt;code&gt;viewControllerAfter&lt;/code&gt;を実装する&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewControllerBefore&lt;/code&gt;だとこんな感じで前のページを返す&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let vc = viewController as? PageViewController,
    var index = pages.index(of: vc)  else { return nil }

index -= 1
index = (index &amp;lt; pages.startIndex) ? pages.endIndex - 1 : index
return pages[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは基準となるページ(引数で渡される&lt;code&gt;viewController&lt;/code&gt;)のインデックスをページのリストから検索して見つけること
(コードでは&lt;code&gt;index = pages.index(of: vc)&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;例えば、現在表示中のページのインデックスをプロパティに持っておく方法ではうまくいかない。
なぜならこのデリゲートは現在表示中のページ以外からも呼び出されるので&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;uipageviewcontrollerのstoryboardへの追加&#34;&gt;UIPageViewControllerのStoryboardへの追加&lt;/h3&gt;

&lt;p&gt;追加する時は、右下のUIパーツが並んでいるところから&lt;code&gt;PageViewController&lt;/code&gt;を選んで追加すること&lt;br /&gt;
通常の&lt;code&gt;ViewController&lt;/code&gt;で追加してしまうと後から変更しても、&lt;code&gt;UIPageViewController&lt;/code&gt;の設定項目が出てこない。。。&lt;/p&gt;

&lt;h3 id=&#34;ページを表示した時に各uiの位置が一瞬ずれて表示されてしまう場合&#34;&gt;ページを表示した時に各UIの位置が一瞬ずれて表示されてしまう場合&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AutoLayout&lt;/code&gt;の基準が&lt;code&gt;LayoutGuide&lt;/code&gt;になっているとダメな場合があるので&lt;code&gt;View&lt;/code&gt;を基準に変えてみる&lt;br /&gt;
（例えば上部は&lt;code&gt;TopLayoutGuide&lt;/code&gt;ではなく、&lt;code&gt;View&lt;/code&gt;からにする。&lt;code&gt;Constrain to margins&lt;/code&gt;はチェックを外す）&lt;/p&gt;

&lt;h3 id=&#34;container-viewの中のviewcontrollerを取得する&#34;&gt;Container Viewの中のViewControllerを取得する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Container View&lt;/code&gt;と&lt;code&gt;ChildViewController&lt;/code&gt;を繋ぐ&lt;code&gt;segue&lt;/code&gt;の&lt;code&gt;destination&lt;/code&gt;から取得できる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private weak var pager: PagerViewController!

override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    switch segue.destination {
    case let vc as PagerViewController:
        pager = vc
    default: break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、今回は&lt;code&gt;Container View&lt;/code&gt;の&lt;code&gt;PagerViewController&lt;/code&gt;は1つなので上記の判定だが、
同じクラスのものが複数ある場合は、&lt;code&gt;segue&lt;/code&gt;の&lt;code&gt;identifier&lt;/code&gt;で判定すれば良い
（もちろん、&lt;code&gt;Storyboard&lt;/code&gt;上で別々のIDを設定しておく）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 7+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/EndlessPage&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Provisioning Profileの有効期限をアプリ内で取得</title>
      <link>https://mike-neko.github.io/blog/provisioning/</link>
      <pubDate>Wed, 07 Dec 2016 19:18:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/provisioning/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AdHoc&lt;/code&gt;で作成したiOSアプリ(ipa)にはプロビジョニングプロファイルの有効期限が存在するが、
その有効期限をアプリ内から確認する方法&lt;/p&gt;

&lt;p&gt;確認自体はipaを解凍して見れば良いのだけど、エンタープライズの様にアプリ内で出したい場合は、
この方法であらかじめ設定画面とかに仕込むと良いかもしれない&lt;/p&gt;

&lt;p&gt;もちろん&lt;code&gt;Settings.bundle&lt;/code&gt;や直接アプリ内にリテラルとして持たすのも方法の一つだが、
それだと更新の度に余分な作業が発生したり更新忘れとかのミスも発生したりしがちなので、
この方法に行き着いた感じ&lt;/p&gt;

&lt;p&gt;（プロビジョニングプロファイルはアーカイブ時に確定されるので、
アプリバージョンのようにビルドスクリプトに仕込んでといった技は使えない。
Xcode7以前はdryrunでビルド設定を出力させてそこから特定ということもできたが、
Xcode8からの自動にした場合は使えないっぽい）&lt;/p&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;ipa作成時のプロビジョニングプロファイルについてまとめると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;プロビジョニングプロファイルの中身はほぼ&lt;code&gt;plist&lt;/code&gt;(XML)&lt;/li&gt;
&lt;li&gt;有効期限はプロビジョニングプロファイルの中の&lt;code&gt;ExpirationDate&lt;/code&gt;に&lt;code&gt;Date&lt;/code&gt;(NSDate)で記載&lt;/li&gt;
&lt;li&gt;プロビジョニングプロファイルはアプリのパッケージの中に
&lt;code&gt;embedded.mobileprovision&lt;/code&gt;という名前で同梱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを踏まえてコードにすると、以下の感じになる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/bdbedbb280883dff96b6a5a7062c67bd.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;まずは1行目にあるように、同梱されているプロビジョニングを取得する&lt;br /&gt;
&lt;strong&gt;デバッグ実行時には正しく取得できないので注意！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;次に5〜14行目にあるように、&lt;code&gt;plist&lt;/code&gt;として必要な部分のみに加工。
（不要部分があると変換に失敗するので）&lt;br /&gt;
抜き出したら&lt;code&gt;PropertyListSerialization&lt;/code&gt;で&lt;code&gt;Dictionary&lt;/code&gt;に変換して有効期限を抜き出す&lt;/p&gt;

&lt;p&gt;あとは、画面に表示させる為に文字列に変換してやって完了
（例では余裕を持って1日前の日付にしている）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>multipart/form-dataによるファイルのアップロード</title>
      <link>https://mike-neko.github.io/blog/multipart/</link>
      <pubDate>Tue, 06 Dec 2016 22:04:28 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/multipart/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;（&lt;code&gt;Alamofire&lt;/code&gt;とかのライブラリを使った方が幸せになれると思うが）
HTMLのフォームからの送信と同じ様な&lt;code&gt;multipart&lt;/code&gt;によるアップロードをiOSからする方法&lt;/p&gt;

&lt;h2 id=&#34;要件&#34;&gt;要件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;タイトル（文字列）とファイルを一緒にサーバへアップロード&lt;/li&gt;
&lt;li&gt;アップロード先は同じホストの&lt;code&gt;upload.php&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;サーバからはjsonで結果が返ってくる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;htmlの場合&#34;&gt;HTMLの場合&lt;/h2&gt;

&lt;p&gt;上記要件でかつアップロードと同じ画面内で結果を表示させたい場合、
&lt;code&gt;jQuery&lt;/code&gt;などを全く使わずに素のHTMLで書くと&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/9c53de2d62a4be94dd26131479b52c6f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;もし、ajaxではなく送信結果は次の画面で表示させる様な場合だと&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;タグは
&lt;code&gt;&amp;lt;form name=&amp;quot;upload&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;&lt;/code&gt;
とする必要がある&lt;/p&gt;

&lt;h2 id=&#34;iosの場合&#34;&gt;iOSの場合&lt;/h2&gt;

&lt;p&gt;もし単一のファイルのアップロードだけなら、&lt;code&gt;URLSession&lt;/code&gt;の&lt;code&gt;uploadTask(with:〜&lt;/code&gt;でOKだが、
他のデータやファイルも付加したい場合は自分で&lt;code&gt;multipart&lt;/code&gt;のリクエストを生成する必要がある&lt;/p&gt;

&lt;p&gt;とりあえずHTMLと同じものをベタ書き(+エラー省略)すると、&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/3825cf1ea22cb4f1a1469a33c44097ff.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;boundary文字列&#34;&gt;boundary文字列&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;multipart&lt;/code&gt;の場合、データの区切りを表すためにデータ内に含まれない様なバウンダリ文字列が必要となる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let boundary = String(format: &amp;quot;----iOSURLSessionBoundary.%08x%08x&amp;quot;, arc4random(), arc4random())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は&lt;code&gt;Alamofire&lt;/code&gt;を参考に送信元のプログラムとランダムな数字を組合せた文字列を生成している&lt;/p&gt;

&lt;h3 id=&#34;bodyの生成&#34;&gt;bodyの生成&lt;/h3&gt;

&lt;p&gt;フォームのデータの場合の構造は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)[CRLF]
Content-Disposition: form-data; name=&amp;quot;フォームの名前&amp;quot;[CRLF]
[CRLF]
(フォームのデータ)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;ファイルの場合の構造は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)[CRLF]
Content-Disposition: form-data; name=&amp;quot;フォームの名前&amp;quot;; filename=&amp;quot;ファイル名&amp;quot;[CRLF]
Content-Type: &amp;quot;ファイルのタイプ&amp;quot;[CRLF]
[CRLF]
(ファイルのデータ)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;各構造をバイナリ(&lt;code&gt;Data&lt;/code&gt;型)にしたものを必要な分だけ組合せて、最後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)--[CRLF]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をつけたものがbody部分のデータとなる&lt;/p&gt;

&lt;p&gt;今回の例だとフォームデータが一つとファイルデータが一つなので、
それぞれ一つずつを追加し最後にフッタを付けたものをbodyに入れている&lt;/p&gt;

&lt;h3 id=&#34;headerの生成&#34;&gt;headerの生成&lt;/h3&gt;

&lt;p&gt;フィールドにセットすべきなのは以下の2つ&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ldquo;Content-Type&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Content-Length&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;Content-Type&lt;/code&gt;にはタイプとバウンダリ文字列を以下のように指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;multipart/form-data; boundary=（バウンダリ文字列）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;は普通にbodyのサイズを入れればOK&lt;/p&gt;

&lt;h3 id=&#34;送信&#34;&gt;送信&lt;/h3&gt;

&lt;p&gt;送信は&lt;code&gt;uploadTask&lt;/code&gt;だと&lt;code&gt;multipart&lt;/code&gt;指定ができないので&lt;code&gt;dataTask&lt;/code&gt;で行う。
それ以外は通常の&lt;code&gt;dataTask&lt;/code&gt;のやり方でOK&lt;/p&gt;

&lt;h2 id=&#34;参考-サーバの処理-php&#34;&gt;参考：サーバの処理(PHP)&lt;/h2&gt;

&lt;p&gt;今回サーバ側で検証用に使ったのは以下のソース&lt;br /&gt;
（送信されてきたファイルはそのまま専用のディレクトリに格納し結果をJSONで返すだけ）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// &amp;quot;upload&amp;quot;のディレクトリに書き込み権限が必要
$dir = __DIR__ . &#39;/upload/&#39;;
$path = $dir . basename($_FILES[&#39;filename&#39;][&#39;name&#39;]);

$data[&#39;result&#39;] = &#39;アップロード失敗&#39;;
if (move_uploaded_file($_FILES[&#39;filename&#39;][&#39;tmp_name&#39;], $path)) {
    chmod($path, 0666);
    $data[&#39;result&#39;] = date(&amp;quot;H:i:s&amp;quot;) . &#39; &#39; . $_POST[&#39;title&#39;] . &#39; アップロード成功&#39;;
}

header(&#39;Content-Type: application/json&#39;);
echo json_encode($data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式：&lt;a href=&#34;http://php.net/manual/ja/features.file-upload.post-method.php&#34;&gt;POST メソッドによるアップロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MDN公式：&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/Guide/Using_FormData_Objects&#34;&gt;FormData オブジェクトの利用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;li&gt;PHP 7&lt;/li&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>WebRTCをiOSネイティブで使う(実装編)</title>
      <link>https://mike-neko.github.io/blog/webrtc-ios/</link>
      <pubDate>Wed, 30 Nov 2016 01:38:22 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/webrtc-ios/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSで&lt;code&gt;WebRTC&lt;/code&gt;を使ったビデオチャットを作る方法&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../webrtc-build&#34;&gt;準備編&lt;/a&gt;を参考にフレームワークを組み込む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt;に以下を書き込む（※）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Privacy - Camera Usage Description&lt;/code&gt;（カメラを使うのに必要）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Privacy - Microphone Usage Description&lt;/code&gt;（マイクを使うのに必要）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;※iOS10から必須。ないとアプリが強制終了する。
それぞれの値は使う理由の説明を入れておく&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;シグナリング&#34;&gt;シグナリング&lt;/h2&gt;

&lt;p&gt;WebRTCはP2P通信なので何らかの方法で相手と端末(&lt;code&gt;Peer&lt;/code&gt;)や
通信経路(&lt;code&gt;ICE Candidate&lt;/code&gt;)の情報をやり取りする必要がある&lt;/p&gt;

&lt;p&gt;つまり、何らかのWebRTCとは別の方法で端末間の通信を確立させておくことが必要となる&lt;/p&gt;

&lt;p&gt;といってもテキストベースの情報をやり取りできれば良いので、
特にややこしい訳ではない（もちろん接続管理はそれなりに必要だが）ので、
node.jsのsocket.ioで自前のサーバを立てるのも良いし、
サービスとして提供されているサーバを介してやりとりしても良い&lt;/p&gt;

&lt;p&gt;今回のサンプルでは完全にローカルなネットワークで、かつ、iOS同士限定なので
サーバが不要な&lt;code&gt;Multipeer Connectivity Framework&lt;/code&gt;を使っている
（詳細は&lt;a href=&#34;../multipeer/&#34;&gt;こちら&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;ビデオチャットは1対1で動画と音声をやりとりするタイプとする&lt;/p&gt;

&lt;p&gt;&lt;em&gt;生成したコネクション(&lt;code&gt;RTCPeerConnection&lt;/code&gt;)とローカル / リモートストリーム(&lt;code&gt;RTCMediaStream&lt;/code&gt;)はクラスのプロパティにして、
必ずstrongで保持されるようにしておくこと&lt;br /&gt;
これを忘れると正常に接続ができていても画像が出ない原因となるので注意！&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;接続の準備&#34;&gt;接続の準備&lt;/h3&gt;

&lt;p&gt;最初に自分が相手に送る動画と音声のストリームを準備する。
なお、カメラへのアクセスやカメラのライブ映像の表示はほぼフレームワークがカバーしてくれる&lt;/p&gt;

&lt;h4 id=&#34;ローカルストリームの生成&#34;&gt;ローカルストリームの生成&lt;/h4&gt;

&lt;p&gt;ビデオ（ライブ映像）ストリームを生成して端末のカメラと紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let factory = RTCPeerConnectionFactory()
localStream = factory.mediaStream(withStreamId: &amp;quot;MIKE-VIDEOCHAT&amp;quot;)
let video = factory.avFoundationVideoSource(with: nil)
let track = factory.videoTrack(with: video, trackId: &amp;quot;MIKE-VIDEOCHAT-V0&amp;quot;)
localStream.addVideoTrack(track)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オーディオ（音声）ストリームを生成する
（こちらは特に指定しなくても端末のマイクと紐付けされるみたい）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localStream.addAudioTrack(factory.audioTrack(withTrackId: &amp;quot;MIKE-VIDEOCHAT-A0&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;表示用のビューの生成&#34;&gt;表示用のビューの生成&lt;/h4&gt;

&lt;p&gt;相手に送信している映像を確認できるよう、表示用のView
(&lt;code&gt;RTCEAGLVideoView&lt;/code&gt;というOpenGLを利用して動画を表示する専用のView)
と端末のカメラを紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// localView: ViewController内に置いた表示用ビューのコンテナ
let local = RTCEAGLVideoView(frame: localView.bounds)
localView.addSubview(local)
track.add(local)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで端末のフロントカメラの映像が自動で表示されるようになる&lt;/p&gt;

&lt;h4 id=&#34;接続の生成&#34;&gt;接続の生成&lt;/h4&gt;

&lt;p&gt;ビデオチャットなのでVideoとAudioを必須と指定して&lt;code&gt;RTCPeerConnection&lt;/code&gt;を生成する。
またローカルストリームを接続と紐づけて相手に送信できるようにする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// peer: RTCPeerConnection
let constraints = RTCMediaConstraints(
  mandatoryConstraints: [&amp;quot;OfferToReceiveVideo&amp;quot;: kRTCMediaConstraintsValueTrue,
                         &amp;quot;OfferToReceiveAudio&amp;quot;: kRTCMediaConstraintsValueTrue],
   optionalConstraints: nil)
peer = factory.peerConnection(with: RTCConfiguration(),
                       constraints: constraints,
                          delegate: self)
peer.add(localStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;接続の開始&#34;&gt;接続の開始&lt;/h3&gt;

&lt;p&gt;接続の準備ができればシグナリングを行なって相手と接続を確立させる&lt;/p&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;端末Aがofferを送信&lt;/li&gt;
&lt;li&gt;端末Bが端末Aのofferを受信&lt;/li&gt;
&lt;li&gt;端末Bが端末Aへanswerを送信&lt;/li&gt;
&lt;li&gt;端末Aが端末Bのanswerを受信&lt;/li&gt;
&lt;li&gt;ICEをやりとりしてP2Pで接続を確立&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;h4 id=&#34;端末a-offerの送信&#34;&gt;[端末A] offerの送信&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;peer.offer&lt;/code&gt;で生成したローカルの情報を&lt;code&gt;peer.setLocalDescription&lt;/code&gt;で設定すると、
offerとなる&lt;code&gt;SDP&lt;/code&gt;（Peerの情報）が取得できるので、それを相手へ送信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peer.offer(for: constraints) { (description, error) in
  guard let localDescription = description, error == nil else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
  self.peer.setLocalDescription(localDescription) { error in
    guard error == nil,
          let state = self.peer.signalingState,
          case .haveLocalOffer = state else {
      print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
      return
    }
    // localDescription.sdp(=offer)を相手へ送信する
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;端末b-offerの受信-answerの送信&#34;&gt;[端末B] offerの受信 / answerの送信&lt;/h4&gt;

&lt;p&gt;受信した&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCSessionDescription&lt;/code&gt;でリモートの情報を生成し&lt;code&gt;peer.setRemoteDescription&lt;/code&gt;で設定する&lt;/p&gt;

&lt;p&gt;offerを正常に設定できれば、&lt;code&gt;peer.answer&lt;/code&gt;でローカルの情報を生成し&lt;code&gt;peer.setLocalDescription&lt;/code&gt;で設定すると、
answerとなる&lt;code&gt;SDP&lt;/code&gt;が取得できるので、それを相手へ返信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sdp: 受信した端末Aのoffer
let remoteDescription = RTCSessionDescription(type: .offer, sdp: sdp)
peer.setRemoteDescription(remoteDescription) { error in
  guard error == nil,
        let state = self.peer.signalingState, 
        case .haveRemoteOffer = state else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
  self.peer.answer(for: constraints) { (description, error) in
    guard let localDescription = description, error == nil else {
      print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
      return
    }
    self.peer.setLocalDescription(localDescription) { error in
      guard error == nil else {
        print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
        return
      }
      // localDescription.sdp(=answer)を相手へ送信する
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;端末a-answerの受信&#34;&gt;[端末A] answerの受信&lt;/h4&gt;

&lt;p&gt;相手から返信された&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCSessionDescription&lt;/code&gt;でリモートの情報を生成し&lt;code&gt;peer.setRemoteDescription&lt;/code&gt;で設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sdp: 受信した端末Bのanswer
let remoteDescription = RTCSessionDescription(type: .answer, sdp: sdp)
peer.setRemoteDescription(remoteDescription) { error in
  guard error == nil else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;iceの送受信&#34;&gt;ICEの送受信&lt;/h4&gt;

&lt;p&gt;SDPのやり取りとは別に通信経路(&lt;code&gt;ICE Candidate&lt;/code&gt;)もやり取りする必要がある&lt;/p&gt;

&lt;p&gt;こちらは単純に相手に渡すべき&lt;code&gt;ICE Candidate&lt;/code&gt;があると、&lt;code&gt;RTCPeerConnectionDelegate&lt;/code&gt;の&lt;code&gt;didGenerate&lt;/code&gt;が呼ばれるのでそれを相手へ送信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func peerConnection(_ peerConnection: RTCPeerConnection, didGenerate candidate: RTCIceCandidate) {
  // candidate.sdp(=ICE)を相手へ送信する
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;受信した側は、&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCIceCandidate&lt;/code&gt;を生成して&lt;code&gt;RTCPeerConnection&lt;/code&gt;に追加する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let can = RTCIceCandidate(sdp: sdp, sdpMLineIndex: 0, sdpMid: nil)
peer.add(can)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは何度か行われる&lt;/p&gt;

&lt;h3 id=&#34;リモートストリームの受信&#34;&gt;リモートストリームの受信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ICE&lt;/code&gt;のやり取りで接続が確立されると、&lt;code&gt;RTCPeerConnectionDelegate&lt;/code&gt;の&lt;code&gt;didAdd&lt;/code&gt;が呼び出されて、
相手側からのリモートストリームが渡される&lt;/p&gt;

&lt;p&gt;今回はVideoとAudioの両方のストリームがくるはずなので、それを表示用のViewと紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func peerConnection(_ peerConnection: RTCPeerConnection, 
                       didAdd stream: RTCMediaStream) {
  // remoteView: ViewController内に置いた表示用ビューのコンテナ
  let remote = RTCEAGLVideoView(frame: remoteView.bounds)
  remoteView.addSubview(remote)
  stream.videoTracks.last?.add(remote)
  remoteStream = stream
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで相手の映像が表示されてチャットができるようになる&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12&lt;/li&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/WebRTCVideoChat&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WebRTCをiOSネイティブで使う(準備編)</title>
      <link>https://mike-neko.github.io/blog/webrtc-build/</link>
      <pubDate>Tue, 29 Nov 2016 23:24:55 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/webrtc-build/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのブラウザでは&lt;code&gt;WebRTC&lt;/code&gt;がサポートされていないので、利用したい場合は
ネイティブのフレームワークを使う必要がある。&lt;/p&gt;

&lt;p&gt;今回の準備編では公式のフレームワークを使うにあたってフレームワークの生成と組み込みまでの手順について&lt;/p&gt;

&lt;p&gt;ただ、これが結構面倒で、ソースをダウンロードして一からビルドしないといけないし、
その方法が公式に明記されていないというおまけ付き&lt;/p&gt;

&lt;p&gt;普段、GitHubやCarthageに頼りきっている身には大変だった・・・&lt;/p&gt;

&lt;h2 id=&#34;フレームワークの生成&#34;&gt;フレームワークの生成&lt;/h2&gt;

&lt;p&gt;まずは、作業用の適当なフォルダを作っておく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir 作業用のフォルダ
cd 作業用のフォルダ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルド用のツールをインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install git
brew install python
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースをダウンロードする&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;以下、ものすごく時間と容量をくうので注意！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=`pwd`/depot_tools:&amp;quot;$PATH&amp;quot;
fetch --nohooks webrtc_ios
gclient sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd src
webrtc/build/ios/build_ios_libs.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功すれば、&lt;code&gt;src/out_ios_libs/&lt;/code&gt;の中に&lt;code&gt;WebRTC.framework&lt;/code&gt;ができている&lt;/p&gt;

&lt;h2 id=&#34;組み込み&#34;&gt;組み込み&lt;/h2&gt;

&lt;p&gt;組み込み自体は他のサードパーティのフレームワークと一緒だが、ポイントは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Embedded Binaries&lt;/code&gt;で追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Build Settings&lt;/code&gt;で&lt;code&gt;Bitcode&lt;/code&gt;を無効にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というあたり&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;Video&lt;/code&gt;を使う場合はシミュレータが使えないので注意&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://webrtc.org/native-code/&#34;&gt;WebRTC公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12&lt;/li&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MultipeerConnectivityでP2P通信</title>
      <link>https://mike-neko.github.io/blog/multipeer/</link>
      <pubDate>Tue, 29 Nov 2016 18:40:09 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/multipeer/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS同士限定になるが、&lt;code&gt;Multipeer Connectivity Framework&lt;/code&gt;でお手軽にP2P通信をさせる方法&lt;/p&gt;

&lt;p&gt;今回は特に&lt;code&gt;MCBrowserViewController&lt;/code&gt;を使わずに実装してみた&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;おおまかな流れは&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MCSession&lt;/code&gt;で接続を開く&lt;br /&gt;
同時に&lt;code&gt;MCNearbyServiceAdvertiser&lt;/code&gt;で他の端末からの接続を待機&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MCNearbyServiceBrowser&lt;/code&gt;で待機している端末を探す&lt;br /&gt;
見つかれば、招待して接続を確立する&lt;/li&gt;
&lt;li&gt;招待された側が招待を受け入れれば接続が確立されるので、データをやりとりできる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、各種デリゲートはメインスレッドで呼び出されるとは限らないので、
UIを操作する場合は注意すること&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;接続の開始&#34;&gt;接続の開始&lt;/h3&gt;

&lt;p&gt;各端末は&lt;code&gt;Peer&lt;/code&gt;（ピア）と呼ばれ、相手に表示させる表示名を設定できる。
自端末をあらわす&lt;code&gt;Peer&lt;/code&gt;を生成したら、それを使って接続を開始する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let peerID = MCPeerID(displayName: &amp;quot;表示名&amp;quot;)
session = MCSession(peer: peerID, securityIdentity: nil, encryptionPreference: .none)
session.delegate = self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに他の端末から見える状態にする為に&lt;code&gt;MCNearbyServiceAdvertiser&lt;/code&gt;を設定する。
サービス名は相手を検索するのに使用するIDの様なものなので、かぶらないものを指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;advertiser = MCNearbyServiceAdvertiser(peer: peerID, discoveryInfo: nil, serviceType: &amp;quot;サービス名&amp;quot;)
advertiser.delegate = self
advertiser.startAdvertisingPeer()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまでの手順でいわば接続の待ち受け状態となる&lt;/p&gt;

&lt;h3 id=&#34;相手の検索と接続の確立&#34;&gt;相手の検索と接続の確立&lt;/h3&gt;

&lt;p&gt;相手を検索するには、&lt;code&gt;MCNearbyServiceBrowser&lt;/code&gt;を利用する。
サービス名には&lt;code&gt;Advertiser&lt;/code&gt;で設定したのと同じものを指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;browser = MCNearbyServiceBrowser(peer: peerID, serviceType: &amp;quot;サービス名&amp;quot;)
browser.delegate = self
browser.startBrowsingForPeers()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定したサービス名と同じPeerが見つかると&lt;code&gt;MCNearbyServiceBrowserDelegate&lt;/code&gt;の&lt;code&gt;foundPeer&lt;/code&gt;が呼び出される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func browser(_ browser: MCNearbyServiceBrowser,
      foundPeer peerID: MCPeerID,
withDiscoveryInfo info: [String : String]?) {
    print(&amp;quot;found: \(peerID)&amp;quot;)
    browser.invitePeer(peerID, to: session, withContext: nil, timeout: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見つかった相手に、&lt;code&gt;invitePeer&lt;/code&gt;で接続を招待することができる。
招待された側には、&lt;code&gt;MCNearbyServiceAdvertiserDelegate&lt;/code&gt;の&lt;code&gt;didReceiveInvitationFromPeer&lt;/code&gt;が呼び出される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func advertiser(_ advertiser: MCNearbyServiceAdvertiser,
  didReceiveInvitationFromPeer peerID: MCPeerID,
                  withContext context: Data?,
                    invitationHandler: @escaping (Bool, MCSession?) -&amp;gt; Void) {
    print(&amp;quot;InvitationFrom: \(peerID)&amp;quot;)
    invitationHandler(true, session)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;invitationHandler&lt;/code&gt;の第一引数で&lt;code&gt;true&lt;/code&gt;を渡すと招待を受け入れたことになり接続が確立される。&lt;/p&gt;

&lt;h3 id=&#34;データの送受信&#34;&gt;データの送受信&lt;/h3&gt;

&lt;p&gt;接続が確立されればデータのやりとりが出来る様になる。
データのやりとりには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data / NSData&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URL / NSURL&lt;/code&gt;でのリソース&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stream / NSStream&lt;/code&gt;でのストリーム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のどれかを使う&lt;/p&gt;

&lt;p&gt;一番シンプルな&lt;code&gt;Data&lt;/code&gt;の場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.send(data, toPeers: session.connectedPeers, with: .reliable)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、接続を確立しているPeer全てにデータを送信できる。
&lt;code&gt;.reliable&lt;/code&gt;にするとデータの送信順が保証され、
&lt;code&gt;.unreliable&lt;/code&gt;にすると送信順が保証されない代わりに即時にデータが送られる&lt;/p&gt;

&lt;p&gt;送信されたデータは、&lt;code&gt;MCSessionDelegate&lt;/code&gt;の各メソッドで受け取ることができる。
&lt;code&gt;Data&lt;/code&gt;の場合だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で受け取れる&lt;/p&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;上記を元に2台の端末同士でP2Pで単純なテキストを送受信するクラスのソースは以下のとおり&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/00e0e04fd7bdf4c3e9378fc6d8e0a11a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;使い方は、&lt;/p&gt;

&lt;h4 id=&#34;接続の開始-1&#34;&gt;接続の開始&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;P2PConnectivity.manager.start(
    serviceType: &amp;quot;MIKE-SIMPLE-P2P&amp;quot;,
    displayName: UIDevice.current.name,
    stateChangeHandler: { state in
        // 接続状況の変化した時の処理
    }, recieveHandler: { data in
        // データを受信した時の処理
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;データの送信&#34;&gt;データの送信&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 送信
P2PConnectivity.manager.send(message: &amp;quot;送信するテキスト&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;終了&#34;&gt;終了&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;P2PConnectivity.manager.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じ&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Guzzle(PHP)でAPNsの同時配信を行う</title>
      <link>https://mike-neko.github.io/blog/guzzle-apns/</link>
      <pubDate>Sat, 29 Oct 2016 22:40:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle-apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;でiOSのAPNs(Push通知)をお手軽に同時配信する方法&lt;/p&gt;

&lt;p&gt;APNs自体については&lt;a href=&#34;../http2apns/&#34;&gt;APNs Provider API(http2)を利用する(Node.js)&lt;/a&gt;を参照&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;自体は&lt;a href=&#34;../guzzle/&#34;&gt;以前の記事&lt;/a&gt;を参照&lt;/p&gt;

&lt;h3 id=&#34;curlの更新&#34;&gt;curlの更新&lt;/h3&gt;

&lt;p&gt;APNsを使うには&lt;code&gt;http2&lt;/code&gt;が必要かつ非同期で実行したいので、&lt;code&gt;curl&lt;/code&gt;をインストールし直す&lt;/p&gt;

&lt;p&gt;&lt;code&gt;homebrew&lt;/code&gt;を使っている場合は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install curl --with-nghttp2 --with-openssl
brew link curl --force
brew reinstall php56 --with-homebrew-curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、自分で試した時は上記だけでは&lt;code&gt;http2&lt;/code&gt;が有効にならなかったので、
アンイストールした方が確実かもしれない&lt;/p&gt;

&lt;p&gt;更新後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;code&gt;http2&lt;/code&gt;が出ていればOK&lt;/p&gt;

&lt;h2 id=&#34;guzzleの使い方&#34;&gt;Guzzleの使い方&lt;/h2&gt;

&lt;h3 id=&#34;http2で通信する&#34;&gt;http2で通信する&lt;/h3&gt;

&lt;p&gt;オプションで指定するだけでOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;version&#39; =&amp;gt; 2.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post送信&#34;&gt;POST送信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;はリクエスト時のオプションとして以下の感じで指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client();
$response = $client-&amp;gt;request(&#39;POST&#39;, $url, [&#39;body&#39; =&amp;gt; $body]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;の中身を&lt;code&gt;JSON&lt;/code&gt;にしたい時は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;body&#39; =&amp;gt; json_encode($json])]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形にして渡す&lt;/p&gt;

&lt;h3 id=&#34;クライアント証明書をつける&#34;&gt;クライアント証明書をつける&lt;/h3&gt;

&lt;p&gt;これもオプションで指定するだけでOK&lt;/p&gt;

&lt;p&gt;例えば同じ階層内に&lt;code&gt;apns_dev.pem&lt;/code&gt;という証明書（パスフレーズ&lt;code&gt;0000&lt;/code&gt;）に置いた場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;cert&#39; =&amp;gt; [&#39;apns_dev.pem&#39;, &#39;0000&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あえていうなら、&lt;code&gt;pem&lt;/code&gt;形式の証明書を作るのがちょっと面倒&lt;/p&gt;

&lt;h2 id=&#34;apnsの同時配信&#34;&gt;APNsの同時配信&lt;/h2&gt;

&lt;p&gt;APNsは通知内容をJSONで指定することと、前回の並列リクエストを併せると、以下のコードで同時配信が実現できる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/dcc15bedbc4d42e4e8b1c31119f3c63a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;（※配信環境はSandBox向け）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UIScrollViewのAutoLayoutをStoryboardのみで設定</title>
      <link>https://mike-neko.github.io/blog/scrollview/</link>
      <pubDate>Sun, 23 Oct 2016 22:28:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/scrollview/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Storyboard上だけでUIScrollViewのAutoLayoutを完結させる方法。
中のUIを動的に追加や削除しないのであればコードを書く必要もないし、
&lt;code&gt;UILabel&lt;/code&gt;のようにコンテンツに応じて動的に高さが変わるようなものにも対応可能&lt;/p&gt;

&lt;p&gt;ポイントは&lt;code&gt;ContainerView&lt;/code&gt;を利用してScrollViewを別のViewControllerに持っていくこと&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;サンプルとしてViewControllerの全画面に縦スクロールするScrollViewを配置する例を考える&lt;/p&gt;

&lt;h4 id=&#34;1-viewcontrollerのscrollviewを置きたい場所に-containerview-を置き制約を設定する&#34;&gt;1. ViewControllerのScrollViewを置きたい場所に&lt;code&gt;ContainerView&lt;/code&gt;を置き制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;&lt;code&gt;Layout Guide&lt;/code&gt;に対して制約を設定するとステータスバーなどに合わせて位置が変わる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1で追加した子viewcontrollerをアウトライン上で選択し-viewcontrollerのサイズを-freeform-へ変更する&#34;&gt;2. 1で追加した子ViewControllerをアウトライン上で選択し、ViewControllerのサイズを&lt;code&gt;Freeform&lt;/code&gt;へ変更する&lt;/h4&gt;

&lt;p&gt;変更すると&lt;code&gt;Height&lt;/code&gt;の部分が変更できるようになるので、
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step2.png&#34; /&gt;
&lt;/figure&gt;

ScrollViewの&lt;code&gt;ContentSize&lt;/code&gt;の高さがあらかじめ決まっているのであれば同じに、
そうでないなら余裕を持った数字に変えておく&lt;/p&gt;

&lt;p&gt;&lt;em&gt;サイズを変更しなくても組めるが変更した方がスクロールせずに作業が行えるので楽&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-1で追加した子viewcontrollerのviewにscrollviewを追加し任意の制約を設定する&#34;&gt;3. 1で追加した子ViewControllerのViewにScrollViewを追加し任意の制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して今回も&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;もしスクロールしないヘッダとつけたりしたいなら、この子ViewControllerのViewに対して追加しておくと便利&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-3で追加したscrollviewにviewを追加し制約を設定する&#34;&gt;4. 3で追加したScrollViewにViewを追加し制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）縦スクロールにしたいので制約は以下の通り
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step4.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;縦と横はそれぞれ親(Scrollview)に対して&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;横幅は親(Scrollview)と同じ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ここで追加したViewがいわば&lt;code&gt;ContentView&lt;/code&gt;となる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-4のviewに各パーツを配置していく&#34;&gt;5. 4のviewに各パーツを配置していく&lt;/h4&gt;

&lt;p&gt;この工程は普段通りのAutoLayoutの設定でOK。
&lt;code&gt;UILabel&lt;/code&gt;の高さをコンテンツに応じて変えたいなら高さを設定せずにマージンだけを設定する&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scrollviewの中身の高さが固定でないなら&lt;code&gt;height&lt;/code&gt;は設定しないこと&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考-viewの階層&#34;&gt;参考：Viewの階層&lt;/h3&gt;

&lt;p&gt;子ViewControllerのアウトライン
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/view.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AutoLayout&lt;/code&gt;って使い方のコツを見つけるまでが大変だけど、このサンプルみたいにやり方を見つけてしまうと楽すぎ〜〜&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>NotificationCenter(Swift3)の使い方</title>
      <link>https://mike-neko.github.io/blog/notification/</link>
      <pubDate>Sun, 23 Oct 2016 18:30:34 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/notification/</guid>
      <description>

&lt;p&gt;旧&lt;code&gt;NSNotification&lt;/code&gt;がSwift3でちょっと変更が入ったので使い方と＋αのエクステンションのまとめ&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;h3 id=&#34;通知の送信&#34;&gt;通知の送信&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Change&amp;rdquo;という名前の通知を送信するときは以下の2パターン&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.post(
    Notification(name: Notification.Name(&amp;quot;Change&amp;quot;)))

NotificationCenter.default.post(name: Notification.Name(&amp;quot;Change&amp;quot;),
                                object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通知の受信&#34;&gt;通知の受信&lt;/h3&gt;

&lt;p&gt;上述の通知を受信したい場合は、&lt;/p&gt;

&lt;h4 id=&#34;受信先の登録&#34;&gt;受信先の登録&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    name: Notification.Name(&amp;quot;Change&amp;quot;),
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、登録した場合は解除も忘れずにすること！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考: UIKeyboardWillShowNotificationとかは&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(keyboardWillShow),
    name: .UIKeyboardWillShow,
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに名前が定義されているので省略形で良い&lt;/p&gt;

&lt;h4 id=&#34;受信するメソッド&#34;&gt;受信するメソッド&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func recieveHoge(notification: NSNotification) {
    // ここで処理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アクセス制限は&lt;code&gt;internal&lt;/code&gt;以上が必要（&lt;code&gt;private&lt;/code&gt;/&lt;code&gt;fileprivate&lt;/code&gt;は不可）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;post&lt;/code&gt;時に送った&lt;code&gt;object&lt;/code&gt;を利用したい場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let hoge = notification.object as? Hoge else { return }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というように変換して使う&lt;/p&gt;

&lt;p&gt;また、特に指定をしないとメイン以外のスレッドで呼び出されることがあるので、
UI絡みの部分は&lt;code&gt;DispatchQueue.main.async&lt;/code&gt;を使った方が良い&lt;/p&gt;

&lt;h4 id=&#34;受信の解除&#34;&gt;受信の解除&lt;/h4&gt;

&lt;p&gt;特定の通知のみ解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self,
                                          name: Notification.Name(&amp;quot;Change&amp;quot;),
                                          object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自身が登録している受信を全て解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;エクステンション&#34;&gt;エクステンション&lt;/h2&gt;

&lt;p&gt;今回のSwift3から&lt;code&gt;Notification.Name&lt;/code&gt;の部分で、以前と比べて手間がかかるようになってしまった
（元からOSで用意されているものは逆に楽）&lt;/p&gt;

&lt;p&gt;それとは別に、名前がアプリの他とかぶらないようになるべく一元管理をしたいので、以下のようなエクステンションと&lt;code&gt;enum&lt;/code&gt;を利用する&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5c92a36705ebcc3c49022a534d4df157.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;em&gt;※&lt;code&gt;enum&lt;/code&gt;はガイドライン的には小文字が良いが文字定数を強調したいので大文字になっている&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;特にエクステンションといっても特別なことはしていなくて単に専用の&lt;code&gt;enum&lt;/code&gt;を使えるようにしただけ。&lt;br /&gt;
でも、これを実際に使うと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通知の送信
NotificationCenter.default.post(key: .ChangeStatus)

// 通知の受信先の登録
NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    key: .ChangeStatus)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;って感じですっきりする&lt;/p&gt;

&lt;p&gt;本来は、&lt;code&gt;Notification.Name&lt;/code&gt;をエクステンションして使うのが想定されているようだが、
&lt;code&gt;enum&lt;/code&gt;により一意になることが保証されるのと、リテラルが出てこないので、個人的にはこっちがお気に入り&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ATS有効の状態でオレオレ証明書を使って通信する(iOS9)</title>
      <link>https://mike-neko.github.io/blog/ios-cert/</link>
      <pubDate>Tue, 06 Sep 2016 00:35:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/ios-cert/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ATS&lt;/code&gt;が有効の場合、SSL/TLS通信でないと通信自体ができない。&lt;/p&gt;

&lt;p&gt;が、開発時はローカル環境だったりドメイン自体がなかったりで正式なSSL証明書を使えないことが多い・・・
かといって、ATSをOFFにして開発するのも・・・&lt;/p&gt;

&lt;p&gt;って時に自己署名証明書（オレオレ証明書）を使ってしのぐ方法。&lt;/p&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;オレオレ証明書を作ってサーバへ設定&lt;/li&gt;
&lt;li&gt;iOS端末へオレオレ証明書をインストール&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;br /&gt;
ポイントはオレオレ証明書のインストール部分で、その手順をメモしておく。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;証明書の作成のあたりは&lt;a href=&#34;../docker/&#34;&gt;Docker構築メモ&lt;/a&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;注意&#34;&gt;！注意！&lt;/h2&gt;

&lt;p&gt;検証はiOS9でのみ。iOS10は未検証。
（ローカル環境でのATSの挙動が変わりそう！？）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;は&lt;code&gt;2.2&lt;/code&gt;の操作方法。&lt;/p&gt;

&lt;p&gt;また、&lt;strong&gt;セキュリティ面で危険&lt;/strong&gt;なのでくれぐれもオレオレ証明書の容量・用法には気をつけること&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;前提：サーバへのオレオレ証明書は設定済みの状態&lt;/p&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;オレオレ証明書&lt;code&gt;server.crt&lt;/code&gt;を作成しておく&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator2&lt;/code&gt;をインストールしておく&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;構成プロファイルの作成&#34;&gt;構成プロファイルの作成&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;のメニューの&lt;code&gt;ファイル&lt;/code&gt;から&lt;code&gt;新規プロファイル&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側の&lt;code&gt;証明書&lt;/code&gt;の項目を選択し&lt;code&gt;構成&lt;/code&gt;ボタンを押下&lt;/li&gt;
&lt;li&gt;ファイル選択画面でオレオレ証明書(&lt;code&gt;server.crt&lt;/code&gt;)を選択して開く&lt;/li&gt;
&lt;li&gt;メニューの&lt;code&gt;ファイル&lt;/code&gt;から&lt;code&gt;保存&lt;/code&gt;を選択し、適当な名前をつけて保存&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;端末へインストール&#34;&gt;端末へインストール&lt;/h3&gt;

&lt;p&gt;以下のどちらかの方法でインストールする&lt;/p&gt;

&lt;h4 id=&#34;apple-configurator経由&#34;&gt;Apple Configurator経由&lt;/h4&gt;

&lt;p&gt;Macと端末の有線接続が必要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;に接続中の端末が表示されるので選択&lt;/li&gt;
&lt;li&gt;ツールバーの&lt;code&gt;追加&lt;/code&gt;ボタンから&lt;code&gt;プロファイル&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;作成した構成プロファイルを選択&lt;/li&gt;
&lt;li&gt;iOS端末の画面がインストール画面に変わるので、&lt;code&gt;インストール&lt;/code&gt;x3&lt;br /&gt;
（プロファイルのインストールはConfiguratorから操作不可）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ネットワーク経由&#34;&gt;ネットワーク経由&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;適当なサーバに構成プロファイルを置いてダウンロードできるようにする&lt;/li&gt;
&lt;li&gt;iOS端末のSafariから該当のURLへアクセス&lt;/li&gt;
&lt;li&gt;インストール画面になるので&lt;code&gt;インストール&lt;/code&gt;x3&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、証明書だけをインストールしてもアプリからは接続できないので、
&lt;code&gt;構成プロファイル&lt;/code&gt;を作ってからインストールするのが大事！&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Appleのテクニカルノート：&lt;a href=&#34;https://developer.apple.com/library/ios/technotes/tn2326/_index.html&#34;&gt;TLSのテスト用証明書の作成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.4&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>jazzyの使い方 その1</title>
      <link>https://mike-neko.github.io/blog/jazzy-cmd/</link>
      <pubDate>Sat, 03 Sep 2016 00:12:14 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/jazzy-cmd/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Swiftのドキュメント生成ツールの&lt;a href=&#34;https://github.com/realm/jazzy&#34;&gt;jazzy&lt;/a&gt;の使い方。
その1はコマンド周りのメモ。&lt;/p&gt;

&lt;h2 id=&#34;ドキュメント生成時のコマンド&#34;&gt;ドキュメント生成時のコマンド&lt;/h2&gt;

&lt;p&gt;主に自分個人で使う時のコマンドは以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jazzy -o Documents --min-acl internal --skip-undocumented -a M.Ike -x SYMROOT=/private/tmp/jazzy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;o-documents&#34;&gt;&amp;rdquo;-o Documents&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-o [フォルダ]&lt;/code&gt;でドキュメントを出力するフォルダを指定する。&lt;br /&gt;
なお、フォルダが存在しない場合は自動で作成される。&lt;/p&gt;

&lt;p&gt;今回の指定だと以下の場所にフォルダが生成される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample                 # 対象のプロジェクトのフォルダ
  ├─ Sample            # Xcodeのソースなど一式
  ├─ Sample.xcodeproj  # Xcodeのプロジェクトファイル
  └─ Documents         # この中に生成されたドキュメント一式が入る
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;min-acl-internal&#34;&gt;&amp;rdquo;&amp;ndash;min-acl internal&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;--min-acl [private | internal | public]&lt;/code&gt;で出力の対象を指定する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Swift2.x&lt;/code&gt;では&lt;code&gt;public&lt;/code&gt;は使わずに、明示的な&lt;code&gt;private&lt;/code&gt;か暗黙的な&lt;code&gt;internal&lt;/code&gt;しか使わない
（※複数のモジュールを利用しない場合）
ので、&lt;code&gt;internal&lt;/code&gt;以上で設定している。&lt;/p&gt;

&lt;h3 id=&#34;skip-undocumented&#34;&gt;&amp;rdquo;&amp;ndash;skip-undocumented&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;この設定をすると、ドキュメントコメントのないソースからはドキュメントを生成しなくなる。&lt;/p&gt;

&lt;p&gt;さらに&lt;code&gt;documentation-coverage&lt;/code&gt;の対象からも除外される。&lt;/p&gt;

&lt;h3 id=&#34;a&#34;&gt;&amp;rdquo;-a&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;作者名の指定。
別に個人用なので必要もないが、ないと見栄えが悪いのでつけている。&lt;/p&gt;

&lt;h3 id=&#34;x-symroot-private-tmp-jazzy&#34;&gt;&amp;rdquo;-x SYMROOT=/private/tmp/jazzy&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-x arg1,arg2,…argN,&lt;/code&gt;で&lt;code&gt;xcodebuild&lt;/code&gt;時のビルドオプションを指定できる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jazzy&lt;/code&gt;を使うと&lt;code&gt;build&lt;/code&gt;というビルドの一時ファイルの入ったディレクトリが
プロジェクトのフォルダ内に生成されてしまう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;でちゃんと指定しているので実害はないが、一時ファイルが生成されるのは気持ち悪い。。。&lt;/p&gt;

&lt;p&gt;という訳で、これを指定すれば&lt;code&gt;jazzy&lt;/code&gt;利用時の一時ファイルを
&lt;code&gt;/private/tmp/jazzy&lt;/code&gt;(テンポラリフォルダ)へ出力させることができ、
同じフォルダ内に&lt;code&gt;build&lt;/code&gt;フォルダが生成されなくなる。
（テンポラリフォルダは再起動時に消去される）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ただしXcodeのプロジェクトの設定によっては、別の環境変数を書き換える必要あり&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;使っていないもの&#34;&gt;使っていないもの&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;をつけると、ドキュメント作成前に元のデータを全部消してくれるので、
本来はつけておいた方が良いオプション。&lt;/p&gt;

&lt;p&gt;が、ヘルプにもあるように、指定した出力先のフォルダが&lt;strong&gt;問答無用で削除&lt;/strong&gt;されてしまう。。。&lt;br /&gt;
開発中はターミナルから手打ち（コピペ）して使うことが多いので、
間違って指定してしまった！という悲劇を防ぐ為、これは指定していない&lt;/p&gt;

&lt;p&gt;（確実に作りたい時は手動で削除で対応。
ビルド用のシェルスクリプトを組んでいる場合はつけている）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.6&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;jazzy 0.7.0&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/http2apns-ios/</link>
      <pubDate>Thu, 25 Aug 2016 23:00:38 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns-ios/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
しかもiOS端末からPush通知を送信する方法。&lt;/p&gt;

&lt;p&gt;前回の&lt;a href=&#34;../http2apns/&#34;&gt;Node.jsからAPNsを使う方法&lt;/a&gt;の派生ネタ。
&lt;code&gt;APNs Provider API&lt;/code&gt;はhttp2とクライアント証明書に対応さえしていればPushを送れるので、
それならiOS端末からでも良けるよね？って試してみた。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;iOSならiOS9から&lt;code&gt;http2&lt;/code&gt;に対応しているので、証明書の準備のみ必要。&lt;/p&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;の手順で&lt;code&gt;apns.p12&lt;/code&gt;を書き出せばOK。
&lt;code&gt;.pem&lt;/code&gt;の作成やCAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;ポイントは&lt;code&gt;https&lt;/code&gt;のクライアント認証を実装すること。
それができれば後はPOST形式でAPIを呼び出すだけなので簡単（APIについては&lt;a href=&#34;../http2apns/&#34;&gt;前回記事&lt;/a&gt;参照）&lt;/p&gt;

&lt;h3 id=&#34;クライアント認証&#34;&gt;クライアント認証&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;NSURLSession&lt;/code&gt;でクライアント認証を実装するには、&lt;code&gt;NSURLSessionDelegate&lt;/code&gt;の
&lt;code&gt;URLSession(_:didReceiveChallenge:completionHandler:)&lt;/code&gt;を実装する。&lt;/p&gt;

&lt;p&gt;サーバからクライアント認証が要求されると、このデリゲートメソッドが呼ばれるので、
クライアント証明書を読み込んで&lt;code&gt;NSURLCredential&lt;/code&gt;にして渡してあげればOK。&lt;/p&gt;

&lt;p&gt;注意点は、他の認証（通常のSSL/TLS認証とかBasic認証）時も全て呼び出されるので、その実装を忘れないこと！&lt;/p&gt;

&lt;p&gt;以上を踏まえると、実装はこんな感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func URLSession(session: NSURLSession, didReceiveChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&amp;gt; Void) {
    switch challenge.protectionSpace.authenticationMethod {
    // 通常のhttpsのSSL/TLS認証
    case NSURLAuthenticationMethodServerTrust:
      // デフォルトの動作をさせる
      completionHandler(.PerformDefaultHandling, nil)
    // httpsのクライアント認証
    case NSURLAuthenticationMethodClientCertificate:
      // clientCredential(あらかじめクライアント証明書から生成した認証情報)を
      // 利用して認証をかける
      completionHandler(.UseCredential, clientCredential)
    // その他の認証
    default:
      completionHandler(.PerformDefaultHandling, nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クライアント証明書の読み込み&#34;&gt;クライアント証明書の読み込み&lt;/h3&gt;

&lt;p&gt;クライアントの証明書は&lt;code&gt;p12&lt;/code&gt;形式を利用する。
証明書からは&lt;code&gt;SecPKCS12Import&lt;/code&gt;を使って認証情報を取り出し、&lt;code&gt;NSURLCredential&lt;/code&gt;を生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// アプリにバンドルされているクライアント証明書(apns.p12)
guard let url = NSBundle.mainBundle().
  URLForResource(&amp;quot;apns&amp;quot;, withExtension: &amp;quot;p12&amp;quot;) else { return }
guard let p12data = NSData(contentsOfURL: p12URL) else { return }

let passphrase = &amp;quot;0000&amp;quot;     // 証明書のパスフレーズ
let options = [kSecImportExportPassphrase as String : passphrase]

var items: CFArray?
guard SecPKCS12Import(p12data, options, &amp;amp;items) == errSecSuccess
  else { return }
guard let cfarr = items else { return }
guard let certEntry = (cfarr as Array).first as? [String: AnyObject]
  else { return }

let identity = certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity
let certificates = certEntry[&amp;quot;chain&amp;quot;] as? [AnyObject]
let clientCredential = NSURLCredential(identity: identity,
                                       certificates: certificates,
                                       persistence: .ForSession)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はサンプルなのでクライアント証明書はアプリにバンドルしているが、通常はキーチェーンにいれておくべき。&lt;/p&gt;

&lt;p&gt;なお、クライアント証明書の中身はPush送信用の一つだけが入っている前提。&lt;/p&gt;

&lt;p&gt;小ネタなのが、&lt;code&gt;certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity&lt;/code&gt;という部分。
&lt;code&gt;AnyObject&lt;/code&gt;から&lt;code&gt;SecIdentity&lt;/code&gt;への変換は常に成功するので&lt;code&gt;as?&lt;/code&gt;にはできないみたい。
詳細は&lt;a href=&#34;https://forums.developer.apple.com/thread/11171&#34;&gt;公式フォーラム&lt;/a&gt;を参照。&lt;/p&gt;

&lt;h3 id=&#34;apnsの送信&#34;&gt;APNsの送信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// デバイストークン
let deviceToken = &amp;quot;00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0&amp;quot;
// 通知内容
let payload = &amp;quot;{\&amp;quot;aps\&amp;quot;:{\&amp;quot;alert\&amp;quot;:\&amp;quot;Hello!\&amp;quot;}}&amp;quot;

// 開発環境向けURL
guard let url = NSURL(string: &amp;quot;https://api.development.push.apple.com/3/device/&amp;quot;)
  else { return }
let request = NSMutableURLRequest(URL: url.URLByAppendingPathComponent(deviceToken))
request.HTTPMethod = &amp;quot;POST&amp;quot;
request.HTTPBody = payload.dataUsingEncoding(NSUTF8StringEncoding)

let config = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: config, delegate: self, delegateQueue: nil)
session.dataTaskWithRequest(request).resume()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;送信時のポイントは、デリゲートを指定しておくことと、&lt;code&gt;completionHandler&lt;/code&gt;形式のメソッドを使わないこと。
使ってしまうとデリゲートが呼び出されなくなり、クライアント認証が通らなくなる。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回は本当にネタ。多分使い道はないと思う。。。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;クライアント証明書を上書きして使う必要があるので注意！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/APNs_iOS&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(Node.js)</title>
      <link>https://mike-neko.github.io/blog/http2apns/</link>
      <pubDate>Thu, 11 Aug 2016 17:16:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
サーバサイドは&lt;code&gt;Node.js&lt;/code&gt;を利用。&lt;/p&gt;

&lt;h3 id=&#34;apns-provider-api&#34;&gt;APNs Provider API&lt;/h3&gt;

&lt;p&gt;利用するために必要なのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http2のPOST送信&lt;/li&gt;
&lt;li&gt;クライアント認証用の証明書&lt;/li&gt;
&lt;li&gt;CAルート証明書（必要な場合のみ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。
なお、&lt;code&gt;http2&lt;/code&gt;対応が必要なのは送信のみなので、サーバ自体はhttp2対応にしなくてもOK。&lt;/p&gt;

&lt;p&gt;従来のソケット通信経由でAPNsを送信するのと比較すると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;実装が簡単&lt;/li&gt;
&lt;li&gt;1つのデバイストークン毎に結果が取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というのが大きなメリット。&lt;/p&gt;

&lt;p&gt;特に以前は、環境の異なるトークンを送信すると、いきなりソケットの接続自体が切断される・・・
みたいな挙動があって確実に全件送信させるのは結構大変だったけど、API方式ではそういったのはなさそう。&lt;/p&gt;

&lt;p&gt;パフォーマンス的にどうなのかは不明。&lt;/p&gt;

&lt;h3 id=&#34;送信形式&#34;&gt;送信形式&lt;/h3&gt;

&lt;p&gt;環境毎のAppleのサーバへPOSTリクエストを送ることでPush通知が送信される。&lt;br /&gt;
指定する内容自体は従来のものと同じなので、詳細な内容は公式を参照のこと。&lt;/p&gt;

&lt;h4 id=&#34;アドレス&#34;&gt;アドレス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;開発 : &lt;code&gt;https://api.development.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;商用 : &lt;code&gt;https://api.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ヘッダ&#34;&gt;ヘッダ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apns-topic&lt;/code&gt; : 送信対象のアプリのバンドルID&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-id&lt;/code&gt; : 通知ID。指定しなければAPNs側で自動生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-expiration&lt;/code&gt; : 通知が無効になり破棄できるようになる有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-priority&lt;/code&gt; : 優先度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ボディ&#34;&gt;ボディ&lt;/h4&gt;

&lt;p&gt;JSON形式の通知ペイロード&lt;/p&gt;

&lt;h4 id=&#34;レスポンス&#34;&gt;レスポンス&lt;/h4&gt;

&lt;p&gt;送信の受付に成功した場合はステータスコードが&lt;code&gt;200&lt;/code&gt;で返ってくる。&lt;/p&gt;

&lt;p&gt;失敗した場合は、それ以外のステータスコードと、コードに応じてより詳細なエラー内容がボディで返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;もしかすると、&lt;code&gt;OpenSSL&lt;/code&gt;は最新に上げておいた方がいいかも知れない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;は現時点(6.3.1)では&lt;code&gt;http2&lt;/code&gt;には対応していないので、
&lt;a href=&#34;https://www.npmjs.com/package/http2&#34;&gt;http2&lt;/a&gt;というモジュールをインストールしておく。&lt;/p&gt;

&lt;h3 id=&#34;証明書&#34;&gt;証明書&lt;/h3&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;と同じ。
ただし、今回はMacに直接インストールした&lt;code&gt;Node.js&lt;/code&gt;を使うので、CAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/2f2f9f9130ef1d46872894b115a4b0c3.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;クライアント証明書の指定&#34;&gt;クライアント証明書の指定&lt;/h3&gt;

&lt;p&gt;22,23行目にあるように、クライアント証明書と鍵を読み込んで指定する。
（もちろん各ファイルを同じフォルダ内に置いておくのを忘れないように）&lt;/p&gt;

&lt;p&gt;もし、証明書の秘密鍵のパスフレーズを設定している時は、25行目のように設定が必要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（8/24 追記）&lt;/em&gt;&lt;/strong&gt;
&lt;del&gt;証明書の中が送信対象アプリ単独のもの（他の証明書や鍵を含んでいない）であれば、
&lt;code&gt;apns-topic&lt;/code&gt;は指定しなくても送信可能。&lt;br /&gt;
通常の手順で生成した場合は単独のはずなので、指定は不要。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（11/20 追記）&lt;/em&gt;&lt;/strong&gt;
開発環境では上記の通りだが、本番環境では指定がないとエラーが発生する為、必須の様子&lt;/p&gt;

&lt;h3 id=&#34;通知内容の設定&#34;&gt;通知内容の設定&lt;/h3&gt;

&lt;p&gt;送信形式の項目で述べたように、ヘッダにバンドルIDを設定(10−12,21行目)する。&lt;/p&gt;

&lt;p&gt;デバイストークンは、URLの一部として設定する(20行目)。&lt;/p&gt;

&lt;p&gt;通知ペイロードは、44行目にあるようにボディとして書き出す。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html&#34;&gt;APNs Provider API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/jp/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW1&#34;&gt;日本語ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Node.js 6.3.1&lt;/li&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>