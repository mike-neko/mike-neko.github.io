+++
categories = ["ios"]
tags = ["swift3"]
date = "2016-07-25T22:55:03+09:00"
draft = false
slug = "swift-kvo"
title = "KVOを利用する(Swift)"

+++

`Swift`で`KVO`を利用する方法について。特に`context`を一意の識別子として使いたい場合の方法
<!--more-->

## サンプルコード
{{< gist 5f00c1927b3cede0376c575147956112 >}} 

## ポイント
### `NSObject`を継承する
監視対象も監視するクラスも両方とも`NSObject`のサブクラスであることが必要

監視対象（サンプルでは`Target`）で継承しなかった場合、
```
'NSUnknownKeyException', reason: '[<〜.ViewController 0x〜> addObserver:<〜.ViewController 0x〜> forKeyPath:@"target.valueA" options:3 context:0x〜] was sent to an object that is not KVC-compliant for the "target" property.'
```
といった実行時エラーが発生する

監視する側だとそもそも`addObserver`などが利用できない

### プロパティには`dynamic`をつける
監視対象のプロパティ（`addObserver`で追加するプロパティ）は必ず`dynamic`をつけること

もし、これをつけ忘れると、エラーにはならないが、通知も来ない状態
（＝変更されても`observeValueForKeyPath`が呼ばれない）
という判りにくいバグになってしまう

### アクセスコントロールに注意
プロパティが別クラスのオブジェクト?の場合、`private`にすると
```
'NSUnknownKeyException', reason: '[<〜.ViewController 0x〜> addObserver:<〜.ViewController 0x〜> forKeyPath:@"target.valueA" options:3 context:0x〜] was sent to an object that is not KVC-compliant for the "target" property.'
```
といった実行時エラーが発生する

サンプルだと、`value1`と`value2`は`private`でも問題無いが、`target`は`private`ではエラーになる

> `String`や`Int`ではエラーにならないのは確認したが、具体的な条件は未調査・・・

### 識別子としての`context`の指定
通常の指定方法は参考リンクの通り（`private var myContext = 0`）。
ただ、今回のサンプルでは、キー値の指定とまとめて以下のようにしている

```
private struct KeyContext {
    static var value1 = "value1"
    ...
}
```
というのも、`context`には一意なアドレスを渡すべきなので、`static`によりアドレスを確保している
（通常の指定方法ではグローバル変数にして一意なアドレスを確保）

なお、`private`なのは単に他からアクセスさせないようにしたい（する必要がない）からで、
`struct`の中で宣言しているのは、名前空間のようにしたかったからである。
よって、
```
private var value1 = "value1"
...

class ViewController: UIViewController {
```
と言った書き方でも同じ

### 通知の登録 / 解除
#### 呼び出しタイミング
##### 登録時
サンプルでは`UIViewController`なので、`viewWillAppear`で登録しているが、
通常は`init`での登録が良さげ

##### 解除時
サンプルでは登録が`viewWillAppear`なので、対となる`viewWillDisappear`で解除しているが、
通常は`deinit`での登録が良い

#### 登録方法
```
addObserver(self, forKeyPath: KeyContext.value1, options: .new, context: &KeyContext.value1)
```

`Objective-C`との相違点は、

- `KeyPath`に`self`がいらない
- `options`を複数指定する時は、`|`ではなく配列（例：`[.new, .old]`）で渡す
- `context`へのポインタは`&`だけで良い（暗黙的変換が入る）

といったあたり

### 通知の受信
今回は、`context`を識別子として利用しているので、`switch`でまとめて比較しているが、`defalut`の時にちゃんと
```
super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
```
を呼ぶこと。これがないと、もし親クラスで何か監視をしていた場合に処理が正しく行われないので
（当然、自身の監視対象だった場合は呼ばない）

なお、`case`に監視対象のプロパティを書き忘れると、
```
An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.
```
の実行時エラーとなる

#### 値の取得
```
// Change Dictionary Keys: 
// NSKeyValueChangeKey.newKeyとかNSKeyValueChangeKey.oldKeyとか
let value = change?["Change Dictionary Keys"] as? "データ型"
```
と書けば希望のデータ型へ変換して取得できる。
`NSNull`や型が違う場合などは、最終的に`nil`が入るのでサンプルのように`guard`ではじくのがスマート

#### Swift2からの変更点
`addObserver`の`context`のポインタが`UnsafeMutableRawPointer`に変わっている


# 参考リンク
- 公式：[Using Swift with Cocoa and Objective-C (Swift 3.0.1)](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12)

# 開発環境
+ Xcode 8.2.1
