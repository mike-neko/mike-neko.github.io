<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/post/</link>
    <description>Recent content in Posts on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Sat, 29 Oct 2016 22:40:57 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Guzzle(PHP)でAPNsの同時配信を行う</title>
      <link>https://mike-neko.github.io/blog/guzzle-apns/</link>
      <pubDate>Sat, 29 Oct 2016 22:40:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle-apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;でiOSのAPNs(Push通知)をお手軽に同時配信する方法&lt;/p&gt;

&lt;p&gt;APNs自体については&lt;a href=&#34;../http2apns/&#34;&gt;APNs Provider API(http2)を利用する(Node.js)&lt;/a&gt;を参照&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;自体は&lt;a href=&#34;../guzzle/&#34;&gt;以前の記事&lt;/a&gt;を参照&lt;/p&gt;

&lt;h3 id=&#34;curlの更新&#34;&gt;curlの更新&lt;/h3&gt;

&lt;p&gt;APNsを使うには&lt;code&gt;http2&lt;/code&gt;が必要かつ非同期で実行したいので、&lt;code&gt;curl&lt;/code&gt;をインストールし直す&lt;/p&gt;

&lt;p&gt;&lt;code&gt;homebrew&lt;/code&gt;を使っている場合は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install curl --with-nghttp2 --with-openssl
brew link curl --force
brew reinstall php56 --with-homebrew-curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、自分で試した時は上記だけでは&lt;code&gt;http2&lt;/code&gt;が有効にならなかったので、
アンイストールした方が確実かもしれない&lt;/p&gt;

&lt;p&gt;更新後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;code&gt;http2&lt;/code&gt;が出ていればOK&lt;/p&gt;

&lt;h2 id=&#34;guzzleの使い方&#34;&gt;Guzzleの使い方&lt;/h2&gt;

&lt;h3 id=&#34;http2で通信する&#34;&gt;http2で通信する&lt;/h3&gt;

&lt;p&gt;オプションで指定するだけでOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;version&#39; =&amp;gt; 2.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post送信&#34;&gt;POST送信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;はリクエスト時のオプションとして以下の感じで指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client();
$response = $client-&amp;gt;request(&#39;POST&#39;, $url, [&#39;body&#39; =&amp;gt; $body]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;の中身を&lt;code&gt;JSON&lt;/code&gt;にしたい時は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;body&#39; =&amp;gt; json_encode($json])]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形にして渡す&lt;/p&gt;

&lt;h3 id=&#34;クライアント証明書をつける&#34;&gt;クライアント証明書をつける&lt;/h3&gt;

&lt;p&gt;これもオプションで指定するだけでOK&lt;/p&gt;

&lt;p&gt;例えば同じ階層内に&lt;code&gt;apns_dev.pem&lt;/code&gt;という証明書（パスフレーズ&lt;code&gt;0000&lt;/code&gt;）に置いた場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;cert&#39; =&amp;gt; [&#39;apns_dev.pem&#39;, &#39;0000&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あえていうなら、&lt;code&gt;pem&lt;/code&gt;形式の証明書を作るのがちょっと面倒&lt;/p&gt;

&lt;h2 id=&#34;apnsの同時配信&#34;&gt;APNsの同時配信&lt;/h2&gt;

&lt;p&gt;APNsは通知内容をJSONで指定することと、前回の並列リクエストを併せると、以下のコードで同時配信が実現できる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/dcc15bedbc4d42e4e8b1c31119f3c63a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;（※配信環境はSandBox向け）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Guzzleで非同期の並列リクエストを行う</title>
      <link>https://mike-neko.github.io/blog/guzzle/</link>
      <pubDate>Sat, 29 Oct 2016 16:50:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PHP&lt;/code&gt;のHTTPクライアント(&lt;a href=&#34;http://docs.guzzlephp.org/en/latest/&#34;&gt;Guzzle&lt;/a&gt;)で非同期の並列リクエストを行う方法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;は内部では&lt;code&gt;curl&lt;/code&gt;を使っており、便利な&lt;code&gt;curl&lt;/code&gt;を面倒な設定をせずに使えるというありがたいもの
（なお&lt;code&gt;curl&lt;/code&gt;がなくても動くがその場合は非同期が使えないなど機能が制限されるらしい）&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;動作環境は以下のとおり&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.5.0以上&lt;/li&gt;
&lt;li&gt;curl 7.19.4以上
(要openSSL/zlib)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;composer&lt;/code&gt;で&lt;code&gt;guzzlehttp/guzzle&lt;/code&gt;を入れる&lt;br /&gt;
(&lt;code&gt;guzzle/guzzle&lt;/code&gt;は古いバージョンなので注意)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;composer&lt;/code&gt;を使っているので、使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;vendor/autoload.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を忘れないこと&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;php-iniの設定&#34;&gt;php.iniの設定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;allow_url_fopen = ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を設定しておく&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;複数のURLに並列に非同期にリクエストをかける方法は以下のとおり&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/07e16ffece9ecfbffa4959f875897418.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;まずは、&lt;code&gt;$requests&lt;/code&gt;に実際のリクエストを生成する処理をクロージャとして登録する。&lt;br /&gt;
今回であれば、URLのリストから単純にURLを取り出し、&lt;code&gt;$client-&amp;gt;getAsync($url)&lt;/code&gt;としてリクエストを生成している&lt;br /&gt;
（URLのエンドポイントだけが違うような場合は&lt;code&gt;base_uri&lt;/code&gt;を指定した方がスマート）&lt;/p&gt;

&lt;p&gt;ポイントは&lt;code&gt;yield&lt;/code&gt;でジェネレータを使っていること。&lt;br /&gt;
通常は&lt;code&gt;foreach&lt;/code&gt;をした時点でそのループの回数分中の処理が実行されてメモリなどのリソースを消費するが、
ジェネレータを使うと実際に必要になる（今回であれば&lt;code&gt;Pool&lt;/code&gt;で順次実行される時）まで実行されずリソースを消費しないメリットがある&lt;/p&gt;

&lt;p&gt;リクエストの生成処理ができれば、&lt;code&gt;Pool&lt;/code&gt;オブジェクトに渡して&lt;code&gt;Promise&lt;/code&gt;を生成する。
その際、&lt;code&gt;concurrency&lt;/code&gt;で同時リクエスト数を、&lt;code&gt;fulfilled&lt;/code&gt;で成功時の処理、&lt;code&gt;rejected&lt;/code&gt;で失敗時の処理が行われる。
非同期の場合、リクエストは生成順に実行されるが、当然、処理結果は順不同で返ってくる。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;code&gt;Promise&lt;/code&gt;の&lt;code&gt;wait()&lt;/code&gt;の部分で全ての並列処理が終わるまで待機される。
これを忘れると完了しないまま処理が終わってしまう&lt;/p&gt;

&lt;p&gt;つまり、例えばあるページにアクセスした時にバックグラウンドの非同期でダウンロードを行うといったことはできない。
そういったことをしたい場合は、&lt;code&gt;Laravel&lt;/code&gt;の&lt;a href=&#34;https://readouble.com/laravel/5.1/ja/queues.html&#34;&gt;キュー&lt;/a&gt;なんかがおすすめ&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;debug&#39; =&amp;gt; true]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと細かな通信状況が出力されるので便利&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;http://docs.guzzlephp.org/en/latest/&#34;&gt;Guzzle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ジェネレータ:&lt;a href=&#34;http://php.net/manual/ja/language.generators.overview.php&#34;&gt;PHP公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UIScrollViewのAutoLayoutをStoryboardのみで設定</title>
      <link>https://mike-neko.github.io/blog/scrollview/</link>
      <pubDate>Sun, 23 Oct 2016 22:28:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/scrollview/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Storyboard上だけでUIScrollViewのAutoLayoutを完結させる方法。
中のUIを動的に追加や削除しないのであればコードを書く必要もないし、
&lt;code&gt;UILabel&lt;/code&gt;のようにコンテンツに応じて動的に高さが変わるようなものにも対応可能&lt;/p&gt;

&lt;p&gt;ポイントは&lt;code&gt;ContainerView&lt;/code&gt;を利用してScrollViewを別のViewControllerに持っていくこと&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;サンプルとしてViewControllerの全画面に縦スクロールするScrollViewを配置する例を考える&lt;/p&gt;

&lt;h4 id=&#34;1-viewcontrollerのscrollviewを置きたい場所に-containerview-を置き制約を設定する&#34;&gt;1. ViewControllerのScrollViewを置きたい場所に&lt;code&gt;ContainerView&lt;/code&gt;を置き制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;&lt;code&gt;Layout Guide&lt;/code&gt;に対して制約を設定するとステータスバーなどに合わせて位置が変わる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1で追加した子viewcontrollerをアウトライン上で選択し-viewcontrollerのサイズを-freeform-へ変更する&#34;&gt;2. 1で追加した子ViewControllerをアウトライン上で選択し、ViewControllerのサイズを&lt;code&gt;Freeform&lt;/code&gt;へ変更する&lt;/h4&gt;

&lt;p&gt;変更すると&lt;code&gt;Height&lt;/code&gt;の部分が変更できるようになるので、
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step2.png&#34; /&gt;
&lt;/figure&gt;

ScrollViewの&lt;code&gt;ContentSize&lt;/code&gt;の高さがあらかじめ決まっているのであれば同じに、
そうでないなら余裕を持った数字に変えておく&lt;/p&gt;

&lt;p&gt;&lt;em&gt;サイズを変更しなくても組めるが変更した方がスクロールせずに作業が行えるので楽&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-1で追加した子viewcontrollerのviewにscrollviewを追加し任意の制約を設定する&#34;&gt;3. 1で追加した子ViewControllerのViewにScrollViewを追加し任意の制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して今回も&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;もしスクロールしないヘッダとつけたりしたいなら、この子ViewControllerのViewに対して追加しておくと便利&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-3で追加したscrollviewにviewを追加し制約を設定する&#34;&gt;4. 3で追加したScrollViewにViewを追加し制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）縦スクロールにしたいので制約は以下の通り
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step4.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;縦と横はそれぞれ親(Scrollview)に対して&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;横幅は親(Scrollview)と同じ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ここで追加したViewがいわば&lt;code&gt;ContentView&lt;/code&gt;となる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-4のviewに各パーツを配置していく&#34;&gt;5. 4のviewに各パーツを配置していく&lt;/h4&gt;

&lt;p&gt;この工程は普段通りのAutoLayoutの設定でOK。
&lt;code&gt;UILabel&lt;/code&gt;の高さをコンテンツに応じて変えたいなら高さを設定せずにマージンだけを設定する&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scrollviewの中身の高さが固定でないなら&lt;code&gt;height&lt;/code&gt;は設定しないこと&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考-viewの階層&#34;&gt;参考：Viewの階層&lt;/h3&gt;

&lt;p&gt;子ViewControllerのアウトライン
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/view.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AutoLayout&lt;/code&gt;って使い方のコツを見つけるまでが大変だけど、このサンプルみたいにやり方を見つけてしまうと楽すぎ〜〜&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>NotificationCenter(Swift3)の使い方</title>
      <link>https://mike-neko.github.io/blog/notification/</link>
      <pubDate>Sun, 23 Oct 2016 18:30:34 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/notification/</guid>
      <description>

&lt;p&gt;旧&lt;code&gt;NSNotification&lt;/code&gt;がSwift3でちょっと変更が入ったので使い方と＋αのエクステンションのまとめ&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;h3 id=&#34;通知の送信&#34;&gt;通知の送信&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Change&amp;rdquo;という名前の通知を送信するときは以下の2パターン&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.post(
    Notification(name: Notification.Name(&amp;quot;Change&amp;quot;)))

NotificationCenter.default.post(name: Notification.Name(&amp;quot;Change&amp;quot;),
                                object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通知の受信&#34;&gt;通知の受信&lt;/h3&gt;

&lt;p&gt;上述の通知を受信したい場合は、&lt;/p&gt;

&lt;h4 id=&#34;受信先の登録&#34;&gt;受信先の登録&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    name: Notification.Name(&amp;quot;Change&amp;quot;),
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、登録した場合は解除も忘れずにすること！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考: UIKeyboardWillShowNotificationとかは&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(keyboardWillShow),
    name: .UIKeyboardWillShow,
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに名前が定義されているので省略形で良い&lt;/p&gt;

&lt;h4 id=&#34;受信するメソッド&#34;&gt;受信するメソッド&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func recieveHoge(notification: NSNotification) {
    // ここで処理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アクセス制限は&lt;code&gt;internal&lt;/code&gt;以上が必要（&lt;code&gt;private&lt;/code&gt;/&lt;code&gt;fileprivate&lt;/code&gt;は不可）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;post&lt;/code&gt;時に送った&lt;code&gt;object&lt;/code&gt;を利用したい場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let hoge = notification.object as? Hoge else { return }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というように変換して使う&lt;/p&gt;

&lt;p&gt;また、特に指定をしないとメイン以外のスレッドで呼び出されることがあるので、
UI絡みの部分は&lt;code&gt;DispatchQueue.main.async&lt;/code&gt;を使った方が良い&lt;/p&gt;

&lt;h4 id=&#34;受信の解除&#34;&gt;受信の解除&lt;/h4&gt;

&lt;p&gt;特定の通知のみ解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self,
                                          name: Notification.Name(&amp;quot;Change&amp;quot;),
                                          object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自身が登録している受信を全て解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;エクステンション&#34;&gt;エクステンション&lt;/h2&gt;

&lt;p&gt;今回のSwift3から&lt;code&gt;Notification.Name&lt;/code&gt;の部分で、以前と比べて手間がかかるようになってしまった
（元からOSで用意されているものは逆に楽）&lt;/p&gt;

&lt;p&gt;それとは別に、名前がアプリの他とかぶらないようになるべく一元管理をしたいので、以下のようなエクステンションと&lt;code&gt;enum&lt;/code&gt;を利用する&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5c92a36705ebcc3c49022a534d4df157.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;em&gt;※&lt;code&gt;enum&lt;/code&gt;はガイドライン的には小文字が良いが文字定数を強調したいので大文字になっている&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;特にエクステンションといっても特別なことはしていなくて単に専用の&lt;code&gt;enum&lt;/code&gt;を使えるようにしただけ。&lt;br /&gt;
でも、これを実際に使うと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通知の送信
NotificationCenter.default.post(key: .ChangeStatus)

// 通知の受信先の登録
NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    key: .ChangeStatus)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;って感じですっきりする&lt;/p&gt;

&lt;p&gt;本来は、&lt;code&gt;Notification.Name&lt;/code&gt;をエクステンションして使うのが想定されているようだが、
&lt;code&gt;enum&lt;/code&gt;により一意になることが保証されるのと、リテラルが出てこないので、個人的にはこっちがお気に入り&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>さくらのレンタルサーバでredisを使う</title>
      <link>https://mike-neko.github.io/blog/redis-sakura/</link>
      <pubDate>Sat, 15 Oct 2016 21:53:49 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/redis-sakura/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;さくらのレンタルサーバ（スタンダード）に&lt;a href=&#34;http://redis.io/&#34;&gt;redis&lt;/a&gt;をインストールする方法のメモ&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Laravel&lt;/code&gt;のキューを使うついでに、せっかくなので&lt;code&gt;redis&lt;/code&gt;を使えるようにしてみる。
&lt;code&gt;Laravel&lt;/code&gt;をさくらで使うあたりは&lt;a href=&#34;../laravel-sakura/&#34;&gt;以前の記事&lt;/a&gt;を参照&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;h3 id=&#34;ソースを展開&#34;&gt;ソースを展開&lt;/h3&gt;

&lt;p&gt;SSHでログインして公式の手順通り以下の様にする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% wget http://download.redis.io/releases/redis-3.2.0.tar.gz
% tar xzf redis-3.2.0.tar.gz
% cd redis-3.2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新版(Ver.3.2.4)では、権限絡みで&lt;code&gt;make&lt;/code&gt;に失敗する為、少し古いバージョンを使っているのがポイント&lt;/p&gt;

&lt;h3 id=&#34;インストール先の変更&#34;&gt;インストール先の変更&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;src/Makefile&lt;/code&gt;を開く
（&lt;code&gt;redis-3.2.0&lt;/code&gt;直下にも&lt;code&gt;Makefile&lt;/code&gt;があるので間違わないこと）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PREFIX?=&lt;/code&gt;という行を以下の様に書き換えて保存する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PREFIX?=/home/アカウント名
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make&#34;&gt;make&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;% gmake
% gmake install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さくらのサーバはBSD系なので&lt;code&gt;gmake&lt;/code&gt;を使ってインストールを実行。
これで、&lt;code&gt;~/bin&lt;/code&gt;に&lt;code&gt;redis&lt;/code&gt;関連がインストールされる&lt;/p&gt;

&lt;p&gt;もし、&lt;code&gt;~/bin&lt;/code&gt;にパスが通っていなければ通しておくと便利&lt;/p&gt;

&lt;h3 id=&#34;実行&#34;&gt;実行&lt;/h3&gt;

&lt;p&gt;一旦、SSHをログアウトしてログインしなおしてから&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% nohup redis-server &amp;lt; /dev/null &amp;gt;&amp;amp; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として、&lt;code&gt;redis&lt;/code&gt;サーバをバックグラウンド起動する&lt;/p&gt;

&lt;p&gt;確認のため、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% redis-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というようになればOK。失敗している時は&lt;code&gt;not connected&amp;gt;&lt;/code&gt;となる&lt;/p&gt;

&lt;p&gt;&lt;em&gt;この時に表示されているサーバのIPとポート番号を覚えておくこと&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;確認が終了すれば、&lt;code&gt;exit&lt;/code&gt;で抜ける（&lt;code&gt;shatdown&lt;/code&gt;にするとサーバまで止まるのでNG）&lt;/p&gt;

&lt;h2 id=&#34;laravelで使う&#34;&gt;Laravelで使う&lt;/h2&gt;

&lt;h3 id=&#34;パッケージの準備&#34;&gt;パッケージの準備&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Laravel&lt;/code&gt;で&lt;code&gt;redis&lt;/code&gt;を使うには&lt;code&gt;predis/predis&lt;/code&gt;が必要なので、&lt;code&gt;Composer&lt;/code&gt;でインストールしておく&lt;/p&gt;

&lt;h3 id=&#34;設定&#34;&gt;設定&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;config/database.php&lt;/code&gt;の中の&lt;code&gt;redis&lt;/code&gt;を設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;redis&#39; =&amp;gt; [

  &#39;cluster&#39; =&amp;gt; false,

  &#39;default&#39; =&amp;gt; [
    &#39;host&#39;     =&amp;gt; &#39;127.0.0.1&#39;,      // redis-cliで確認したIP
    &#39;port&#39;     =&amp;gt; 6379,             // redis-cliで確認したポート
    &#39;database&#39; =&amp;gt; 0,
  ],
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;なお&lt;code&gt;.env&lt;/code&gt;を使う場合、&lt;code&gt;database&lt;/code&gt;の部分は&lt;code&gt;intval(env(&#39;REDIS_DATABASE&#39;, 0))&lt;/code&gt;というように明示的にintにしないとエラーになるので注意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上で、&lt;code&gt;Laravel&lt;/code&gt;からも&lt;code&gt;redis&lt;/code&gt;が使える様になる&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Laravel 5.1&lt;/li&gt;
&lt;li&gt;さくらのレンタルサーバ（スタンダード）

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;redis 3.2.0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>さくらのレンタルサーバでeasy_installを使う</title>
      <link>https://mike-neko.github.io/blog/easyinstall-sakura/</link>
      <pubDate>Sat, 15 Oct 2016 02:03:14 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/easyinstall-sakura/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;さくらのレンタルサーバ（スタンダード）でいつのまにか
&lt;a href=&#34;http://setuptools.readthedocs.io/en/latest/easy_install.html&#34;&gt;easy_install&lt;/a&gt;
が使えるようになっていたので使い方のメモ&lt;/p&gt;

&lt;p&gt;レンタルサーバなので、当然そのまま実行すると&lt;code&gt;[Errno 13] Permission denied&lt;/code&gt;で怒られるのでその対策&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;インストール先の変更&#34;&gt;インストール先の変更&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;(無ければ)&lt;code&gt;~/.pydistutils.cfg&lt;/code&gt;を作成&lt;/li&gt;
&lt;li&gt;ファイルの中に以下を追記&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;[install]
user=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;パスの追加&#34;&gt;パスの追加&lt;/h3&gt;

&lt;p&gt;ついでにパスを通しておく。
&lt;code&gt;csh&lt;/code&gt;の場合は、&lt;code&gt;~/.cshrc&lt;/code&gt;の中の&lt;code&gt;set path&lt;/code&gt;の行に&lt;code&gt;$HOME/.local/bin&lt;/code&gt;を追加する&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;インストール時はそのまま実行すればOK。&lt;/p&gt;

&lt;p&gt;例えば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% easy_install pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば、&lt;code&gt;~/.local/bin&lt;/code&gt;に&lt;code&gt;pip&lt;/code&gt;がインストールされる。&lt;/p&gt;

&lt;p&gt;実行したい時は、パスが通っているので&lt;code&gt;pip&lt;/code&gt;とだけで実行できる。&lt;/p&gt;

&lt;p&gt;なお、インストールしたのに、&lt;code&gt;Command not found.&lt;/code&gt;と出る場合は、
SSHにログインしなおすと良い&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PhpStormからさくらのレンタルサーバを使う</title>
      <link>https://mike-neko.github.io/blog/phpstorm-sakura/</link>
      <pubDate>Mon, 10 Oct 2016 02:03:14 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/phpstorm-sakura/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;さくらのレンタルサーバ（スタンダード）をPhpStormから使うにあたっての便利な小ネタ&lt;/p&gt;

&lt;h2 id=&#34;さくらのdbに接続する&#34;&gt;さくらのDBに接続する&lt;/h2&gt;

&lt;h3 id=&#34;設定情報&#34;&gt;設定情報&lt;/h3&gt;

&lt;p&gt;接続したいさくらのDBは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DBサーバ:mysql***.db.sakura.ne.jp&lt;/li&gt;
&lt;li&gt;データベース名:アカウント名_testdb&lt;/li&gt;
&lt;li&gt;ユーザ名:アカウント名&lt;/li&gt;
&lt;li&gt;パスワード:pass&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とし、事前に作成済みとする。&lt;/p&gt;

&lt;h3 id=&#34;phpstormでの設定&#34;&gt;PhpStormでの設定&lt;/h3&gt;

&lt;p&gt;1. &lt;code&gt;PhpStorm&lt;/code&gt;で適当なプロジェクトを作って起動&lt;br /&gt;
2. メニューの&lt;code&gt;View&lt;/code&gt; - &lt;code&gt;Tool Windows&lt;/code&gt; - &lt;code&gt;Database&lt;/code&gt;を選択&lt;br /&gt;
3. ツールウィンドウの左上の&lt;code&gt;+&lt;/code&gt; - &lt;code&gt;Data Source&lt;/code&gt; - &lt;code&gt;MySQL&lt;/code&gt;を選択&lt;br /&gt;
4. &lt;code&gt;SSH/SSL&lt;/code&gt;のタブを選択&lt;br /&gt;
5. &lt;code&gt;Use SSH tunnel&lt;/code&gt;にチェック&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;設定値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Proxy host&lt;/td&gt;
&lt;td&gt;アカウント名.sakura.ne.jp&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Proxy user&lt;/td&gt;
&lt;td&gt;アカウント名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Auth type&lt;/td&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Proxy password&lt;/td&gt;
&lt;td&gt;サーバのパスワード&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;6. &lt;code&gt;Test Connection&lt;/code&gt;を押して&lt;code&gt;Error&lt;/code&gt;と出なければ接続OK&lt;br /&gt;
7. &lt;code&gt;General&lt;/code&gt;のタブを選択&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;設定値&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;mysql***.db.sakura.ne.jp&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;3306&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Database&lt;/td&gt;
&lt;td&gt;アカウント名_testdb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;アカウント名&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;pass&lt;/td&gt;
&lt;td&gt;DBのパスワード&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;8. &lt;code&gt;Test Connection&lt;/code&gt;を押して&lt;code&gt;Successful&lt;/code&gt;と出れば接続OK&lt;br /&gt;
9. &lt;code&gt;Options&lt;/code&gt;タブを選択&lt;br /&gt;
10. &lt;code&gt;Resolve ...&lt;/code&gt;の欄でDB名にチェックを入れる&lt;br /&gt;
11. &lt;code&gt;OK&lt;/code&gt;で閉じるとツールウィンドウ内にDBが表示される&lt;/p&gt;

&lt;h2 id=&#34;サーバの中を見る-ftp&#34;&gt;サーバの中を見る（FTP）&lt;/h2&gt;

&lt;p&gt;PhpStorm内蔵のFTPの設定方法。
ファイルのアップロードには制約があるが、代わりにローカルファイルとの差分を表示や同期ができるなど結構便利。&lt;/p&gt;

&lt;p&gt;1. &lt;code&gt;PhpStorm&lt;/code&gt;で適当なプロジェクトを作って起動&lt;br /&gt;
2. メニューの&lt;code&gt;View&lt;/code&gt; - &lt;code&gt;Tool Windows&lt;/code&gt; - &lt;code&gt;Remote Host&lt;/code&gt;を選択&lt;br /&gt;
3. ツールウィンドウの&lt;code&gt;...&lt;/code&gt;を選択&lt;br /&gt;
4. &lt;code&gt;Name&lt;/code&gt;に適当な名前をつける&lt;br /&gt;
5. &lt;code&gt;Type&lt;/code&gt;で&lt;code&gt;SFTP&lt;/code&gt;を選択&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;設定値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SFTP host&lt;/td&gt;
&lt;td&gt;アカウント名.sakura.ne.jp&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Root path&lt;/td&gt;
&lt;td&gt;/home/アカウント名/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;User name&lt;/td&gt;
&lt;td&gt;アカウント名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Auth type&lt;/td&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;サーバのパスワード&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;6. &lt;code&gt;Test SFTP connection&lt;/code&gt;を押して&lt;code&gt;Successful&lt;/code&gt;と出れば接続OK&lt;/p&gt;

&lt;p&gt;ここまで設定すればサーバ内のファイルの閲覧や削除などが行える。
さらに、アップロードやローカルファイルとの比較などがしたい場合は、ローカルとの紐付けが必要。&lt;/p&gt;

&lt;p&gt;7. &lt;code&gt;Mappings&lt;/code&gt;のタブを選択&lt;br /&gt;
8. &lt;code&gt;Loacal path&lt;/code&gt;に既存プロジェクトのパスが入っていることを確認&lt;br /&gt;
9. &lt;code&gt;Deployment path on server 〜&lt;/code&gt;に対応するサーバのパスを選択&lt;/p&gt;

&lt;p&gt;これでツールウィンドウの中にサーバ上のファイルが表示され、右クリックでいろいろできるようになる。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PhpStorm 2016.2&lt;/li&gt;
&lt;li&gt;さくらのレンタルサーバ（スタンダード）

&lt;ul&gt;
&lt;li&gt;MySQL 5.5&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Laravelをさくらのレンタルサーバへデプロイ</title>
      <link>https://mike-neko.github.io/blog/laravel-sakura/</link>
      <pubDate>Thu, 06 Oct 2016 00:27:56 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/laravel-sakura/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;ローカルで開発した&lt;code&gt;Laravel5&lt;/code&gt;のプロジェクトをさくらのレンタルサーバ（スタンダード）で公開する時のメモ&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12.0&lt;/li&gt;
&lt;li&gt;Laravel 5.1&lt;/li&gt;
&lt;li&gt;さくらのレンタルサーバ（スタンダード）

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;MySQL 5.5&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみにローカルでは&lt;code&gt;PhpStorm&lt;/code&gt;で開発している&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;www.アカウント名.sakura.ne.jp/hoge&lt;/code&gt;とアクセスすると表示させる前提の手順&lt;br /&gt;
（アカウント名は○○○○.sakura.ne.jpの○○○○部分）&lt;/p&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Gitの&lt;code&gt;export&lt;/code&gt;でアップするファイルを準備&lt;/li&gt;
&lt;li&gt;FTPで1をアップロード&lt;/li&gt;
&lt;li&gt;&lt;code&gt;composer&lt;/code&gt;をインストール&lt;/li&gt;
&lt;li&gt;プロジェクトの設定&lt;/li&gt;
&lt;li&gt;公開&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回はGitのリモートサーバは外部に公開していない為、1〜2の手順が必要。
GitHubとかで管理しているならcloneしてくればOK&lt;/p&gt;

&lt;h3 id=&#34;ファイルの準備&#34;&gt;ファイルの準備&lt;/h3&gt;

&lt;h4 id=&#34;任意-除外ファイルの設定&#34;&gt;（任意）除外ファイルの設定&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;※普段はGit管理しているがサーバへアップしたくないファイルがある場合のみ&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;PhpStorm&lt;/code&gt;のプロジェクトファイルをアップロード対象外としたい
=エクスポートさせたくないので、&lt;code&gt;.gitattributes&lt;/code&gt;に設定を追加する&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;プロジェクトのルートフォルダの&lt;code&gt;.gitattributes&lt;/code&gt;を開く&lt;br /&gt;
（無い場合は作成）&lt;/li&gt;
&lt;li&gt;除外対象を&lt;code&gt;.idea/ export-ignore&lt;/code&gt;として追記する&lt;br /&gt;
（.ideaフォルダ以下をエクスポート時に除外する設定）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;エクスポート&#34;&gt;エクスポート&lt;/h4&gt;

&lt;p&gt;ターミナルでエクスポートする。エクスポート先はプロジェクトのフォルダと同じ階層にしている&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd （プロジェクトのルート）
mkdir ../export
git archive master --worktree-attributes | tar -x -C ../export
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（回線によってはここで圧縮しておき、サーバ上で展開した方が良いかも）&lt;/p&gt;

&lt;h3 id=&#34;サーバへアップロード&#34;&gt;サーバへアップロード&lt;/h3&gt;

&lt;p&gt;FTPソフトで一つ前の手順でエクスポートしたフォルダの中身を丸ごとアップロードする&lt;br /&gt;
アップロード先は&lt;code&gt;/home/アカウント名/laravel&lt;/code&gt;とする&lt;br /&gt;
&lt;em&gt;&lt;code&gt;www&lt;/code&gt;以下にはアップロードしないこと！&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;composerをインストール&#34;&gt;composerをインストール&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SSHでログインする&lt;br /&gt;
ターミナルで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh アカウント名@アカウント名.sakura.ne.jp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鍵認証をしていなければ、パスワードを聞かれるので入力する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;bin&lt;/code&gt;ディレクトリを作成し、そこへ&lt;code&gt;composer&lt;/code&gt;をインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% mkdir bin
% curl -sS https://getcomposer.org/installer | php -- --install-dir=bin --filename=composer
% chmod 755 bin/composer
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一旦ログアウトしてログインする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% exit
ssh アカウント名@アカウント名.sakura.ne.jp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Laravel&lt;/code&gt;プロジェクトにパッケージをインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% cd laravel
% composer install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;プロジェクトの設定&#34;&gt;プロジェクトの設定&lt;/h3&gt;

&lt;h4 id=&#34;dbの準備&#34;&gt;DBの準備&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;サーバのコントロールパネルへログイン&lt;/li&gt;
&lt;li&gt;&lt;code&gt;データベースの設定&lt;/code&gt;を開き、DBサーバとユーザ名を確認&lt;/li&gt;
&lt;li&gt;&lt;code&gt;データベースの新規作成&lt;/code&gt;からプロジェクト用のデータベースを作成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;laravelへ設定&#34;&gt;Laravelへ設定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.env&lt;/code&gt;ファイルを設定する&lt;br /&gt;
&lt;code&gt;DB_〜&lt;/code&gt;の各項目はコントロールパネルで確認・設定したものを記述しておく&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/7ae29213feac486174f86ebe8e8c534c.js&#34;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.env&lt;/code&gt;ファイルの&lt;code&gt;APP_KEY&lt;/code&gt;を生成&lt;br /&gt;
（ターミナルの状態は前回の続き）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% php artisan key:generate  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DBのマイグレーションを実施&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% php artisan migrate  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;公開&#34;&gt;公開&lt;/h3&gt;

&lt;h4 id=&#34;公開用フォルダの設定&#34;&gt;公開用フォルダの設定&lt;/h4&gt;

&lt;p&gt;さくらのレンタルサーバは&lt;code&gt;DocumentRoot&lt;/code&gt;を変更できないので、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% ln -s ~/laravel/public ~/www/hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;code&gt;Laravel&lt;/code&gt;の&lt;code&gt;public&lt;/code&gt;へのシンボリックリンクを&lt;code&gt;www&lt;/code&gt;の中へ置く&lt;/p&gt;

&lt;p&gt;これで&lt;code&gt;www.アカウント名.sakura.ne.jp/hoge&lt;/code&gt;へのアクセスで、
プロジェクトの公開用フォルダ&lt;code&gt;public&lt;/code&gt;へアクセスできるようになる。&lt;br /&gt;
（ただしまだこの段階ではエラー）&lt;/p&gt;

&lt;h4 id=&#34;htaccessの編集&#34;&gt;.htaccessの編集&lt;/h4&gt;

&lt;p&gt;さくらのレンタルサーバは&lt;code&gt;.htaccess&lt;/code&gt;で&lt;code&gt;Options&lt;/code&gt;を使えないので、
&lt;code&gt;laravel/public&lt;/code&gt;の中の&lt;code&gt;.htaccess&lt;/code&gt;を開き、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IfModule mod_negotiation.c&amp;gt;
  Options -MultiViews
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の部分を削除する。&lt;br /&gt;
これで無事公開が完了！&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;サーバ上のファイル構成は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/アカウント名
  ├─ laravel
  |    ├─ .env
  |    ├─ public
  |    |  ├─ .htaccess
  |    |  └─ ...
  |    └─ ...
  ├─ www
  |    ├─ hoge          # シンボリックリンク
  |    └─ ...
  └─ ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://c-rtx.com/2015/09/22/laravel-on-sakura-rental-server/&#34;&gt;Laravel5をさくらのレンタルサーバで動かす&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker(Kitematic)&#43;PHPStormでMySQL環境をお手軽構築</title>
      <link>https://mike-neko.github.io/blog/docker-db/</link>
      <pubDate>Thu, 29 Sep 2016 01:44:58 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/docker-db/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;個人的には&lt;code&gt;MariaDB&lt;/code&gt;を使っているが、レンタルサーバや既存開発のものだと
まだまだ&lt;code&gt;MySQL&lt;/code&gt;の環境が必要なこともしばしば。。。&lt;/p&gt;

&lt;p&gt;かといって、そんなに使わない環境をわざわざローカルに構築するのも面倒なので、
さっくりとお手軽に速攻で構築してしまおうという時のメモ。&lt;/p&gt;

&lt;p&gt;ちなみに、お手軽なのでターミナルでコマンドを叩くことすらしない。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Docker&lt;/code&gt;と&lt;code&gt;Kitematic&lt;/code&gt;をインストールしておく&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PhpStorm&lt;/code&gt;をインストールしておく&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&#34;../docker/&#34;&gt;Docker構築メモ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;※&lt;code&gt;PhpStorm&lt;/code&gt;は接続確認や&lt;code&gt;phpMyAdmin&lt;/code&gt;の代わりに使うので、なくてもDB構築には支障ない&lt;/p&gt;

&lt;h3 id=&#34;mysqlの構築&#34;&gt;MySQLの構築&lt;/h3&gt;

&lt;h4 id=&#34;コンテナの生成&#34;&gt;コンテナの生成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Kitematic&lt;/code&gt;を起動する&lt;/li&gt;
&lt;li&gt;検索窓(&lt;code&gt;Serach for Docker ...&lt;/code&gt;とあるところ)にmysqlで検索し、
作者が&lt;code&gt;official&lt;/code&gt;になっている&lt;code&gt;mysql&lt;/code&gt;のイメージを見つける&lt;/li&gt;
&lt;li&gt;&lt;em&gt;（バージョンを指定したい時のみ）&lt;/em&gt;&lt;br /&gt;
CREATEボタンの左にある&lt;code&gt;・・・&lt;/code&gt; - &lt;code&gt;SELECTED TAG&lt;/code&gt;から任意のバージョンを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CREATE&lt;/code&gt;を実行してしばらく待つとコンテナが生成される&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;※この段階ではパスワードなど必要な設定がまだの為、エラーで起動しない&lt;/p&gt;

&lt;h4 id=&#34;mysqlの設定&#34;&gt;MySQLの設定&lt;/h4&gt;

&lt;p&gt;DBの設定は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rootパスワード:&lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;データベース名:testdb&lt;/li&gt;
&lt;li&gt;ユーザ名:user&lt;/li&gt;
&lt;li&gt;パスワード:pass&lt;/li&gt;
&lt;li&gt;ポート:32768&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という前提のため適宜読み替えること&lt;/p&gt;

&lt;p&gt;1. &lt;code&gt;Settings&lt;/code&gt;のタブを選択&lt;br /&gt;
2. &lt;code&gt;Environment Variables&lt;/code&gt;に以下のように設定値を追加&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;KEY&lt;/th&gt;
&lt;th&gt;VALUE&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MYSQL_ROOT_PASSWORD&lt;/td&gt;
&lt;td&gt;root&lt;/td&gt;
&lt;td&gt;rootパスワード&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MYSQL_DATABASE&lt;/td&gt;
&lt;td&gt;testdb&lt;/td&gt;
&lt;td&gt;データベース名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MYSQL_USER&lt;/td&gt;
&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;ユーザ名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MYSQL_PASSWORD&lt;/td&gt;
&lt;td&gt;pass&lt;/td&gt;
&lt;td&gt;パスワード&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3. &lt;code&gt;SAVE&lt;/code&gt;を押す（&lt;strong&gt;忘れないこと&lt;/strong&gt;）&lt;br /&gt;
4. &lt;code&gt;Ports&lt;/code&gt;のタブを選択&lt;br /&gt;
5. &lt;code&gt;MAC IP:PORT&lt;/code&gt;の項目の下に&lt;code&gt;Docker&lt;/code&gt;のIPアドレスが表示されているので、
&lt;code&gt;:&lt;/code&gt;の後ろにポート番号を入れる&lt;br /&gt;
6. &lt;code&gt;SAVE&lt;/code&gt;を押す（&lt;strong&gt;忘れないこと&lt;/strong&gt;）&lt;br /&gt;
7. 再起動がかかるはずなので、&lt;code&gt;Home&lt;/code&gt;のタブを選択&lt;br /&gt;
8. ログに&lt;code&gt;mysqld: ready for connections.&lt;/code&gt;と出ていればOK&lt;br /&gt;
9. 右側の&lt;code&gt;ACCESS URL&lt;/code&gt;のIPアドレスを確認しておく&lt;/p&gt;

&lt;p&gt;※ポートの指定をしない場合は、適当なポートが割り振られ、
起動毎にポートが変わる可能性があるので指定しておくこと&lt;/p&gt;

&lt;h3 id=&#34;接続確認&#34;&gt;接続確認&lt;/h3&gt;

&lt;p&gt;1. &lt;code&gt;PhpStorm&lt;/code&gt;で適当なプロジェクトを作って起動&lt;br /&gt;
2. メニューの&lt;code&gt;View&lt;/code&gt; - &lt;code&gt;Tool Windows&lt;/code&gt; - &lt;code&gt;Database&lt;/code&gt;を選択&lt;br /&gt;
3. ツールウィンドウの左上の&lt;code&gt;+&lt;/code&gt; - &lt;code&gt;Data Source&lt;/code&gt; - &lt;code&gt;MySQL&lt;/code&gt;を選択&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;設定値&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;192.168.99.100&lt;/td&gt;
&lt;td&gt;前項9で確認したIPアドレス&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;32768&lt;/td&gt;
&lt;td&gt;前項5で指定したポート&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Database&lt;/td&gt;
&lt;td&gt;testdb&lt;/td&gt;
&lt;td&gt;データベース名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;ユーザ名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Password&lt;/td&gt;
&lt;td&gt;pass&lt;/td&gt;
&lt;td&gt;パスワード&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;4. &lt;code&gt;Test Connection&lt;/code&gt;を押して&lt;code&gt;Successful&lt;/code&gt;と出れば接続OK&lt;br /&gt;
5. &lt;code&gt;Options&lt;/code&gt;タブを選択&lt;br /&gt;
6. &lt;code&gt;Resolve ...&lt;/code&gt;の欄でDB名にチェックを入れる&lt;br /&gt;
7. &lt;code&gt;OK&lt;/code&gt;で閉じるとツールウィンドウ内にDBが表示される&lt;/p&gt;

&lt;p&gt;あとはPhpStormのGUIでDB内のデータを表示や操作させたり、SQLを実行したり自由にできる&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;頻繁に使うものならともかく、使い捨てやまれなものは、やっぱりGUIで操作できると助かる&lt;/p&gt;

&lt;p&gt;特に今回は&lt;code&gt;PhpStorm&lt;/code&gt;を使って、実際の開発環境でDBの確認や操作が楽にするのがポイント&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PhpStorm&lt;/code&gt;はアップデートも早いし機能も豊富で素晴らしいツール！
ただ、もうちょっと日本語の資料が多いとありがたい（他力本願）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12.0&lt;/li&gt;
&lt;li&gt;PhpStorm 2016.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ATS有効の状態でオレオレ証明書を使って通信する(iOS9)</title>
      <link>https://mike-neko.github.io/blog/ios-cert/</link>
      <pubDate>Tue, 06 Sep 2016 00:35:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/ios-cert/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ATS&lt;/code&gt;が有効の場合、SSL/TLS通信でないと通信自体ができない。&lt;/p&gt;

&lt;p&gt;が、開発時はローカル環境だったりドメイン自体がなかったりで正式なSSL証明書を使えないことが多い・・・
かといって、ATSをOFFにして開発するのも・・・&lt;/p&gt;

&lt;p&gt;って時に自己署名証明書（オレオレ証明書）を使ってしのぐ方法。&lt;/p&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;オレオレ証明書を作ってサーバへ設定&lt;/li&gt;
&lt;li&gt;iOS端末へオレオレ証明書をインストール&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;br /&gt;
ポイントはオレオレ証明書のインストール部分で、その手順をメモしておく。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;証明書の作成のあたりは&lt;a href=&#34;../docker/&#34;&gt;Docker構築メモ&lt;/a&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;注意&#34;&gt;！注意！&lt;/h2&gt;

&lt;p&gt;検証はiOS9でのみ。iOS10は未検証。
（ローカル環境でのATSの挙動が変わりそう！？）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;は&lt;code&gt;2.2&lt;/code&gt;の操作方法。&lt;/p&gt;

&lt;p&gt;また、&lt;strong&gt;セキュリティ面で危険&lt;/strong&gt;なのでくれぐれもオレオレ証明書の容量・用法には気をつけること&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;前提：サーバへのオレオレ証明書は設定済みの状態&lt;/p&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;オレオレ証明書&lt;code&gt;server.crt&lt;/code&gt;を作成しておく&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator2&lt;/code&gt;をインストールしておく&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;構成プロファイルの作成&#34;&gt;構成プロファイルの作成&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;のメニューの&lt;code&gt;ファイル&lt;/code&gt;から&lt;code&gt;新規プロファイル&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側の&lt;code&gt;証明書&lt;/code&gt;の項目を選択し&lt;code&gt;構成&lt;/code&gt;ボタンを押下&lt;/li&gt;
&lt;li&gt;ファイル選択画面でオレオレ証明書(&lt;code&gt;server.crt&lt;/code&gt;)を選択して開く&lt;/li&gt;
&lt;li&gt;メニューの&lt;code&gt;ファイル&lt;/code&gt;から&lt;code&gt;保存&lt;/code&gt;を選択し、適当な名前をつけて保存&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;端末へインストール&#34;&gt;端末へインストール&lt;/h3&gt;

&lt;p&gt;以下のどちらかの方法でインストールする&lt;/p&gt;

&lt;h4 id=&#34;apple-configurator経由&#34;&gt;Apple Configurator経由&lt;/h4&gt;

&lt;p&gt;Macと端末の有線接続が必要&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Apple Configurator&lt;/code&gt;に接続中の端末が表示されるので選択&lt;/li&gt;
&lt;li&gt;ツールバーの&lt;code&gt;追加&lt;/code&gt;ボタンから&lt;code&gt;プロファイル&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;作成した構成プロファイルを選択&lt;/li&gt;
&lt;li&gt;iOS端末の画面がインストール画面に変わるので、&lt;code&gt;インストール&lt;/code&gt;x3&lt;br /&gt;
（プロファイルのインストールはConfiguratorから操作不可）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ネットワーク経由&#34;&gt;ネットワーク経由&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;適当なサーバに構成プロファイルを置いてダウンロードできるようにする&lt;/li&gt;
&lt;li&gt;iOS端末のSafariから該当のURLへアクセス&lt;/li&gt;
&lt;li&gt;インストール画面になるので&lt;code&gt;インストール&lt;/code&gt;x3&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、証明書だけをインストールしてもアプリからは接続できないので、
&lt;code&gt;構成プロファイル&lt;/code&gt;を作ってからインストールするのが大事！&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Appleのテクニカルノート：&lt;a href=&#34;https://developer.apple.com/library/ios/technotes/tn2326/_index.html&#34;&gt;TLSのテスト用証明書の作成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.4&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>jazzyの使い方 その1</title>
      <link>https://mike-neko.github.io/blog/jazzy-cmd/</link>
      <pubDate>Sat, 03 Sep 2016 00:12:14 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/jazzy-cmd/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Swiftのドキュメント生成ツールの&lt;a href=&#34;https://github.com/realm/jazzy&#34;&gt;jazzy&lt;/a&gt;の使い方。
その1はコマンド周りのメモ。&lt;/p&gt;

&lt;h2 id=&#34;ドキュメント生成時のコマンド&#34;&gt;ドキュメント生成時のコマンド&lt;/h2&gt;

&lt;p&gt;主に自分個人で使う時のコマンドは以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jazzy -o Documents --min-acl internal --skip-undocumented -a M.Ike -x SYMROOT=/private/tmp/jazzy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;o-documents&#34;&gt;&amp;rdquo;-o Documents&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-o [フォルダ]&lt;/code&gt;でドキュメントを出力するフォルダを指定する。&lt;br /&gt;
なお、フォルダが存在しない場合は自動で作成される。&lt;/p&gt;

&lt;p&gt;今回の指定だと以下の場所にフォルダが生成される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample                 # 対象のプロジェクトのフォルダ
  ├─ Sample            # Xcodeのソースなど一式
  ├─ Sample.xcodeproj  # Xcodeのプロジェクトファイル
  └─ Documents         # この中に生成されたドキュメント一式が入る
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;min-acl-internal&#34;&gt;&amp;rdquo;&amp;ndash;min-acl internal&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;--min-acl [private | internal | public]&lt;/code&gt;で出力の対象を指定する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Swift2.x&lt;/code&gt;では&lt;code&gt;public&lt;/code&gt;は使わずに、明示的な&lt;code&gt;private&lt;/code&gt;か暗黙的な&lt;code&gt;internal&lt;/code&gt;しか使わない
（※複数のモジュールを利用しない場合）
ので、&lt;code&gt;internal&lt;/code&gt;以上で設定している。&lt;/p&gt;

&lt;h3 id=&#34;skip-undocumented&#34;&gt;&amp;rdquo;&amp;ndash;skip-undocumented&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;この設定をすると、ドキュメントコメントのないソースからはドキュメントを生成しなくなる。&lt;/p&gt;

&lt;p&gt;さらに&lt;code&gt;documentation-coverage&lt;/code&gt;の対象からも除外される。&lt;/p&gt;

&lt;h3 id=&#34;a&#34;&gt;&amp;rdquo;-a&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;作者名の指定。
別に個人用なので必要もないが、ないと見栄えが悪いのでつけている。&lt;/p&gt;

&lt;h3 id=&#34;x-symroot-private-tmp-jazzy&#34;&gt;&amp;rdquo;-x SYMROOT=/private/tmp/jazzy&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-x arg1,arg2,…argN,&lt;/code&gt;で&lt;code&gt;xcodebuild&lt;/code&gt;時のビルドオプションを指定できる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jazzy&lt;/code&gt;を使うと&lt;code&gt;build&lt;/code&gt;というビルドの一時ファイルの入ったディレクトリが
プロジェクトのフォルダ内に生成されてしまう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;でちゃんと指定しているので実害はないが、一時ファイルが生成されるのは気持ち悪い。。。&lt;/p&gt;

&lt;p&gt;という訳で、これを指定すれば&lt;code&gt;jazzy&lt;/code&gt;利用時の一時ファイルを
&lt;code&gt;/private/tmp/jazzy&lt;/code&gt;(テンポラリフォルダ)へ出力させることができ、
同じフォルダ内に&lt;code&gt;build&lt;/code&gt;フォルダが生成されなくなる。
（テンポラリフォルダは再起動時に消去される）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ただしXcodeのプロジェクトの設定によっては、別の環境変数を書き換える必要あり&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;使っていないもの&#34;&gt;使っていないもの&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-c&lt;/code&gt;をつけると、ドキュメント作成前に元のデータを全部消してくれるので、
本来はつけておいた方が良いオプション。&lt;/p&gt;

&lt;p&gt;が、ヘルプにもあるように、指定した出力先のフォルダが&lt;strong&gt;問答無用で削除&lt;/strong&gt;されてしまう。。。&lt;br /&gt;
開発中はターミナルから手打ち（コピペ）して使うことが多いので、
間違って指定してしまった！という悲劇を防ぐ為、これは指定していない&lt;/p&gt;

&lt;p&gt;（確実に作りたい時は手動で削除で対応。
ビルド用のシェルスクリプトを組んでいる場合はつけている）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.6&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;jazzy 0.7.0&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/http2apns-ios/</link>
      <pubDate>Thu, 25 Aug 2016 23:00:38 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns-ios/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
しかもiOS端末からPush通知を送信する方法。&lt;/p&gt;

&lt;p&gt;前回の&lt;a href=&#34;../http2apns/&#34;&gt;Node.jsからAPNsを使う方法&lt;/a&gt;の派生ネタ。
&lt;code&gt;APNs Provider API&lt;/code&gt;はhttp2とクライアント証明書に対応さえしていればPushを送れるので、
それならiOS端末からでも良けるよね？って試してみた。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;iOSならiOS9から&lt;code&gt;http2&lt;/code&gt;に対応しているので、証明書の準備のみ必要。&lt;/p&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;の手順で&lt;code&gt;apns.p12&lt;/code&gt;を書き出せばOK。
&lt;code&gt;.pem&lt;/code&gt;の作成やCAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;ポイントは&lt;code&gt;https&lt;/code&gt;のクライアント認証を実装すること。
それができれば後はPOST形式でAPIを呼び出すだけなので簡単（APIについては&lt;a href=&#34;../http2apns/&#34;&gt;前回記事&lt;/a&gt;参照）&lt;/p&gt;

&lt;h3 id=&#34;クライアント認証&#34;&gt;クライアント認証&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;NSURLSession&lt;/code&gt;でクライアント認証を実装するには、&lt;code&gt;NSURLSessionDelegate&lt;/code&gt;の
&lt;code&gt;URLSession(_:didReceiveChallenge:completionHandler:)&lt;/code&gt;を実装する。&lt;/p&gt;

&lt;p&gt;サーバからクライアント認証が要求されると、このデリゲートメソッドが呼ばれるので、
クライアント証明書を読み込んで&lt;code&gt;NSURLCredential&lt;/code&gt;にして渡してあげればOK。&lt;/p&gt;

&lt;p&gt;注意点は、他の認証（通常のSSL/TLS認証とかBasic認証）時も全て呼び出されるので、その実装を忘れないこと！&lt;/p&gt;

&lt;p&gt;以上を踏まえると、実装はこんな感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func URLSession(session: NSURLSession, didReceiveChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&amp;gt; Void) {
    switch challenge.protectionSpace.authenticationMethod {
    // 通常のhttpsのSSL/TLS認証
    case NSURLAuthenticationMethodServerTrust:
      // デフォルトの動作をさせる
      completionHandler(.PerformDefaultHandling, nil)
    // httpsのクライアント認証
    case NSURLAuthenticationMethodClientCertificate:
      // clientCredential(あらかじめクライアント証明書から生成した認証情報)を
      // 利用して認証をかける
      completionHandler(.UseCredential, clientCredential)
    // その他の認証
    default:
      completionHandler(.PerformDefaultHandling, nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クライアント証明書の読み込み&#34;&gt;クライアント証明書の読み込み&lt;/h3&gt;

&lt;p&gt;クライアントの証明書は&lt;code&gt;p12&lt;/code&gt;形式を利用する。
証明書からは&lt;code&gt;SecPKCS12Import&lt;/code&gt;を使って認証情報を取り出し、&lt;code&gt;NSURLCredential&lt;/code&gt;を生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// アプリにバンドルされているクライアント証明書(apns.p12)
guard let url = NSBundle.mainBundle().
  URLForResource(&amp;quot;apns&amp;quot;, withExtension: &amp;quot;p12&amp;quot;) else { return }
guard let p12data = NSData(contentsOfURL: p12URL) else { return }

let passphrase = &amp;quot;0000&amp;quot;     // 証明書のパスフレーズ
let options = [kSecImportExportPassphrase as String : passphrase]

var items: CFArray?
guard SecPKCS12Import(p12data, options, &amp;amp;items) == errSecSuccess
  else { return }
guard let cfarr = items else { return }
guard let certEntry = (cfarr as Array).first as? [String: AnyObject]
  else { return }

let identity = certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity
let certificates = certEntry[&amp;quot;chain&amp;quot;] as? [AnyObject]
let clientCredential = NSURLCredential(identity: identity,
                                       certificates: certificates,
                                       persistence: .ForSession)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はサンプルなのでクライアント証明書はアプリにバンドルしているが、通常はキーチェーンにいれておくべき。&lt;/p&gt;

&lt;p&gt;なお、クライアント証明書の中身はPush送信用の一つだけが入っている前提。&lt;/p&gt;

&lt;p&gt;小ネタなのが、&lt;code&gt;certEntry[&amp;quot;identity&amp;quot;] as! SecIdentity&lt;/code&gt;という部分。
&lt;code&gt;AnyObject&lt;/code&gt;から&lt;code&gt;SecIdentity&lt;/code&gt;への変換は常に成功するので&lt;code&gt;as?&lt;/code&gt;にはできないみたい。
詳細は&lt;a href=&#34;https://forums.developer.apple.com/thread/11171&#34;&gt;公式フォーラム&lt;/a&gt;を参照。&lt;/p&gt;

&lt;h3 id=&#34;apnsの送信&#34;&gt;APNsの送信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// デバイストークン
let deviceToken = &amp;quot;00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0&amp;quot;
// 通知内容
let payload = &amp;quot;{\&amp;quot;aps\&amp;quot;:{\&amp;quot;alert\&amp;quot;:\&amp;quot;Hello!\&amp;quot;}}&amp;quot;

// 開発環境向けURL
guard let url = NSURL(string: &amp;quot;https://api.development.push.apple.com/3/device/&amp;quot;)
  else { return }
let request = NSMutableURLRequest(URL: url.URLByAppendingPathComponent(deviceToken))
request.HTTPMethod = &amp;quot;POST&amp;quot;
request.HTTPBody = payload.dataUsingEncoding(NSUTF8StringEncoding)

let config = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: config, delegate: self, delegateQueue: nil)
session.dataTaskWithRequest(request).resume()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;送信時のポイントは、デリゲートを指定しておくことと、&lt;code&gt;completionHandler&lt;/code&gt;形式のメソッドを使わないこと。
使ってしまうとデリゲートが呼び出されなくなり、クライアント認証が通らなくなる。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回は本当にネタ。多分使い道はないと思う。。。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;クライアント証明書を上書きして使う必要があるので注意！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/APNs_iOS&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APNs Provider API(http2)を利用する(Node.js)</title>
      <link>https://mike-neko.github.io/blog/http2apns/</link>
      <pubDate>Thu, 11 Aug 2016 17:16:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
サーバサイドは&lt;code&gt;Node.js&lt;/code&gt;を利用。&lt;/p&gt;

&lt;h3 id=&#34;apns-provider-api&#34;&gt;APNs Provider API&lt;/h3&gt;

&lt;p&gt;利用するために必要なのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http2のPOST送信&lt;/li&gt;
&lt;li&gt;クライアント認証用の証明書&lt;/li&gt;
&lt;li&gt;CAルート証明書（必要な場合のみ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。
なお、&lt;code&gt;http2&lt;/code&gt;対応が必要なのは送信のみなので、サーバ自体はhttp2対応にしなくてもOK。&lt;/p&gt;

&lt;p&gt;従来のソケット通信経由でAPNsを送信するのと比較すると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;実装が簡単&lt;/li&gt;
&lt;li&gt;1つのデバイストークン毎に結果が取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というのが大きなメリット。&lt;/p&gt;

&lt;p&gt;特に以前は、環境の異なるトークンを送信すると、いきなりソケットの接続自体が切断される・・・
みたいな挙動があって確実に全件送信させるのは結構大変だったけど、API方式ではそういったのはなさそう。&lt;/p&gt;

&lt;p&gt;パフォーマンス的にどうなのかは不明。&lt;/p&gt;

&lt;h3 id=&#34;送信形式&#34;&gt;送信形式&lt;/h3&gt;

&lt;p&gt;環境毎のAppleのサーバへPOSTリクエストを送ることでPush通知が送信される。&lt;br /&gt;
指定する内容自体は従来のものと同じなので、詳細な内容は公式を参照のこと。&lt;/p&gt;

&lt;h4 id=&#34;アドレス&#34;&gt;アドレス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;開発 : &lt;code&gt;https://api.development.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;商用 : &lt;code&gt;https://api.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ヘッダ&#34;&gt;ヘッダ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apns-topic&lt;/code&gt; : 送信対象のアプリのバンドルID&lt;del&gt;（必須）&lt;/del&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-id&lt;/code&gt; : 通知ID。指定しなければAPNs側で自動生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-expiration&lt;/code&gt; : 通知が無効になり破棄できるようになる有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-priority&lt;/code&gt; : 優先度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ボディ&#34;&gt;ボディ&lt;/h4&gt;

&lt;p&gt;JSON形式の通知ペイロード&lt;/p&gt;

&lt;h4 id=&#34;レスポンス&#34;&gt;レスポンス&lt;/h4&gt;

&lt;p&gt;送信の受付に成功した場合はステータスコードが&lt;code&gt;200&lt;/code&gt;で返ってくる。&lt;/p&gt;

&lt;p&gt;失敗した場合は、それ以外のステータスコードと、コードに応じてより詳細なエラー内容がボディで返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;もしかすると、&lt;code&gt;OpenSSL&lt;/code&gt;は最新に上げておいた方がいいかも知れない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;は現時点(6.3.1)では&lt;code&gt;http2&lt;/code&gt;には対応していないので、
&lt;a href=&#34;https://www.npmjs.com/package/http2&#34;&gt;http2&lt;/a&gt;というモジュールをインストールしておく。&lt;/p&gt;

&lt;h3 id=&#34;証明書&#34;&gt;証明書&lt;/h3&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;と同じ。
ただし、今回はMacに直接インストールした&lt;code&gt;Node.js&lt;/code&gt;を使うので、CAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/2f2f9f9130ef1d46872894b115a4b0c3.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;クライアント証明書の指定&#34;&gt;クライアント証明書の指定&lt;/h3&gt;

&lt;p&gt;22,23行目にあるように、クライアント証明書と鍵を読み込んで指定する。
（もちろん各ファイルを同じフォルダ内に置いておくのを忘れないように）&lt;/p&gt;

&lt;p&gt;もし、証明書の秘密鍵のパスフレーズを設定している時は、25行目のように設定が必要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（8/24 追記）&lt;/em&gt;&lt;/strong&gt;
証明書の中が送信対象アプリ単独のもの（他の証明書や鍵を含んでいない）であれば、
&lt;code&gt;apns-topic&lt;/code&gt;は指定しなくても送信可能。&lt;br /&gt;
通常の手順で生成した場合は単独のはずなので、指定は不要。&lt;/p&gt;

&lt;h3 id=&#34;通知内容の設定&#34;&gt;通知内容の設定&lt;/h3&gt;

&lt;p&gt;送信形式の項目で述べたように、ヘッダにバンドルIDを設定(10−12,21行目)する。&lt;/p&gt;

&lt;p&gt;デバイストークンは、URLの一部として設定する(20行目)。&lt;/p&gt;

&lt;p&gt;通知ペイロードは、44行目にあるようにボディとして書き出す。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html&#34;&gt;APNs Provider API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/jp/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW1&#34;&gt;日本語ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Node.js 6.3.1&lt;/li&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GitHubにタグ付けする</title>
      <link>https://mike-neko.github.io/blog/gittag/</link>
      <pubDate>Tue, 02 Aug 2016 21:36:00 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/gittag/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;GitHubにタグを付ける方法。
&lt;code&gt;GitHub Desktop&lt;/code&gt;はブランチ周りはサポートしているけどタグ関係はサポートしていないのでメモしておく。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GitHub Desktop&lt;/code&gt;でタグ付けしたいリポジトリを選択する&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;タグをつけたいコミットを選択し、チェックサムをコピーする&lt;br /&gt;
（下図の赤枠で囲んだ部分だけでOK）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-08-02-gittag/checksum.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;メニューの&lt;code&gt;Repository&lt;/code&gt;から&lt;code&gt;Open in Terminal&lt;/code&gt;を選択してターミナルを開く&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ターミナルで以下を実行しタグを付ける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag -a [タグ名] -m &amp;quot;メッセージ&amp;quot; [タグ付けするコミットのチェックサム]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例）&lt;code&gt;git tag -a v1.0 -m &amp;quot;drop only&amp;quot; 2a49b78&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ターミナルで以下を実行しタグが付いたか確認する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git show [タグ名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例）&lt;code&gt;git show v1.0&lt;/code&gt;&lt;br /&gt;
（タグの一覧を見たい場合は&lt;code&gt;git tag&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;タグをプッシュする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 特定のタグだけ
git push origin [タグ名]
// プッシュされていない全てのタグ
git push origin --tags
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;githubの状態&#34;&gt;GitHubの状態&lt;/h2&gt;

&lt;p&gt;タグをプッシュすると、GitHub上でも確認できるようになる。&lt;br /&gt;
GitHubではタグは主にリリースと関連づける前提の様子。&lt;/p&gt;

&lt;p&gt;例だと、以下のような感じで反映される。&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-08-02-gittag/github.png&#34; /&gt;
&lt;/figure&gt;


&lt;p&gt;タグをつけておくと、zipで直接落とせるので便利！&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E5%9F%BA%E6%9C%AC-%E3%82%BF%E3%82%B0&#34;&gt;Git の基本 - タグ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>KVOを利用する(Swift)</title>
      <link>https://mike-neko.github.io/blog/swift-kvo/</link>
      <pubDate>Mon, 25 Jul 2016 22:55:03 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/swift-kvo/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;で&lt;code&gt;KVO&lt;/code&gt;を利用する方法について。特に&lt;code&gt;context&lt;/code&gt;を一意の識別子として使いたい場合の方法。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコード&#34;&gt;サンプルコード&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5f00c1927b3cede0376c575147956112.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;ポイント&#34;&gt;ポイント&lt;/h2&gt;

&lt;h3 id=&#34;nsobject-を継承する&#34;&gt;&lt;code&gt;NSObject&lt;/code&gt;を継承する&lt;/h3&gt;

&lt;p&gt;監視対象も監視するクラスも両方とも&lt;code&gt;NSObject&lt;/code&gt;のサブクラスであることが必要。&lt;/p&gt;

&lt;p&gt;監視対象（サンプルでは&lt;code&gt;Target&lt;/code&gt;）で継承しなかった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;NSUnknownKeyException&#39;, reason: &#39;[&amp;lt;〜.ViewController 0x〜&amp;gt; addObserver:&amp;lt;〜.ViewController 0x〜&amp;gt; forKeyPath:@&amp;quot;target.valueA&amp;quot; options:3 context:0x〜] was sent to an object that is not KVC-compliant for the &amp;quot;target&amp;quot; property.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった実行時エラーが発生する。&lt;/p&gt;

&lt;p&gt;監視する側だとそもそも&lt;code&gt;addObserver&lt;/code&gt;などが利用できない。&lt;/p&gt;

&lt;h3 id=&#34;プロパティには-dynamic-をつける&#34;&gt;プロパティには&lt;code&gt;dynamic&lt;/code&gt;をつける&lt;/h3&gt;

&lt;p&gt;監視対象のプロパティ（&lt;code&gt;addObserver&lt;/code&gt;で追加するプロパティ）は必ず&lt;code&gt;dynamic&lt;/code&gt;をつけること。&lt;/p&gt;

&lt;p&gt;もし、これをつけ忘れると、エラーにはならないが、通知も来ない状態
（＝変更されても&lt;code&gt;observeValueForKeyPath&lt;/code&gt;が呼ばれない）
という判りにくいバグになってしまう。&lt;/p&gt;

&lt;h3 id=&#34;アクセスコントロールに注意&#34;&gt;アクセスコントロールに注意&lt;/h3&gt;

&lt;p&gt;プロパティが別クラスのオブジェクト?の場合、&lt;code&gt;private&lt;/code&gt;にすると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;NSUnknownKeyException&#39;, reason: &#39;[&amp;lt;〜.ViewController 0x〜&amp;gt; addObserver:&amp;lt;〜.ViewController 0x〜&amp;gt; forKeyPath:@&amp;quot;target.valueA&amp;quot; options:3 context:0x〜] was sent to an object that is not KVC-compliant for the &amp;quot;target&amp;quot; property.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった実行時エラーが発生する。&lt;/p&gt;

&lt;p&gt;サンプルだと、&lt;code&gt;value1&lt;/code&gt;と&lt;code&gt;value2&lt;/code&gt;は&lt;code&gt;private&lt;/code&gt;でも問題無いが、&lt;code&gt;target&lt;/code&gt;は&lt;code&gt;private&lt;/code&gt;ではエラーになる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;や&lt;code&gt;Int&lt;/code&gt;ではエラーにならないのは確認したが、具体的な条件は未調査・・・&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;識別子としての-context-の指定&#34;&gt;識別子としての&lt;code&gt;context&lt;/code&gt;の指定&lt;/h3&gt;

&lt;p&gt;通常の指定方法は参考リンクの通り（&lt;code&gt;private var myContext = 0&lt;/code&gt;）。
ただ、今回のサンプルでは、キー値の指定とまとめて以下のようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private struct KeyContext {
    static var value1 = &amp;quot;value1&amp;quot;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というのも、&lt;code&gt;context&lt;/code&gt;には一意なアドレスを渡すべきなので、&lt;code&gt;static&lt;/code&gt;によりアドレスを確保している。
（通常の指定方法ではグローバル変数にして一意なアドレスを確保）&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;private&lt;/code&gt;なのは単に他からアクセスさせないようにしたい（する必要がない）からで、
&lt;code&gt;struct&lt;/code&gt;の中で宣言しているのは、名前空間のようにしたかったからである。
よって、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var value1 = &amp;quot;value1&amp;quot;
...

class ViewController: UIViewController {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と言った書き方でも同じ。&lt;/p&gt;

&lt;h3 id=&#34;通知の登録-解除&#34;&gt;通知の登録 / 解除&lt;/h3&gt;

&lt;h4 id=&#34;呼び出しタイミング&#34;&gt;呼び出しタイミング&lt;/h4&gt;

&lt;h5 id=&#34;登録時&#34;&gt;登録時&lt;/h5&gt;

&lt;p&gt;サンプルでは&lt;code&gt;UIViewController&lt;/code&gt;なので、&lt;code&gt;viewWillAppear&lt;/code&gt;で登録しているが、
通常は&lt;code&gt;init&lt;/code&gt;での登録が良さげ。&lt;/p&gt;

&lt;h5 id=&#34;解除時&#34;&gt;解除時&lt;/h5&gt;

&lt;p&gt;サンプルでは登録が&lt;code&gt;viewWillAppear&lt;/code&gt;なので、対となる&lt;code&gt;viewWillDisappear&lt;/code&gt;で解除しているが、
通常は&lt;code&gt;deinit&lt;/code&gt;での登録が良い。&lt;/p&gt;

&lt;h4 id=&#34;登録方法&#34;&gt;登録方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;addObserver(self, forKeyPath: KeyContext.value1, options: .New, context: &amp;amp;KeyContext.value1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt;との相違点は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KeyPath&lt;/code&gt;に&lt;code&gt;self&lt;/code&gt;がいらない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;を複数指定する時は、&lt;code&gt;|&lt;/code&gt;ではなく配列（例：&lt;code&gt;[.New, .Old]&lt;/code&gt;）で渡す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt;へのポインタは&lt;code&gt;&amp;amp;&lt;/code&gt;だけで良い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったあたり。&lt;/p&gt;

&lt;h3 id=&#34;通知の受信&#34;&gt;通知の受信&lt;/h3&gt;

&lt;p&gt;今回は、&lt;code&gt;context&lt;/code&gt;を識別子として利用しているので、&lt;code&gt;switch&lt;/code&gt;でまとめて比較しているが、&lt;code&gt;defalut&lt;/code&gt;の時にちゃんと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を呼ぶこと。これがないと、もし親クラスで何か監視をしていた場合に処理が正しく行われないので。
（当然、自身の監視対象だった場合は呼ばない）&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;case&lt;/code&gt;に監視対象のプロパティを書き忘れると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の実行時エラーとなる。&lt;/p&gt;

&lt;h4 id=&#34;値の取得&#34;&gt;値の取得&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Change Dictionary Keys: 
// NSKeyValueChangeNewKeyとかNSKeyValueChangeOldKeyとか
let value = change?[&amp;quot;Change Dictionary Keys&amp;quot;] as? &amp;quot;データ型&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けば希望のデータ型へ変換して取得できる。
&lt;code&gt;NSNull&lt;/code&gt;や型が違う場合などは、最終的に&lt;code&gt;nil&lt;/code&gt;が入るのでサンプルのように
&lt;code&gt;guard&lt;/code&gt;ではじくのがスマート。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12&#34;&gt;Using Swift with Cocoa and Objective-C (Swift 2.2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>