<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/post/</link>
    <description>Recent content in Posts on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Thu, 11 Aug 2016 17:16:16 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>APNs Provider API(http2)を利用する(Node.js)</title>
      <link>https://mike-neko.github.io/blog/http2apns/</link>
      <pubDate>Thu, 11 Aug 2016 17:16:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/http2apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのAPNsをAPI経由で使う方法。
サーバサイドは&lt;code&gt;Node.js&lt;/code&gt;を利用。&lt;/p&gt;

&lt;h3 id=&#34;apns-provider-api&#34;&gt;APNs Provider API&lt;/h3&gt;

&lt;p&gt;利用するために必要なのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http2のPOST送信&lt;/li&gt;
&lt;li&gt;クライアント認証用の証明書&lt;/li&gt;
&lt;li&gt;CAルート証明書（必要な場合のみ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。
なお、&lt;code&gt;http2&lt;/code&gt;対応が必要なのは送信のみなので、サーバ自体はhttp2対応にしなくてもOK。&lt;/p&gt;

&lt;p&gt;従来のソケット通信経由でAPNsを送信するのと比較すると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;実装が簡単&lt;/li&gt;
&lt;li&gt;1つのデバイストークン毎に結果が取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というのが大きなメリット。&lt;/p&gt;

&lt;p&gt;特に以前は、環境の異なるトークンを送信すると、いきなりソケットの接続自体が切断される・・・
みたいな挙動があって確実に全件送信させるのは結構大変だったけど、API方式ではそういったのはなさそう。&lt;/p&gt;

&lt;p&gt;パフォーマンス的にどうなのかは不明。&lt;/p&gt;

&lt;h3 id=&#34;送信形式&#34;&gt;送信形式&lt;/h3&gt;

&lt;p&gt;環境毎のAppleのサーバへPOSTリクエストを送ることでPush通知が送信される。&lt;br /&gt;
指定する内容自体は従来のものと同じなので、詳細な内容は公式を参照のこと。&lt;/p&gt;

&lt;h4 id=&#34;アドレス&#34;&gt;アドレス&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;開発 : &lt;code&gt;https://api.development.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;商用 : &lt;code&gt;https://api.push.apple.com/3/device/&amp;lt;デバイストークン&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ヘッダ&#34;&gt;ヘッダ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apns-topic&lt;/code&gt; : 送信対象のアプリのバンドルID（必須）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-id&lt;/code&gt; : 通知ID。指定しなければAPNs側で自動生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-expiration&lt;/code&gt; : 通知が無効になり破棄できるようになる有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apns-priority&lt;/code&gt; : 優先度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ボディ&#34;&gt;ボディ&lt;/h4&gt;

&lt;p&gt;JSON形式の通知ペイロード&lt;/p&gt;

&lt;h4 id=&#34;レスポンス&#34;&gt;レスポンス&lt;/h4&gt;

&lt;p&gt;送信の受付に成功した場合はステータスコードが&lt;code&gt;200&lt;/code&gt;で返ってくる。&lt;/p&gt;

&lt;p&gt;失敗した場合は、それ以外のステータスコードと、コードに応じてより詳細なエラー内容がボディで返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;もしかすると、&lt;code&gt;OpenSSL&lt;/code&gt;は最新に上げておいた方がいいかも知れない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;は現時点(6.3.1)では&lt;code&gt;http2&lt;/code&gt;には対応していないので、
&lt;a href=&#34;https://www.npmjs.com/package/http2&#34;&gt;http2&lt;/a&gt;というモジュールをインストールしておく。&lt;/p&gt;

&lt;h3 id=&#34;証明書&#34;&gt;証明書&lt;/h3&gt;

&lt;p&gt;証明書の準備方法は、以前の&lt;a href=&#34;../perfect-push/&#34;&gt;Perfect APNs編&lt;/a&gt;と同じ。
ただし、今回はMacに直接インストールした&lt;code&gt;Node.js&lt;/code&gt;を使うので、CAルート証明書は不要。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/2f2f9f9130ef1d46872894b115a4b0c3.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;クライアント証明書の指定&#34;&gt;クライアント証明書の指定&lt;/h3&gt;

&lt;p&gt;22,23行目にあるように、クライアント証明書と鍵を読み込んで指定する。
（もちろん各ファイルを同じフォルダ内に置いておくのを忘れないように）&lt;/p&gt;

&lt;p&gt;もし、証明書の秘密鍵のパスフレーズを設定している時は、25行目のように設定が必要。&lt;/p&gt;

&lt;h3 id=&#34;通知内容の設定&#34;&gt;通知内容の設定&lt;/h3&gt;

&lt;p&gt;送信形式の項目で述べたように、ヘッダにバンドルIDを設定(10−12,21行目)する。&lt;/p&gt;

&lt;p&gt;デバイストークンは、URLの一部として設定する(20行目)。&lt;/p&gt;

&lt;p&gt;通知ペイロードは、44行目にあるようにボディとして書き出す。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html&#34;&gt;APNs Provider API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/jp/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW1&#34;&gt;日本語ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12 Beta&lt;/li&gt;
&lt;li&gt;Node.js 6.3.1&lt;/li&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GitHubにタグ付けする</title>
      <link>https://mike-neko.github.io/blog/gittag/</link>
      <pubDate>Tue, 02 Aug 2016 21:36:00 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/gittag/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;GitHubにタグを付ける方法。
&lt;code&gt;GitHub Desktop&lt;/code&gt;はブランチ周りはサポートしているけどタグ関係はサポートしていないのでメモしておく。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GitHub Desktop&lt;/code&gt;でタグ付けしたいリポジトリを選択する&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;タグをつけたいコミットを選択し、チェックサムをコピーする&lt;br /&gt;
（下図の赤枠で囲んだ部分だけでOK）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-08-02-gittag/checksum.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;メニューの&lt;code&gt;Repository&lt;/code&gt;から&lt;code&gt;Open in Terminal&lt;/code&gt;を選択してターミナルを開く&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ターミナルで以下を実行しタグを付ける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag -a [タグ名] -m &amp;quot;メッセージ&amp;quot; [タグ付けするコミットのチェックサム]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例）&lt;code&gt;git tag -a v1.0 -m &amp;quot;drop only&amp;quot; 2a49b78&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ターミナルで以下を実行しタグが付いたか確認する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git show [タグ名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例）&lt;code&gt;git show v1.0&lt;/code&gt;&lt;br /&gt;
（タグの一覧を見たい場合は&lt;code&gt;git tag&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;タグをプッシュする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 特定のタグだけ
git push origin [タグ名]
// プッシュされていない全てのタグ
git push origin --tags
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;githubの状態&#34;&gt;GitHubの状態&lt;/h2&gt;

&lt;p&gt;タグをプッシュすると、GitHub上でも確認できるようになる。&lt;br /&gt;
GitHubではタグは主にリリースと関連づける前提の様子。&lt;/p&gt;

&lt;p&gt;例だと、以下のような感じで反映される。&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-08-02-gittag/github.png&#34; /&gt;
&lt;/figure&gt;


&lt;p&gt;タグをつけておくと、zipで直接落とせるので便利！&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E5%9F%BA%E6%9C%AC-%E3%82%BF%E3%82%B0&#34;&gt;Git の基本 - タグ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>KVOを利用する(Swift)</title>
      <link>https://mike-neko.github.io/blog/swift-kvo/</link>
      <pubDate>Mon, 25 Jul 2016 22:55:03 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/swift-kvo/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;で&lt;code&gt;KVO&lt;/code&gt;を利用する方法について。特に&lt;code&gt;context&lt;/code&gt;を一意の識別子として使いたい場合の方法。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコード&#34;&gt;サンプルコード&lt;/h2&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5f00c1927b3cede0376c575147956112.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;ポイント&#34;&gt;ポイント&lt;/h2&gt;

&lt;h3 id=&#34;nsobject-を継承する&#34;&gt;&lt;code&gt;NSObject&lt;/code&gt;を継承する&lt;/h3&gt;

&lt;p&gt;監視対象も監視するクラスも両方とも&lt;code&gt;NSObject&lt;/code&gt;のサブクラスであることが必要。&lt;/p&gt;

&lt;p&gt;監視対象（サンプルでは&lt;code&gt;Target&lt;/code&gt;）で継承しなかった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;NSUnknownKeyException&#39;, reason: &#39;[&amp;lt;〜.ViewController 0x〜&amp;gt; addObserver:&amp;lt;〜.ViewController 0x〜&amp;gt; forKeyPath:@&amp;quot;target.valueA&amp;quot; options:3 context:0x〜] was sent to an object that is not KVC-compliant for the &amp;quot;target&amp;quot; property.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった実行時エラーが発生する。&lt;/p&gt;

&lt;p&gt;監視する側だとそもそも&lt;code&gt;addObserver&lt;/code&gt;などが利用できない。&lt;/p&gt;

&lt;h3 id=&#34;プロパティには-dynamic-をつける&#34;&gt;プロパティには&lt;code&gt;dynamic&lt;/code&gt;をつける&lt;/h3&gt;

&lt;p&gt;監視対象のプロパティ（&lt;code&gt;addObserver&lt;/code&gt;で追加するプロパティ）は必ず&lt;code&gt;dynamic&lt;/code&gt;をつけること。&lt;/p&gt;

&lt;p&gt;もし、これをつけ忘れると、エラーにはならないが、通知も来ない状態
（＝変更されても&lt;code&gt;observeValueForKeyPath&lt;/code&gt;が呼ばれない）
という判りにくいバグになってしまう。&lt;/p&gt;

&lt;h3 id=&#34;アクセスコントロールに注意&#34;&gt;アクセスコントロールに注意&lt;/h3&gt;

&lt;p&gt;プロパティが別クラスのオブジェクト?の場合、&lt;code&gt;private&lt;/code&gt;にすると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;NSUnknownKeyException&#39;, reason: &#39;[&amp;lt;〜.ViewController 0x〜&amp;gt; addObserver:&amp;lt;〜.ViewController 0x〜&amp;gt; forKeyPath:@&amp;quot;target.valueA&amp;quot; options:3 context:0x〜] was sent to an object that is not KVC-compliant for the &amp;quot;target&amp;quot; property.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった実行時エラーが発生する。&lt;/p&gt;

&lt;p&gt;サンプルだと、&lt;code&gt;value1&lt;/code&gt;と&lt;code&gt;value2&lt;/code&gt;は&lt;code&gt;private&lt;/code&gt;でも問題無いが、&lt;code&gt;target&lt;/code&gt;は&lt;code&gt;private&lt;/code&gt;ではエラーになる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;や&lt;code&gt;Int&lt;/code&gt;ではエラーにならないのは確認したが、具体的な条件は未調査・・・&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;識別子としての-context-の指定&#34;&gt;識別子としての&lt;code&gt;context&lt;/code&gt;の指定&lt;/h3&gt;

&lt;p&gt;通常の指定方法は参考リンクの通り（&lt;code&gt;private var myContext = 0&lt;/code&gt;）。
ただ、今回のサンプルでは、キー値の指定とまとめて以下のようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private struct KeyContext {
    static var value1 = &amp;quot;value1&amp;quot;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というのも、&lt;code&gt;context&lt;/code&gt;には一意なアドレスを渡すべきなので、&lt;code&gt;static&lt;/code&gt;によりアドレスを確保している。
（通常の指定方法ではグローバル変数にして一意なアドレスを確保）&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;private&lt;/code&gt;なのは単に他からアクセスさせないようにしたい（する必要がない）からで、
&lt;code&gt;struct&lt;/code&gt;の中で宣言しているのは、名前空間のようにしたかったからである。
よって、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var value1 = &amp;quot;value1&amp;quot;
...

class ViewController: UIViewController {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と言った書き方でも同じ。&lt;/p&gt;

&lt;h3 id=&#34;通知の登録-解除&#34;&gt;通知の登録 / 解除&lt;/h3&gt;

&lt;h4 id=&#34;呼び出しタイミング&#34;&gt;呼び出しタイミング&lt;/h4&gt;

&lt;h5 id=&#34;登録時&#34;&gt;登録時&lt;/h5&gt;

&lt;p&gt;サンプルでは&lt;code&gt;UIViewController&lt;/code&gt;なので、&lt;code&gt;viewWillAppear&lt;/code&gt;で登録しているが、
通常は&lt;code&gt;init&lt;/code&gt;での登録が良さげ。&lt;/p&gt;

&lt;h5 id=&#34;解除時&#34;&gt;解除時&lt;/h5&gt;

&lt;p&gt;サンプルでは登録が&lt;code&gt;viewWillAppear&lt;/code&gt;なので、対となる&lt;code&gt;viewWillDisappear&lt;/code&gt;で解除しているが、
通常は&lt;code&gt;deinit&lt;/code&gt;での登録が良い。&lt;/p&gt;

&lt;h4 id=&#34;登録方法&#34;&gt;登録方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;addObserver(self, forKeyPath: KeyContext.value1, options: .New, context: &amp;amp;KeyContext.value1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt;との相違点は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KeyPath&lt;/code&gt;に&lt;code&gt;self&lt;/code&gt;がいらない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;を複数指定する時は、&lt;code&gt;|&lt;/code&gt;ではなく配列（例：&lt;code&gt;[.New, .Old]&lt;/code&gt;）で渡す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt;へのポインタは&lt;code&gt;&amp;amp;&lt;/code&gt;だけで良い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったあたり。&lt;/p&gt;

&lt;h3 id=&#34;通知の受信&#34;&gt;通知の受信&lt;/h3&gt;

&lt;p&gt;今回は、&lt;code&gt;context&lt;/code&gt;を識別子として利用しているので、&lt;code&gt;switch&lt;/code&gt;でまとめて比較しているが、&lt;code&gt;defalut&lt;/code&gt;の時にちゃんと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を呼ぶこと。これがないと、もし親クラスで何か監視をしていた場合に処理が正しく行われないので。
（当然、自身の監視対象だった場合は呼ばない）&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;case&lt;/code&gt;に監視対象のプロパティを書き忘れると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の実行時エラーとなる。&lt;/p&gt;

&lt;h4 id=&#34;値の取得&#34;&gt;値の取得&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Change Dictionary Keys: 
// NSKeyValueChangeNewKeyとかNSKeyValueChangeOldKeyとか
let value = change?[&amp;quot;Change Dictionary Keys&amp;quot;] as? &amp;quot;データ型&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けば希望のデータ型へ変換して取得できる。
&lt;code&gt;NSNull&lt;/code&gt;や型が違う場合などは、最終的に&lt;code&gt;nil&lt;/code&gt;が入るのでサンプルのように
&lt;code&gt;guard&lt;/code&gt;ではじくのがスマート。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12&#34;&gt;Using Swift with Cocoa and Objective-C (Swift 2.2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SceneKitでMetalのシェーダを利用する(SCNProgram)</title>
      <link>https://mike-neko.github.io/blog/metalshader-scenekit/</link>
      <pubDate>Sun, 10 Jul 2016 18:28:58 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metalshader-scenekit/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Metal&lt;/code&gt;を使いたい場合にネックとなるのが、シーンの構築とかモデル・テクスチャの管理。
なので、その面倒な部分を&lt;code&gt;SceneKit&lt;/code&gt;に任せたいという時の話。&lt;/p&gt;

&lt;p&gt;今回は描画周りに&lt;code&gt;Metal&lt;/code&gt;のシェーダを使うパターン。&lt;/p&gt;

&lt;p&gt;主に&lt;code&gt;SceneKit&lt;/code&gt;でカスタムシェーダを使いたい場合は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SCNProgram&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCNShadable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCNTechnique&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった辺りがあるみたい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SCNTechnique&lt;/code&gt;はマルチパスのレンダリングに使うのがメインっぽい。
&lt;del&gt;（これも試したけどシェーダへカスタム変数を渡す辺りでつまずいて放置）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SCNShadable&lt;/code&gt;は&lt;code&gt;Metal&lt;/code&gt;での使えそうなサンプルがなかったので断念。&lt;/p&gt;

&lt;p&gt;という訳で、WWDCのセッションの資料にあった&lt;code&gt;SCNProgram&lt;/code&gt;を使って実装。&lt;/p&gt;

&lt;h2 id=&#34;下準備&#34;&gt;下準備&lt;/h2&gt;

&lt;p&gt;プロジェクトはXcodeのデフォルトのテンプレートの&lt;code&gt;Game&lt;/code&gt;を流用している。
作成時の&lt;code&gt;Game Technology&lt;/code&gt;では&lt;code&gt;SceneKit&lt;/code&gt;を選択する。&lt;/p&gt;

&lt;h3 id=&#34;scenekitの設定&#34;&gt;SceneKitの設定&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Main.storeyboard&lt;/code&gt;を開き、&lt;code&gt;Game View Controller&lt;/code&gt;の&lt;code&gt;SceneKit View&lt;/code&gt;の
&lt;code&gt;Rendering API&lt;/code&gt;を&lt;code&gt;Metal&lt;/code&gt;にする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;GameViewController&lt;/code&gt;の&lt;code&gt;viewDidLoad&lt;/code&gt;の中のライト周りのコードを削除&lt;br /&gt;
（今回のシェーダはライトを使わないもので不必要なので消す）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scnprogramの作成&#34;&gt;SCNProgramの作成&lt;/h3&gt;

&lt;p&gt;以下のようにして&lt;code&gt;SCNProgram&lt;/code&gt;を生成してシェーダの関数名を設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let program = SCNProgram()
program.vertexFunctionName = &amp;quot;textureVertex&amp;quot;
program.fragmentFunctionName = &amp;quot;textureFragment&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成した&lt;code&gt;SCNProgram&lt;/code&gt;を適用させたいマテリアルに設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let material = ship.childNodes.first?.geometry?.firstMaterial!
material.program = program
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;シェーダの準備&#34;&gt;シェーダの準備&lt;/h3&gt;

&lt;p&gt;通常どおり&lt;code&gt;Metal&lt;/code&gt;のファイルを追加した後に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;SceneKit/scn_metal&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする。
これは後述の&lt;code&gt;SceneKit&lt;/code&gt;とデータのやりとりに必要。&lt;/p&gt;

&lt;h2 id=&#34;データの渡し方&#34;&gt;データの渡し方&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SceneKit&lt;/code&gt;から描画に必要なデータ（座標や変換行列、テクスチャなど）を
シェーダへ渡す方法&lt;/p&gt;

&lt;h3 id=&#34;vertexshader側&#34;&gt;VertexShader側&lt;/h3&gt;

&lt;h4 id=&#34;頂点属性-位置とか法線とかuv座標とか&#34;&gt;頂点属性（位置とか法線とかuv座標とか）&lt;/h4&gt;

&lt;p&gt;まずは、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct VertexInput {
    float3 position [[ attribute(SCNVertexSemanticPosition) ]];
    float2 texcoord [[ attribute(SCNVertexSemanticTexcoord0) ]];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じで、頂点属性の中で必要なものを構造体で定義する。
すると、変数名の後ろの&lt;code&gt;Attribute Qualifier&lt;/code&gt;(&amp;rdquo;[[]]&amp;ldquo;で囲まれた部分)で指定したものが
&lt;code&gt;[[stage_in]]&lt;/code&gt;にバインドされて自動で渡されてくる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;指定できるものはドキュメントの&lt;code&gt;Table 1 
SceneKit Vertex Attribute Qualifiers for Metal Shaders&lt;/code&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;フレーム定数-ビューの変換行列など&#34;&gt;フレーム定数（ビューの変換行列など）&lt;/h4&gt;

&lt;p&gt;あらかじめ&lt;code&gt;SCNSceneBuffer&lt;/code&gt;という構造体が用意されており、これらはその中に入っている。
このデータは&lt;code&gt;[[buffer(0)]]&lt;/code&gt;にバインドされて渡されてくる。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;構造体の定義はドキュメントの&lt;code&gt;Frame-Constant Data&lt;/code&gt;の項目を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;ノード毎のデータ-モデルの変換行列など&#34;&gt;ノード毎のデータ（モデルの変換行列など）&lt;/h4&gt;

&lt;p&gt;これは、あらかじめ用意された構造体がなく、代わりに必要なものをピックアップして
以下のように自分で構造体を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NodeBuffer {
    float4x4 modelViewProjectionTransform;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、そのデータが&lt;code&gt;[[buffer(1)]]&lt;/code&gt;にバインドされてシェーダに渡される。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ピックアップできるものはドキュメントの&lt;code&gt;Listing 1 
Available Fields for Per-Node Shader Data&lt;/code&gt;を参照&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;カスタム変数&#34;&gt;カスタム変数&lt;/h4&gt;

&lt;p&gt;上記以外の変数は構造体として定義が必要。定義自体は通常通りに行う。
ただし、バインドされるバッファは2以降になる。&lt;/p&gt;

&lt;h4 id=&#34;実装&#34;&gt;実装&lt;/h4&gt;

&lt;p&gt;まとめると、&lt;code&gt;VertexShader&lt;/code&gt;の宣言部分は以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vertex output myVertex(input in [[ stage_in ]],
                       constant SCNSceneBuffer&amp;amp; scn_frame [[ buffer(0) ]],
                       constant NodeBuffer&amp;amp; scn_node [[ buffer(1) ]],
                       constant CustomBuffer&amp;amp; custom [[ buffer(2) ]]) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでの重要なポイントは&lt;strong&gt;引数名&lt;/strong&gt;。
- &lt;code&gt;scn_frame&lt;/code&gt;と&lt;code&gt;scn_node&lt;/code&gt;は固定&lt;br /&gt;
（違う名前にすると正しくバインドされない）
- カスタム変数の引数名&lt;code&gt;custom&lt;/code&gt;は&lt;code&gt;SceneKit&lt;/code&gt;からデータを渡す時に使う&lt;/p&gt;

&lt;p&gt;中での処理は必要な計算をして、それを&lt;code&gt;FragmentShader&lt;/code&gt;に渡すという、
通常の&lt;code&gt;Metal&lt;/code&gt;のシェーダと同じ実装を行う。&lt;/p&gt;

&lt;h3 id=&#34;fragmentshader側&#34;&gt;FragmentShader側&lt;/h3&gt;

&lt;h4 id=&#34;テクスチャ&#34;&gt;テクスチャ&lt;/h4&gt;

&lt;p&gt;テクスチャを利用したい場合は、特に事前の定義などは不要で通常通り宣言する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fragment half4 textureFragment(VertexOut in [[ stage_in ]],
                               texture2d&amp;lt;float&amp;gt; texture [[ texture(0) ]]) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただしここでも重要なポイントは&lt;strong&gt;引数名&lt;/strong&gt;（詳細は後述）。&lt;/p&gt;

&lt;h3 id=&#34;scenekit側&#34;&gt;SceneKit側&lt;/h3&gt;

&lt;p&gt;カスタム変数とテクスチャ以外は自動でバインドされる&lt;br /&gt;
（＝SceneKit側の処理は特にない）&lt;/p&gt;

&lt;h4 id=&#34;カスタム変数-1&#34;&gt;カスタム変数&lt;/h4&gt;

&lt;p&gt;シェーダ側と同じ構造体のデータを準備する辺りは通常通り。&lt;/p&gt;

&lt;p&gt;そのデータをシェーダ側にバインドするのは以下のように&lt;code&gt;setValue&lt;/code&gt;を利用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var custom = CustomBuffer(color: float4(0, 0, 0, 1))
material.setValue(NSData(bytes: &amp;amp;custom, length:sizeof(CustomBuffer)),
                  forKey: &amp;quot;custom&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setValue&lt;/code&gt;は&lt;code&gt;SCNProgram&lt;/code&gt;をセットしたのと同じ対象（今回は&lt;code&gt;material&lt;/code&gt;）に行う。&lt;br /&gt;
また、&lt;code&gt;value&lt;/code&gt;は&lt;code&gt;NSData&lt;/code&gt;としてバイナリで渡し、&lt;code&gt;key&lt;/code&gt;はシェーダでの宣言と同じ名前にする。&lt;/p&gt;

&lt;h4 id=&#34;テクスチャ-1&#34;&gt;テクスチャ&lt;/h4&gt;

&lt;p&gt;今回のモデルではマテリアルの&lt;code&gt;diffuse&lt;/code&gt;にテクスチャが設定されているので、まずそれを取得する。
その後、&lt;code&gt;SCNMaterialProperty&lt;/code&gt;の形式にしてから変数と同様に&lt;code&gt;setValue&lt;/code&gt;する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let contents = material.diffuse.contents else { return }
material.setValue(SCNMaterialProperty(contents: contents),
                  forKey: &amp;quot;texture&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは、&lt;code&gt;SCNMaterialProperty&lt;/code&gt;を生成しなおしてからセットすること。&lt;br /&gt;
直接&lt;code&gt;diffuse&lt;/code&gt;の中のデータを&lt;code&gt;setValue&lt;/code&gt;すると正しくデータが渡されない。&lt;/p&gt;

&lt;h4 id=&#34;命名の注意点&#34;&gt;命名の注意点&lt;/h4&gt;

&lt;p&gt;シェーダの引数名と&lt;code&gt;SceneKit&lt;/code&gt;側で&lt;code&gt;setValue&lt;/code&gt;の&lt;code&gt;key&lt;/code&gt;は一致させる必要がある。&lt;/p&gt;

&lt;p&gt;さらに大事な点として、&lt;code&gt;setValue&lt;/code&gt;は&lt;code&gt;KVO&lt;/code&gt;を利用しているので、
命名時にはオブジェクトのプロパティとかぶる様な名前をつけてはいけない。&lt;br /&gt;
（例えば&lt;code&gt;color&lt;/code&gt;などは実行時にエラーログが出て連携ができない）&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回はサンプルもなくとても苦戦した。。。特にシェーダとSceneKit間のデータのやりとり辺りは、
ドキュメントにも細かく書いてなくて苦労した。&lt;br /&gt;
妙に親切に頂点属性などをバインドしてくれると思ったら、
引数名固定だったり、テクスチャの再生成が必要だったりと落とし穴もいっぱい・・・&lt;/p&gt;

&lt;p&gt;あと、引数名がスネークケースなのもいただけない。
他がキャメルケースなのでここは統一して欲しかった。&lt;/p&gt;

&lt;p&gt;ただ、Metalのバインドの辺りの仕組みはどうなっているのか興味深いので、
もっといろいろ触ってみたい。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Apple公式ドキュメント(&lt;a href=&#34;https://developer.apple.com/reference/scenekit/scnprogram&#34;&gt;SCNProgram&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalShaderSceneKit&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WKWebViewの内容をPDFで保存する(Swift)</title>
      <link>https://mike-neko.github.io/blog/webview-pdf/</link>
      <pubDate>Thu, 23 Jun 2016 00:13:25 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/webview-pdf/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;昔に&lt;code&gt;UIWebView&lt;/code&gt;でやっていたものを最新の&lt;code&gt;WKWebView&lt;/code&gt;+&lt;code&gt;Swift&lt;/code&gt;で書き換えた時のメモ。&lt;/p&gt;

&lt;p&gt;内容は大したことないのだけれど、検索で引っかかるWebの資料がiOS9の実機で動かなかったので残しておく。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;内容全体の取得&#34;&gt;内容全体の取得&lt;/h3&gt;

&lt;p&gt;今回は&lt;code&gt;WebView&lt;/code&gt;の中身全体をPDF化したいので、PDF化する時に表示中のコンテンツがビュー内に収まるように、
コンテンツの表示位置（&lt;code&gt;scrollView.contentOffset&lt;/code&gt;）を初期位置に戻し、
ビュー自体のサイズも表示ページのサイズ（&lt;code&gt;scrollView.contentSize&lt;/code&gt;）に拡大している。&lt;/p&gt;

&lt;p&gt;また、以下のようにPDFのページのサイズもコンテンツと同じサイズに設定している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// frameの中身はコンテンツのサイズ
UIGraphicsBeginPDFPageWithInfo(frame, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（つまり、書き出し時には一瞬画面がちらついてしまうので、気になる場合は
&lt;code&gt;ViewController&lt;/code&gt;の&lt;code&gt;view&lt;/code&gt;にマスクとなるビューを&lt;code&gt;addSubView&lt;/code&gt;して隠すこと）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ただし、あまりにコンテンツが長い場合は、うまく描画されないので注意！&lt;/strong&gt;&lt;br /&gt;
（例えば、Google検索結果とかだと半分ぐらいから下は空白状態になったり、全く空白になったりする）&lt;/p&gt;

&lt;p&gt;なお、端末によっても状況が異なるようで、対処方法は未調査。。。&lt;/p&gt;

&lt;h3 id=&#34;pdfへの書き出し&#34;&gt;PDFへの書き出し&lt;/h3&gt;

&lt;p&gt;今回は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webView.scrollView.drawViewHierarchyInRect(frame, afterScreenUpdates: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてWebView内のコンテンツをPDFに書き出ししている。&lt;/p&gt;

&lt;p&gt;ちまたにある資料では、この部分が、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webView.scrollView.layer.renderInContext(context)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになっているのが多いが、iOS9の実機では、
&lt;code&gt;CGImageCreateWithImageProvider: invalid image provider: NULL&lt;/code&gt;
のエラーが出て書き出しが出来なくなっている。（他のOSは未検証）&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;drawViewHierarchyInRect&lt;/code&gt;の方が速いらしいが、個人的には、
わざわざコンテキストの取得がいらなくなったのがありがたい。
（よく書く場所を間違えて取得に失敗する凡ミスをしていたので）&lt;/p&gt;

&lt;h3 id=&#34;pdfのファイル保存&#34;&gt;PDFのファイル保存&lt;/h3&gt;

&lt;p&gt;PDFをファイルとして保存したい場合は、&lt;code&gt;UIGraphicsBeginPDFContextToFile&lt;/code&gt;を利用するが、
このメソッドは既存のファイルを問答無用で上書きするので注意すること。&lt;/p&gt;

&lt;p&gt;もし、サーバへ送信などでデータが欲しい場合は、&lt;code&gt;UIGraphicsBeginPDFContextToData&lt;/code&gt;を利用すれば、
&lt;code&gt;NSData&lt;/code&gt;で取得できる。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/WebView2PDF&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QRコードの読み取りサンプル(Swift) その2</title>
      <link>https://mike-neko.github.io/blog/qr-reader/</link>
      <pubDate>Thu, 16 Jun 2016 21:17:36 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/qr-reader/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;以前に書いたQRコードの読み取りサンプルの別バージョン。
今回はカメラ不要で画像データから直接QRコードを読み取りが可能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;過去の記事（&lt;a href=&#34;../code-reader/&#34;&gt;QRコードの読み取りサンプル&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;サンプルでは、カメラロールから画像を取得し、認識できたQRコードを切り出して表示している。&lt;/p&gt;

&lt;p&gt;今回の認識部分は、&lt;code&gt;CoreImage&lt;/code&gt;の&lt;code&gt;CIDetector&lt;/code&gt;を利用している。
&lt;code&gt;CIDetector&lt;/code&gt;は顔認識や文字認識もできる優れもの。&lt;/p&gt;

&lt;h3 id=&#34;相違点&#34;&gt;相違点&lt;/h3&gt;

&lt;p&gt;前回の&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;を利用した方法との違いは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;画像データから読み取り可能&lt;/li&gt;
&lt;li&gt;読み取り可能なコードはQRコードのみ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった辺り。複数認識可能なのは変わらない。&lt;/p&gt;

&lt;p&gt;画像データは&lt;code&gt;UIImage&lt;/code&gt;が生成できるデータを用意すれば良いので、
元データはローカルファイルでもネット上でも、当然カメラからでもOK。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;qr検出&#34;&gt;QR検出&lt;/h3&gt;

&lt;p&gt;検出のコードはとてもシンプル。&lt;/p&gt;

&lt;p&gt;画像データを&lt;code&gt;CoreImage&lt;/code&gt;の形式へ変換し、検出器にかけるだけ。&lt;/p&gt;

&lt;p&gt;エラー処理を省略して抜粋すると以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let ciimg = CIImage(image: image)!
let detector = CIDetector(ofType: CIDetectorTypeQRCode,
                         context: nil, options: nil)
let results = detector.featuresInImage(ciimg) as! [CIQRCodeFeature]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、検出されたコードの配列が取得される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CIQRCodeFeature&lt;/code&gt;には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bounds&lt;/code&gt;：コードを検出した領域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bottomLeft bottomRight topLeft topRight&lt;/code&gt;：コードを検出した位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;messageString&lt;/code&gt;：コードに含まれるデータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が入っている。&lt;/p&gt;

&lt;h3 id=&#34;検出位置&#34;&gt;検出位置&lt;/h3&gt;

&lt;p&gt;位置の座標は、画面ではなく画像の座標を基準とした座標で取得される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bounds&lt;/code&gt;とそれ以外の&lt;code&gt;bottom〜&lt;/code&gt;や&lt;code&gt;top〜&lt;/code&gt;で取れる座標は、
検出したQRコードが回転していた場合に異なってくる。&lt;/p&gt;

&lt;p&gt;例えば、斜めの状態のQRコードが検出された場合、
&lt;code&gt;bounds&lt;/code&gt;は周りの余白部分を含めた正方形の領域が入る。
それ以外のものにはQRコードの各頂点の座標がそれぞれ入る。&lt;br /&gt;
（この辺りは実際に斜めの画像を読み込んで見ればよくわかる）&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;このQRコードの検出は&lt;code&gt;iOS8&lt;/code&gt;から可能になっているが、全然把握できていなかったので反省。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;CIDetector&lt;/code&gt;は他にもいろいろ検出できるので楽しみ。
他にもまだこういう知らないものがいっぱいあるんだろうな・・・&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;との性能などの差は未調査。。。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/QRReader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QRコードの読み取りサンプル(Swift) その1</title>
      <link>https://mike-neko.github.io/blog/code-reader/</link>
      <pubDate>Wed, 15 Jun 2016 22:52:40 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/code-reader/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のカメラでQRコードを読み取り、認識されたコードを枠線で強調表示するサンプル。&lt;/p&gt;

&lt;p&gt;なお、QRコードに限らず、他のバーコードや顔認識にも対応。対応形式は&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/AVFoundation/Reference/AVMetadataMachineReadableCodeObject_Class/index.html#//apple_ref/doc/constant_group/Machine_Readable_Object_Types&#34;&gt;公式&lt;/a&gt;を参照。地味にiOS8から対応形式が増えている。&lt;/p&gt;

&lt;p&gt;あと、2次元なら同時認識できたりするが、その辺りの詳細は参考リンクの公式FAQが詳しい。&lt;/p&gt;

&lt;p&gt;コード認識自体はもっと詳しい説明がいろんなとこにあるので、ここは他で説明していなそうなところだけ。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;シリアルキューの利用&#34;&gt;シリアルキューの利用&lt;/h3&gt;

&lt;p&gt;カメラの起動や画像認識は処理が重いので、それぞれ専用のシリアルキューを作成して利用している。&lt;/p&gt;

&lt;p&gt;カメラの設定周りはフリーズ状態になるのを防ぐためだが、最近の端末は起動が早いらしく、キューを使わなくても特に問題無い感じ。&lt;/p&gt;

&lt;h3 id=&#34;avmetadatamachinereadablecodeobject&#34;&gt;AVMetadataMachineReadableCodeObject&lt;/h3&gt;

&lt;p&gt;認識されたコードは&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;のオブジェクトの配列で渡される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：認識されたコードのフォーマットが逆DNS形式で返ってくる&lt;br /&gt;
(QRの場合は&lt;code&gt;org.iso.QRCode&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringValue&lt;/code&gt;：コードに含まれるデータ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;プレビュー画面上に認識したコードの枠を表示する&#34;&gt;プレビュー画面上に認識したコードの枠を表示する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;の中の&lt;code&gt;corners&lt;/code&gt;にコードの座標位置が含まれているが、これはプレビューのViewの座標系とは異なるので、そのままでは使えない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の&lt;code&gt;transformedMetadataObjectForMetadataObject&lt;/code&gt;で変換後の座標が入った&lt;code&gt;AVMetadataObject&lt;/code&gt;が取得できるので、その中の&lt;code&gt;bounds&lt;/code&gt;を使って枠線を描画している。&lt;/p&gt;

&lt;p&gt;（以前は手動でちゃんとプレビュー画面上の座標に変換していたが、今回、この簡単に変換できるメソッドを発見！&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の方もちゃんと調べていれば・・・）&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;昔iOS7で使えるようになった時に試したものを、Swiftで書き直し＋αしたコード。やはりSwiftはわかりやすく、かつエラー処理もしっかり書いても、Objective-Cよりコードが少ないので良い。&lt;/p&gt;

&lt;p&gt;以前は結構カメラの起動もコードの読み取りも時間がかかっていたのだが、今回はかなりスピードアップした感じがした。iPhoneのカメラの進化もすごいということか。ただ、バッテリーには優しくないので常に使うのは厳しそう・・・&lt;/p&gt;

&lt;p&gt;&lt;del&gt;あと、カメラをわざわざ起動しなくても画像を直接認識してくれるようになって欲しい。&lt;/del&gt;
(6/17追記：方法が判ったので&lt;a href=&#34;../qr-reader/&#34;&gt;その2&lt;/a&gt;を作成した)&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/technotes/tn2325/_index.html&#34;&gt;AV Foundation iOS Machine Readable Code Detection FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/CodeReader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;カメラ不要なバージョンは&lt;a href=&#34;../qr-reader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UnityからOpenCVを利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/unity-opencv/</link>
      <pubDate>Tue, 07 Jun 2016 00:56:50 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/unity-opencv/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;UnityからiOSのネイティブプラグイン経由で&lt;code&gt;OpenCV&lt;/code&gt;でカメラを利用するサンプル。&lt;/p&gt;

&lt;p&gt;内容としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OpenCV経由で端末のカメラ画像を取得&lt;/li&gt;
&lt;li&gt;取得した画像をOpenCVで処理（シンプルにグレースケールへ変換）&lt;/li&gt;
&lt;li&gt;ネイティブプラグイン経由でUnity側(C#)へ渡す&lt;/li&gt;
&lt;li&gt;Unity側でテクスチャを生成して表示する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れになる。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;opencvのフレームワークの準備&#34;&gt;OpenCVのフレームワークの準備&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://opencv.org/downloads.html&#34;&gt;公式のダウンロードページ&lt;/a&gt;から&lt;code&gt;for iOS&lt;/code&gt;の&lt;strong&gt;Ver.2系&lt;/strong&gt;をダウンロードする&lt;br /&gt;
（サンプルでは&lt;a href=&#34;https://sourceforge.net/projects/opencvlibrary/files/opencv-ios/2.4.13/opencv2.framework.zip/download&#34;&gt;Ver.2.4.13&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ダウンロードしたファイルを解凍して&lt;code&gt;opencv2.framework&lt;/code&gt;を取り出しておく&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、Ver.2を利用したのは、作成時点ではVer.3だとエラーが出てしまったので。
多分ソースからビルドするかバージョン上がれば、Ver.3系でも問題ないかと。&lt;/p&gt;

&lt;h3 id=&#34;iosネイティブ部分のソースを作成&#34;&gt;iOSネイティブ部分のソースを作成&lt;/h3&gt;

&lt;p&gt;OpenCVがC++なので、言語は&lt;code&gt;Objective-C++&lt;/code&gt;を利用する。&lt;br /&gt;
(残念ながらSwiftはC++を扱うことができないのでObjC一択)&lt;/p&gt;

&lt;p&gt;それに伴い、忘れずにファイルの拡張子を&lt;code&gt;.mm&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただその場合、ヘッダファイル（&lt;code&gt;.hpp&lt;/code&gt;）はUnityがプラグインのファイルとして認識してくれないので、
今回は一つのファイルに収まるように書いている。&lt;br /&gt;
（通常の&lt;code&gt;.h&lt;/code&gt;はちゃんと認識してくれるのに・・・）&lt;/p&gt;

&lt;p&gt;プラグインの呼び出しは以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[iOS]
OpenCV(C++)での処理
 |
ObjC++のクラスでラップ
 |
Cの関数でラッパークラスをエクスポート
 |
[Unity]
C#でDLLimportして呼び出し
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ObjC++で一旦ラップしているのは、OpenCV部分の開発は別にXCode上で行う為。
ただ、場合によってはメソッド呼び出しが遅いのでそこは注意。&lt;/p&gt;

&lt;p&gt;ネイティブ側のソースの全文は以下の通り。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/bf258536e5414e25b1e147c8b5e7834d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h4 id=&#34;通常のopencv周りの処理-4-51行目あたり&#34;&gt;通常のOpenCV周りの処理（4〜51行目あたり）&lt;/h4&gt;

&lt;p&gt;ややこしいのが、C++はARC管理外の為、手動でメモリ管理が必要。
今回はメモリの確保/破棄をラッパークラスの初期化/破棄と合わせて、
ラッパークラスの生存期間とOpenCVのオブジェクトの生存期間が一致するようにしてある。&lt;/p&gt;

&lt;p&gt;カメラの画像の取得は、初期化と同時に&lt;code&gt;cv::VideoCapture&lt;/code&gt;を生成し、
その後は毎フレーム&lt;code&gt;*camera &amp;gt;&amp;gt; img&lt;/code&gt;で画像を読み込んでいる。&lt;/p&gt;

&lt;p&gt;この時、取得された画像のフォーマットは&lt;code&gt;BGR&lt;/code&gt;なのがポイント。
最終的にUnityのテクスチャのサイズとフォーマット&lt;code&gt;RGBA&lt;/code&gt;に変換してUnity側へ渡す。&lt;br /&gt;
（Unity側では&lt;code&gt;ARGB&lt;/code&gt;の表記なので、最初それで変換してハマってた・・・）&lt;/p&gt;

&lt;h4 id=&#34;プラグインのエントリポイントを用意-54-77行目あたり&#34;&gt;プラグインのエントリポイントを用意（54〜77行目あたり）&lt;/h4&gt;

&lt;p&gt;用意するのはラッパークラス&lt;code&gt;VideoCapture&lt;/code&gt;の生成、毎フレーム呼び出す用、破棄の3つのCの関数。&lt;/p&gt;

&lt;p&gt;これを55〜59行目のように宣言してC#へエクスポートする。
このファイルはC++の扱いになっているので&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;が必要。&lt;br /&gt;
（逆に言うと、C#からはこれ以外が見えない状態となっている）&lt;/p&gt;

&lt;p&gt;関数の本体は61行目以降にあるように、単純にブリッジしているだけ。&lt;/p&gt;

&lt;h3 id=&#34;unityでネイティブプラグイン作成&#34;&gt;Unityでネイティブプラグイン作成&lt;/h3&gt;

&lt;h4 id=&#34;unityにネイティブのソース類を組み込む&#34;&gt;Unityにネイティブのソース類を組み込む&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Assets&lt;/code&gt;直下に&lt;code&gt;Plugins&lt;/code&gt;フォルダを作る&lt;/li&gt;
&lt;li&gt;作成した&lt;code&gt;Plugins&lt;/code&gt;フォルダにiOSネイティブ用のソースファイルを入れる&lt;br /&gt;
Unityのエディタ上のインスペクタの設定を念のため確認

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Select platforms for plugin&lt;/code&gt;：iOS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Platform settings&lt;/code&gt;：チェック不要&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;Plugins&lt;/code&gt;フォルダにダウンロードしておいた&lt;code&gt;opencv2.framework&lt;/code&gt;を丸ごと入れる&lt;br /&gt;
Unity上ではフォルダとして認識されて、中にいろいろあればOK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;コンポーネントの作成&#34;&gt;コンポーネントの作成&lt;/h4&gt;

&lt;p&gt;ネイティブの画像データからテクスチャを生成し、
そのテクスチャを指定した&lt;code&gt;Renderer&lt;/code&gt;のマテリアルにセットするコンポーネントを作成。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5ea8d851f18b163ae6a70f6a05ccd4d1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;当然、ネイティブプラグイン部分は、iOS上での実行時しか動かないので、
該当部分は&lt;code&gt;#if UNITY_IOS&lt;/code&gt;〜&lt;code&gt;#endif&lt;/code&gt;でエディタ実行時にエラーにならないようにしておく。&lt;/p&gt;

&lt;p&gt;ネイティブ側で準備したエントリポイントを利用する為にインポートの宣言（16〜26行目あたり）が必要。&lt;/p&gt;

&lt;p&gt;Cの関数宣言をそのままC#での宣言にするが、同じデータ型がC#にない場合は対応するデータ型を代わりに指定する。
（今回だと&lt;code&gt;void*&lt;/code&gt;が&lt;code&gt;IntPtr&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;なお、構造体をやりとりするような場合は&lt;code&gt;マーシャリング&lt;/code&gt;が必要となるので結構面倒。&lt;/p&gt;

&lt;p&gt;宣言すれば後は通常のメソッドと同じ様に利用できる。ただし、C側と引数などが異なっていた場合は、
実行時にエラーとなるので注意。&lt;/p&gt;

&lt;p&gt;後は、コンポーネントのライフサイクルと、キャプチャ用とテクスチャのオブジェクトのライフサイクルを一致させればOK。&lt;/p&gt;

&lt;h4 id=&#34;シーン作成&#34;&gt;シーン作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;キャプチャしたテクスチャ用の&lt;code&gt;Material&lt;/code&gt;を作成

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shader&lt;/code&gt;で&lt;code&gt;Unlit/Texture&lt;/code&gt;を選択&lt;br /&gt;
（キャプチャ画像にライトが反映して光らないように）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quad&lt;/code&gt;でテクスチャを貼るオブジェクトを作成

&lt;ul&gt;
&lt;li&gt;Scaleを&lt;code&gt;X:3, Y:4, Z:1&lt;/code&gt;にする&lt;br /&gt;
（数値はキャプチャ画像のアスペクト比と合わせる）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Material&lt;/code&gt;に1で作成したマテリアルをセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プラグインのコンポーネントを追加

&lt;ul&gt;
&lt;li&gt;プラグインの&lt;code&gt;renderTarget&lt;/code&gt;に自身をセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;サンプルでは出てこないけど、C#のアンマネージドの辺りが、ObjCやSwiftに比べると結構大変な気がした。
慣れてないからかも知れないけど、特にメモリ周りやマーシャリングはいずれちゃんと勉強しないと。&lt;/p&gt;

&lt;p&gt;あと、OpenCV周りの細かい挙動もまだ把握しきれていないので調べたい。&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Unity 5.3.4f1&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/UnityOpenCV&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただし、上記ソースには&lt;code&gt;opencv2.framework&lt;/code&gt;が含まれていない。&lt;br /&gt;
（Githubの100MB制限にかかってしまったので）&lt;br /&gt;
動かすには、&lt;code&gt;OpenCVのフレームワークの準備&lt;/code&gt;の項目で準備した
&lt;code&gt;opencv2.framework&lt;/code&gt;を手動で&lt;code&gt;UnityOpenCV/Assets/Plugins/&lt;/code&gt;直下に追加する必要がある。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginxをhttp2に対応させる</title>
      <link>https://mike-neko.github.io/blog/nginx-http2/</link>
      <pubDate>Fri, 03 Jun 2016 21:29:36 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/nginx-http2/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;以前に構築したDockerでの開発環境で使ったnginxを&lt;code&gt;http2&lt;/code&gt;に対応させた時のメモ。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;過去の記事（&lt;a href=&#34;../docker/&#34;&gt;Dockerでの開発環境&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;p&gt;ベースは前回構築したnginx+Dockerで通信はオレオレ証明書によるSSLを前提。&lt;/p&gt;

&lt;p&gt;主な変更点は以下の通り&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;li&gt;nginx 1.10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いずれもhttp2対応させる為にバージョンアップが必要。&lt;/p&gt;

&lt;p&gt;なお、iOSは&lt;strong&gt;iOS9&lt;/strong&gt;からhttp2へ対応している。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;事前準備&#34;&gt;事前準備&lt;/h3&gt;

&lt;p&gt;http2での通信かどうかの確認用に以下のChromeのプラグインを入れておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=ja&#34;&gt;HTTP/2 and SPDY indicator&lt;/a&gt;&lt;br /&gt;
（Firefox用もあるみたいなのでお好きな方で）&lt;/p&gt;

&lt;p&gt;http2での通信だと稲妻が青色になるので確認が楽。&lt;/p&gt;

&lt;h3 id=&#34;macでの作業&#34;&gt;Macでの作業&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OpenSSLを最新にあげる&lt;br /&gt;
OpenSSLの更新方法：&lt;a href=&#34;http://qiita.com/Chrowa3/items/b04e772be959cdda9ac3&#34;&gt;Mac OS X の openssl を最新の状態にする&lt;/a&gt;&lt;br /&gt;
ポイントは&lt;code&gt;upgrade&lt;/code&gt;にすること（普段使う&lt;code&gt;update&lt;/code&gt;ではない）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをアンイストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install nginx --with-http2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxのconfを編集&lt;br /&gt;
&lt;code&gt;HTTPS server&lt;/code&gt;の設定が&lt;code&gt;listen  443 ssl;&lt;/code&gt;となっているはずなので、&lt;code&gt;http2&lt;/code&gt;を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
listen  443 ssl http2;
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追加したらnginxを再起動する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChromeからMacへアクセスしてみて青い稲妻になっていれば&lt;code&gt;nginx&lt;/code&gt;の設定は成功&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ios端末での通信&#34;&gt;iOS端末での通信&lt;/h3&gt;

&lt;p&gt;iOS9以降の&lt;code&gt;NSURLSession&lt;/code&gt;での通信であれば、特に設定など不要で自動で&lt;code&gt;http2&lt;/code&gt;になる。&lt;/p&gt;

&lt;p&gt;なお、規格上は&lt;code&gt;http&lt;/code&gt;のみでも対応しているがiOSでどうかは未検証。&lt;/p&gt;

&lt;h3 id=&#34;ログ設定&#34;&gt;ログ設定&lt;/h3&gt;

&lt;p&gt;iOS端末からの通信も&lt;code&gt;http2&lt;/code&gt;になっているかの確認は、&lt;code&gt;nginx&lt;/code&gt;のログで判別する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http2&lt;/code&gt;の場合は、&lt;code&gt;log_format&lt;/code&gt;の&lt;code&gt;$http2&lt;/code&gt;に&lt;code&gt;h2&lt;/code&gt;と入ってくる。&lt;br /&gt;
詳細は以下のページを参考に&lt;br /&gt;
&lt;a href=&#34;http://d.hatena.ne.jp/ASnoKaze/20150818/1439896998&#34;&gt;nginxでアクセスログにhttp2の通信か出力する&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;過去情報&#34;&gt;過去情報&lt;/h2&gt;

&lt;p&gt;標準の&lt;code&gt;nginx&lt;/code&gt;に&lt;code&gt;http2&lt;/code&gt;モジュールがないと思っていたら、
実はちゃんとあったので訂正。&lt;/p&gt;

&lt;p&gt;もったいないので、&lt;code&gt;nginx-full&lt;/code&gt;の情報を残しておく。&lt;/p&gt;

&lt;h3 id=&#34;nginx-full&#34;&gt;nginx-full&lt;/h3&gt;

&lt;p&gt;通常の&lt;code&gt;Homebrew&lt;/code&gt;の&lt;code&gt;nginx&lt;/code&gt;ではオプションのモジュールが少ないので、
標準では足りないモジュールをインストールしたい時は&lt;code&gt;nginx-full&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;p&gt;例） nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew tap homebrew/nginx
brew install nginx-full --with-http2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールの一覧は以下で確認すること。
（&lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_v2_module.html&#34;&gt;公式&lt;/a&gt;のモジュールの情報?とは違うようなのでこれで確認）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew info nginx-full
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kannokanno.hatenablog.com/entry/2014/02/10/134920&#34;&gt;Mac - homebrewでnginxを入れるときはnginx-fullを入れよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect APNs編</title>
      <link>https://mike-neko.github.io/blog/perfect-push/</link>
      <pubDate>Mon, 11 Apr 2016 19:45:28 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-push/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその3&lt;/p&gt;

&lt;p&gt;今回はiOSのプッシュ通知を送信する方法について&lt;/p&gt;

&lt;p&gt;Perfectは最新のAPNsの通信形式に対応していて、細かなエラーレスポンスを取れるのがメリット。
なので、開発用としては大変使いやすい。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;Push通知はサーバ側で微妙に必要とされる証明書が変わったりするのがややこしいところ。
PerfectでPush通知を送るのに必要なものは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サーバ

&lt;ul&gt;
&lt;li&gt;APNs用証明書と秘密鍵&lt;/li&gt;
&lt;li&gt;CAルート証明書&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;クライアント

&lt;ul&gt;
&lt;li&gt;プロビジョニングプロファイル&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;登録-プロビジョニングプロファイルと証明書の作成&#34;&gt;登録〜プロビジョニングプロファイルと証明書の作成&lt;/h3&gt;

&lt;p&gt;証明書の取得には&lt;code&gt;AppID&lt;/code&gt;の登録やら結構手順があって大変だが、まずは以下のリンク先の通りに作業をすればOK。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Qiita:&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なお、最後の手順の&lt;code&gt;APNs用証明書(.p12)&lt;/code&gt;を書き出す時のファイル名は&lt;code&gt;apns.p12&lt;/code&gt;とする&lt;/p&gt;

&lt;h3 id=&#34;サーバ用の証明書の準備&#34;&gt;サーバ用の証明書の準備&lt;/h3&gt;

&lt;h4 id=&#34;apns用証明書-pem&#34;&gt;APNs用証明書(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_cert.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -clcerts -nokeys -out apns_dev_cert.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;秘密鍵-pem&#34;&gt;秘密鍵(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_key.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -nocerts -out apns_dev_key.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enter PEM pass phrase:&lt;/code&gt;と秘密鍵のパスフレーズを聞かれるので、適当なものを入れる。
後でサーバに設定するので忘れないように・・・&lt;/p&gt;

&lt;h4 id=&#34;caルート証明書&#34;&gt;CAルート証明書&lt;/h4&gt;

&lt;p&gt;APNsとサーバで接続する為に&lt;code&gt;Entrust&lt;/code&gt;の証明書が必要なので、以下からダウンロードする。&lt;/p&gt;

&lt;p&gt;Entrust.net Certificate Authority (2048)：
&lt;a href=&#34;https://www.entrust.com/root-certificates/entrust_2048_ca.cer&#34;&gt;entrust_2048_ca.cer&lt;/a&gt;&lt;br /&gt;
（&lt;a href=&#34;https://www.entrust.com/get-support/ssl-certificate-support/root-certificate-downloads/&#34;&gt;Entrustの証明書DLページ&lt;/a&gt; - Entrust.net Certificate Authority (2048) - Download）&lt;/p&gt;

&lt;h3 id=&#34;iosアプリの作成&#34;&gt;iOSアプリの作成&lt;/h3&gt;

&lt;p&gt;とりあえず、必要最低限でPush通知を受信できる状態にする。
デバイストークンの更新等には未対応なので注意。&lt;/p&gt;

&lt;h4 id=&#34;プロジェクトの設定&#34;&gt;プロジェクトの設定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ダウンロードしたプロビジョニングプロファイルをダブルクリックしてインストール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bundle Identifier&lt;/code&gt;を&lt;code&gt;AppID&lt;/code&gt;取得時のものと一緒にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Provisioning Profile&lt;/code&gt;をインストールしたプロビジョニングプロファイルにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;アプリの実装&#34;&gt;アプリの実装&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;AppDelegate&lt;/code&gt;に以下の実装をする&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;でPush通知の登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRegisterForRemoteNotificationsWithDeviceToken&lt;/code&gt;でデバイストークンを受信&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;コードにすると以下の通り
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/8000f2d8dc5b37773323065e867e2e4d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これを実機上で実行すると、端末のデバイストークンがログ出力される。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;デバッグ実行を停止させると、Push通知が届かない場合があるので、デバッグ実行したままにするか
再度実機上からアクティブにしてバックグラウンドに落としておく。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;また、マルチタスクから終了させても届かない場合があるので、注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;サーバへ証明書の設置&#34;&gt;サーバへ証明書の設置&lt;/h3&gt;

&lt;p&gt;基礎編の&lt;a href=&#34;../perfect-2/&#34;&gt;ビルドでファイルを配置する&lt;/a&gt;の方法で証明書を配置する&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対象のファイル

&lt;ul&gt;
&lt;li&gt;apns_dev_cert.pem&lt;/li&gt;
&lt;li&gt;apns_dev_key.pem&lt;/li&gt;
&lt;li&gt;entrust_2048_ca.cer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Copy Files&lt;/code&gt;の設定

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;:Products Directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subpath&lt;/code&gt;:空白&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（&lt;code&gt;webroot&lt;/code&gt;へのドキュメントの配置とは別に&lt;code&gt;Copy Files&lt;/code&gt;を設定する）&lt;/p&gt;

&lt;h3 id=&#34;サーバの実装&#34;&gt;サーバの実装&lt;/h3&gt;

&lt;p&gt;サーバ側での実装は主に2つ。
ひとつは証明書を&lt;code&gt;NotificationPusher&lt;/code&gt;に初期設定するのと、
もう一つは実際にPush通知を送る実装。&lt;/p&gt;

&lt;p&gt;初期設定は一度だけ行えばOKなので、（実環境では送信毎にチェックした方が良いけど）
今回は&lt;code&gt;PerfectServerModuleInit&lt;/code&gt;で行う。&lt;/p&gt;

&lt;p&gt;Push通知の送信は、&lt;code&gt;IOSNotificationItem&lt;/code&gt;の配列
（ここのenumの使い方は参考になる）で送信内容を作成し、
&lt;code&gt;NotificationPusher().pushIOS&lt;/code&gt;で送信を行う。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/821b3dced86e0eb741563e23c43fed0f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;この実装でサーバにアクセスする度に、Push通知が端末へ送られる。
送信時の結果は、ブラウザに表示される（エラーであればエラー内容）。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回の一番大変だったのはEntrustの証明書の置き場が変わっていたこと。。。
逆に言えばそれ以外はとても簡単にPush通知を送れる環境を作れた感じ。&lt;/p&gt;

&lt;p&gt;巷にはたくさんAPNsに対応したフレームワークやサービスがあるけど、
開発用としては、このPerfectが一番手軽で確実だと思う。
なにせ環境構築は不要で、Xcodeでプロジェクトを作って
少し実装すれば良いだけという素晴らしさ！&lt;/p&gt;

&lt;p&gt;もちろん、商用はAWSとかがオススメだけど。。。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perfect 基礎編&lt;a href=&#34;../perfect-2/&#34;&gt;その2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect 基礎編</title>
      <link>https://mike-neko.github.io/blog/perfect-2/</link>
      <pubDate>Sun, 10 Apr 2016 23:09:11 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-2/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその2&lt;/p&gt;

&lt;p&gt;基礎編ではルーティングやリクエストの処理方法のあたりまで&lt;/p&gt;

&lt;h2 id=&#34;urlルーティング&#34;&gt;URLルーティング&lt;/h2&gt;

&lt;p&gt;サンプルを見ると、ルーティングは大きくわけて&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mustache&lt;/code&gt;テンプレートエンジンのページを&lt;code&gt;PageHandler&lt;/code&gt;に登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Routing&lt;/code&gt;に&lt;code&gt;RequestHandler&lt;/code&gt;を登録&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2種類がある様子。&lt;/p&gt;

&lt;p&gt;設定はいずれも&lt;code&gt;PerfectServerModuleInit()&lt;/code&gt;の中で行う。&lt;/p&gt;

&lt;h3 id=&#34;pagehandlerでのルーティング&#34;&gt;PageHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;Webアプリなどでの固定ページの表示向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/Authenticator/#authenticator&#34;&gt;Authenticator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;http://0.0.0.0:8181/admin/&lt;/code&gt;というページを表示させたい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;表示するページを-mustache-のテンプレートで作成&#34;&gt;表示するページを&lt;code&gt;mustache&lt;/code&gt;のテンプレートで作成&lt;/h4&gt;

&lt;p&gt;例だと&lt;code&gt;admin.mustache&lt;/code&gt;というファイル名にし、先頭のところで&lt;code&gt;handler:AdminHandler&lt;/code&gt;と指定する。&lt;br /&gt;
ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先頭の&lt;code&gt;handler:&lt;/code&gt;の部分で対応する&lt;code&gt;PageHandler&lt;/code&gt;の名前を指定&lt;/li&gt;
&lt;li&gt;ファイル名がアクセスする際のディレクトリと対応&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;テンプレートをプロジェクトへ追加&#34;&gt;テンプレートをプロジェクトへ追加&lt;/h4&gt;

&lt;p&gt;後述の小ネタにある「ドキュメントの配置」の方法で、&lt;code&gt;admin.mustache&lt;/code&gt;がドキュメントルートへ配置されるように設定する。&lt;/p&gt;

&lt;h4 id=&#34;pagehandler-を作成&#34;&gt;&lt;code&gt;PageHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;ページにアクセスがあった時の処理を行う為の&lt;code&gt;PageHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;AdminHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;作ったクラスを&lt;code&gt;PageHandlerRegistry.addPageHandler&lt;/code&gt;で登録する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PageHandlerRegistry.addPageHandler(&amp;quot;AdminHandler&amp;quot;) {
// (r: WebResponse) -&amp;gt; PageHandler in
  return AdminHandler()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addPageHandler&lt;/code&gt;の一つ目の引数の文字列は、テンプレートの中で指定したhandlerと同じにする&lt;/li&gt;
&lt;li&gt;リクエストの詳細な情報で分岐させたい時は、コメントアウトを外し&lt;code&gt;WebResponse&lt;/code&gt;の情報を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;PageHandler&lt;/code&gt;の中では、テンプレートに流し込む変数のDictionaryを生成する。&lt;/p&gt;

&lt;h3 id=&#34;requesthandlerでのルーティング&#34;&gt;RequestHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;APIとかブログのような動的なページ向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/URL%20Routing/#url-routing&#34;&gt;URL Routing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、REST APIで&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;の&lt;code&gt;GET&lt;/code&gt;でmikeというユーザの情報を取得したい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;ルーティングを設定&#34;&gt;ルーティングを設定&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing&lt;/code&gt;でルーティングのルール（HTTPのメソッドやURLなど）を&lt;code&gt;RouteMap&lt;/code&gt;を使って設定する。&lt;/p&gt;

&lt;p&gt;例だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Routing.Routes[&amp;quot;GET&amp;quot;, &amp;quot;/user/{id}&amp;quot;] = { _ in return UserHandler() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPのメソッドが指定できる&lt;br /&gt;
（指定する場合は一つ目にする）&lt;/li&gt;
&lt;li&gt;URL部分は配列で複数指定できる&lt;/li&gt;
&lt;li&gt;ルール部分では&lt;code&gt;{}&lt;/code&gt;で囲うと&lt;code&gt;RequestHandler&lt;/code&gt;へ値を渡せる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;が使える&lt;/li&gt;
&lt;li&gt;クロージャで対応する&lt;code&gt;RequestHandler&lt;/code&gt;を指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;requesthandler-を作成&#34;&gt;&lt;code&gt;RequestHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;クライアントへ返すレスポンスを生成する為の&lt;code&gt;RequestHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;UserHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;URLで指定されたユーザ名をそのままJSONで返す場合は以下の感じ。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/55c5d91b5b1d7a309289f5d0b2a12edd.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これで、&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;にアクセスすると&lt;code&gt;{ user: &amp;quot;mike&amp;quot; }&lt;/code&gt;と返ってくる。&lt;/p&gt;

&lt;h4 id=&#34;ルーティング設定の確認&#34;&gt;ルーティング設定の確認&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing.Routes.description&lt;/code&gt;で設定をダンプできる。これ、かなり便利！&lt;/p&gt;

&lt;h2 id=&#34;リクエストの処理&#34;&gt;リクエストの処理&lt;/h2&gt;

&lt;p&gt;URLパラメータやPOSTのボディの中身は、&lt;code&gt;WebRequest&lt;/code&gt;の中に格納されている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://0.0.0.0:8181/hoge?key1=value1&amp;amp;key2=value2&lt;/code&gt;とした場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  request.queryString()  // key1=value1&amp;amp;key2=value2
  request.queryParams    // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.params()       // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.param(&amp;quot;key1&amp;quot;)  // value1
  request.param(&amp;quot;key3&amp;quot;, defaultValue: &amp;quot;value3&amp;quot;)  // value3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POSTで&lt;code&gt;{ &amp;quot;count&amp;quot;=100 }&lt;/code&gt;を送った場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  let body = request.postBodyString
  let json = try! JSONDecoder().decode(body) as! JSONDictionaryType
  json[&amp;quot;count&amp;quot;]  // 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じで取得できる。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;ドキュメントの配置&#34;&gt;ドキュメントの配置&lt;/h3&gt;

&lt;p&gt;Xcode経由で起動している時に、サーバからドキュメントへアクセスできるようにする方法。なお、ドキュメントルートはデフォルトで&lt;code&gt;./webroot/&lt;/code&gt;が設定されている。&lt;/p&gt;

&lt;h4 id=&#34;documentrootのパスを変更する&#34;&gt;DocumentRootのパスを変更する&lt;/h4&gt;

&lt;p&gt;状況によってはソースから改変するのもアリだが、起動時に立ち上がるGUIから変更するのが手軽。&lt;code&gt;Choose...&lt;/code&gt;でフォルダ位置を選択できる。ただし、注意すべきなのは&lt;code&gt;Document Root&lt;/code&gt;のテキストフィールド内でキー操作(return)しないと変更と認識されずに保存されない点（これにはまってソースまで見てようやく気付いた・・・）。変更後はサーバの再起動が必要（というか勝手にされるはず）。&lt;/p&gt;

&lt;p&gt;この方法だとサーバを起動したままでもドキュメントを変更できるが、一方でパスの設定が必要となる。&lt;/p&gt;

&lt;h4 id=&#34;ビルドでファイルを配置する&#34;&gt;ビルドでファイルを配置する&lt;/h4&gt;

&lt;p&gt;前回の導入編で使った方法で、デフォルトの&lt;code&gt;./webroot/&lt;/code&gt;を使いたい場合用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作成したプロジェクトを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TARGETS&lt;/code&gt;でプロジェクト名と同じもの、&lt;code&gt;Build Phases&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;左上の&lt;code&gt;＋&lt;/code&gt;をクリックして、&lt;code&gt;New Copy Files Phases&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;で&lt;code&gt;Products Directory&lt;/code&gt;を選択&lt;br /&gt;
&lt;code&gt;Subpath&lt;/code&gt;に&lt;code&gt;webroot&lt;/code&gt;と入力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;の下の方にある&lt;code&gt;＋&lt;/code&gt;をクリックし、追加ファイルを選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;
（プロジェクトに未追加のファイルの場合は&lt;code&gt;Add Other...&lt;/code&gt;からで）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;同一lan内からのアクセス&#34;&gt;同一LAN内からのアクセス&lt;/h3&gt;

&lt;p&gt;例えば同じルータに繋がっているiPhoneから、Mac上で動いているPerfectのサーバに接続する方法。&lt;/p&gt;

&lt;p&gt;起動時に立ち上がるGUIの&lt;code&gt;Server Address&lt;/code&gt;をMacに割り当てられているIPアドレスに変更すればOK。
（変更後にreturnで確定を忘れずに・・・）
ポートも変更できるが、&lt;code&gt;80&lt;/code&gt;とかはroot権限が必要と怒られて変更できないので注意。&lt;/p&gt;

&lt;p&gt;（今回は既に&lt;a href=&#34;../docker/&#34;&gt;Docker+nginxを構築&lt;/a&gt;してあったので、nginxのリバースプロキシの設定でさくっと対応）&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;普段、クライアント（iOSアプリ）側で使っている開発環境と全く同じ環境でサーバの開発が出来るというのは、
想像以上に便利というかストレスフリーな感じ。&lt;/p&gt;

&lt;p&gt;もちろん、PerfectではCocoaが使えないというのはあるし、物足りない感じはしなくも無いが。。。&lt;/p&gt;

&lt;p&gt;ただ、そのあたりのカバーを目指しての&lt;code&gt;Perfect&lt;/code&gt;という命名なんだろうと勝手に想像。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chrismanahan.com/creating-a-web-service-swift-perfect&#34;&gt;Creating a Web Service for Your App in Swift with Perfect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Xcode 7.3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect APNs編&lt;a href=&#34;../perfect-push/&#34;&gt;その3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect 導入編</title>
      <link>https://mike-neko.github.io/blog/perfect-1/</link>
      <pubDate>Fri, 08 Apr 2016 22:25:06 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-1/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその1&lt;/p&gt;

&lt;p&gt;導入編ではベースとなるプロジェクトを一から作るあたりまで&lt;/p&gt;

&lt;h2 id=&#34;きっかけ&#34;&gt;きっかけ&lt;/h2&gt;

&lt;p&gt;Perfectがついに1.0になったというのを聞きつけてGitHubのREADMEを見てると、、、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;WebSockets &amp;amp; iOS Push Notifications&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Perfect now includes a &lt;strong&gt;WebSockets&lt;/strong&gt; server and support for handling your own server-side &lt;strong&gt;iOS push notifications&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ってのを発見！&lt;/p&gt;

&lt;p&gt;ちょうど、Push通知周りの実験をしたかったこともあり、さっそく手を出すことに〜&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;下準備&#34;&gt;下準備&lt;/h3&gt;

&lt;h4 id=&#34;github-https-github-com-perfectlysoft-perfect-からperfectをダウンロードする&#34;&gt;&lt;a href=&#34;https://github.com/PerfectlySoft/Perfect&#34;&gt;GitHub&lt;/a&gt;からPerfectをダウンロードする&lt;/h4&gt;

&lt;p&gt;ダウンロードしたら適当な場所に展開しておく&lt;/p&gt;

&lt;h4 id=&#34;xcodeにテンプレートを追加&#34;&gt;Xcodeにテンプレートを追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;~/Library/Developer/Xcode&lt;/code&gt;をFinderで開く&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Xcode&lt;/code&gt;直下に(無ければ)&lt;code&gt;Templates&lt;/code&gt;というフォルダを作成&lt;/li&gt;
&lt;li&gt;その&lt;code&gt;Templates&lt;/code&gt;直下に(無ければ)&lt;code&gt;Project Template&lt;/code&gt;というフォルダを作成&lt;/li&gt;
&lt;li&gt;ダウンロードしておいたPerfectのプロジェクトの中（&lt;code&gt;Perfect-master/Extras/Xcode Templates/Perfect/&lt;/code&gt;）にある&lt;code&gt;Perfect Server Framework.xctemplate&lt;/code&gt;のフォルダを丸ごとコピー&lt;/li&gt;
&lt;li&gt;3で作ったフォルダに4のフォルダを貼り付け&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;プロジェクトの作成&#34;&gt;プロジェクトの作成&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;ワークスペース名：&lt;code&gt;SmapleBasePerfect&lt;/code&gt;&lt;br /&gt;
 プロジェクト名：&lt;code&gt;SampleServer&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
で作成する前提での手順&lt;/p&gt;

&lt;h4 id=&#34;ワークスペースの作成&#34;&gt;ワークスペースの作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;File&lt;/code&gt;-&lt;code&gt;New&lt;/code&gt;-&lt;code&gt;Workspace...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;ワークスペース名と保存先のフォルダを選択(作成)して&lt;code&gt;Save&lt;/code&gt;&lt;br /&gt;
（ワークスペースはプロジェクトと違ってフォルダは自動作成されないので注意）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自動で空のワークスペースの画面が開かれるので、そのままの状態で次の手順へ&lt;/p&gt;

&lt;h4 id=&#34;プロジェクトの作成-1&#34;&gt;プロジェクトの作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;File&lt;/code&gt;-&lt;code&gt;New&lt;/code&gt;-&lt;code&gt;Project...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側の&lt;code&gt;OS X&lt;/code&gt;-&lt;code&gt;Project Template&lt;/code&gt;の中から&lt;code&gt;Perfect Server Framework&lt;/code&gt;を選択して&lt;code&gt;Next&lt;/code&gt;（下図）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/template.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;プロジェクト名などを適宜入力して&lt;code&gt;Next&lt;/code&gt;&lt;br /&gt;
（プロジェクト名はワークスペースと同じにできない）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add to:&lt;/code&gt;でワークスペース名を選択する&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存先を選択して&lt;code&gt;Create&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;デフォルトで下のようなプロジェクトが生成される
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/project.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;h4 id=&#34;perfectを追加&#34;&gt;Perfectを追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;ダウンロードしておいたPerfectのプロジェクト直下にある&lt;code&gt;PerfectLib&lt;/code&gt;と&lt;code&gt;PerfectServer&lt;/code&gt;のフォルダを丸ごとコピー&lt;/li&gt;
&lt;li&gt;プロジェクトのフォルダと同じ階層に貼り付け&lt;/li&gt;
&lt;li&gt;XcodeのProject Navigator(上のイメージの部分)の何もないところで右クリック&lt;/li&gt;
&lt;li&gt;出てきたメニューから&lt;code&gt;Add files to &amp;quot;ワークスペース名&amp;quot;...&lt;/code&gt;を選択&lt;br /&gt;
（もしプロジェクト名が出てきたら3からやり直し）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Copy items into ...&lt;/code&gt;はチェック無、&lt;code&gt;Create groups ...&lt;/code&gt;にチェック有にする&lt;br /&gt;
（無い場合は&lt;code&gt;Option&lt;/code&gt;をクリック）&lt;/li&gt;
&lt;li&gt;1と2でコピーしたフォルダの中から&lt;code&gt;PerfectLib.xcodeproj&lt;/code&gt;を選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PerfectServer.xcodeproj&lt;/code&gt;についても3からの同じ手順で追加&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;スキームの設定&#34;&gt;スキームの設定&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;Product&lt;/code&gt;-&lt;code&gt;Scheme&lt;/code&gt;-&lt;code&gt;Manage Schemes...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;プロジェクト名と同じスキームを選択して&lt;code&gt;Edit...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側で&lt;code&gt;Run&lt;/code&gt;、右側の&lt;code&gt;Info&lt;/code&gt;タグを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executable&lt;/code&gt;で&lt;code&gt;PerfectServer HTTP.app&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;下の方にある&lt;code&gt;Shared&lt;/code&gt;にチェック&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Close&lt;/code&gt;で閉じる&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;フレームワークの追加&#34;&gt;フレームワークの追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;作成したプロジェクトを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TARGETS&lt;/code&gt;でプロジェクト名と同じもの、&lt;code&gt;General&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linked Frameworks and Libraries&lt;/code&gt;の&lt;code&gt;＋&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PerfectLib.framework&lt;/code&gt;で&lt;code&gt;OSX&lt;/code&gt;の方を選択して&lt;code&gt;Add&lt;/code&gt;
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/framework.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ドキュメントを配置&#34;&gt;ドキュメントを配置&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Build Phases&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;左上の&lt;code&gt;＋&lt;/code&gt;をクリックして、&lt;code&gt;New Copy Files Phases&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;で&lt;code&gt;Products Directory&lt;/code&gt;を選択&lt;br /&gt;
&lt;code&gt;Subpath&lt;/code&gt;に&lt;code&gt;webroot&lt;/code&gt;と入力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;の下の方にある&lt;code&gt;＋&lt;/code&gt;をクリックし、&lt;code&gt;index.mustache&lt;/code&gt;を選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;動作確認&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;Xcodeで&lt;code&gt;SampleServer&lt;/code&gt;のスキームで&lt;code&gt;Run&lt;/code&gt;して、GUIが立ち上がるとサーバが動作した状態となる。&lt;/p&gt;

&lt;p&gt;その状態で&lt;code&gt;http://0.0.0.0:8181/&lt;/code&gt;にアクセスして、「Hello, world!」と出ればひとまずOK。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;意外に日本語の、特にMac上で動かす場合の資料が少なくて苦労した。&lt;br /&gt;
それとこういうのを触る度にサーバ周りの知識が足りないのを痛感する・・・&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://code-me-dirty.blogspot.jp/2016/02/creating-perfect-swift-server.html&#34;&gt;Create a Perfect Swift Server Project(from scratch) in Xcode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/SmapleBasePerfect&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perfect 基礎編&lt;a href=&#34;../perfect-2/&#34;&gt;その2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perfect APNs編&lt;a href=&#34;../perfect-push/&#34;&gt;その3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker構築メモ</title>
      <link>https://mike-neko.github.io/blog/docker/</link>
      <pubDate>Mon, 04 Apr 2016 00:35:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/docker/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS用のサーバ環境をDockerでローカルに構築した時のメモ。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、ローカルの開発用ということでセキュリティは考慮していないので注意&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;要件&#34;&gt;要件&lt;/h3&gt;

&lt;p&gt;主にAPIでサーバとやりとりするアプリの開発用なので以下の感じ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHPとDBが使えること&lt;/li&gt;
&lt;li&gt;同一LAN内の別の端末からアクセスできること&lt;/li&gt;
&lt;li&gt;SSLが使えること（iOS用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;h4 id=&#34;構成イメージ&#34;&gt;構成イメージ&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Mac   (192.168.0.2) == ルータ(192.168.0.1) == iPhone(192.168.0.3)  
｜  
VM    (192.168.99.1)  
｜  
Docker(192.168.99.100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;()内はIPアドレス&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ゴールは、iPhone上から&lt;code&gt;https://192.168.0.2&lt;/code&gt;へアクセスするとページが表示(APIの通信)できればOK。&lt;/p&gt;

&lt;h4 id=&#34;mac上-ホストos&#34;&gt;Mac上(ホストOS)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;MacOS 10.11.3(El Capitan)&lt;/li&gt;
&lt;li&gt;VirtualBox 5.0.14&lt;/li&gt;
&lt;li&gt;DockerToolBox 1.10.2&lt;/li&gt;
&lt;li&gt;nginx 1.8.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;docker上-ゲストos&#34;&gt;Docker上(ゲストOS)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;PHP 5系の最新&lt;br /&gt;
(Xdebug)&lt;/li&gt;
&lt;li&gt;MariaDB&lt;br /&gt;
(phpmyadmin)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;手順&#34;&gt;手順&lt;/h1&gt;

&lt;h3 id=&#34;dockerのインストール&#34;&gt;Dockerのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/products/docker-toolbox&#34;&gt;公式&lt;/a&gt;から&lt;code&gt;DockerToolBox&lt;/code&gt;をダウンロードしてインストールを実行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;途中で&lt;code&gt;Docker Quickstart Terminal&lt;/code&gt;のアイコンがでてきたら起動させる&lt;br /&gt;
（忘れたらアプリケーションにもあるのでそちらから）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;すると勝手にVM作成やらネットワーク設定をしてくれる親切設計なのでクジラが出てくるまで待つ&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;dockercomposeの設定&#34;&gt;DockerComposeの設定&lt;/h3&gt;

&lt;p&gt;Dockerはコンテナをパーツのように組み合わせて環境を作っていく。&lt;/p&gt;

&lt;p&gt;そのコンテナを作成する際の基本的な流れは&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使いたいもののイメージを見つける&lt;br /&gt;
(無ければ&lt;code&gt;Dockerfile&lt;/code&gt;を自力で書く)&lt;/li&gt;
&lt;li&gt;タグを指定してイメージをダウンロード&lt;/li&gt;
&lt;li&gt;コンテナの作成&lt;br /&gt;
(もし足りない設定などあれば&lt;code&gt;Dockerfile&lt;/code&gt;でカスマイズ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;p&gt;イメージの検索からコンテナの取得は公式GUIの&lt;code&gt;Kitematic (Beta)&lt;/code&gt;を使うと一気にしてくれるので便利。&lt;/p&gt;

&lt;p&gt;ただ、この方法だと引数の指定が多かったり複数のコンテナを利用する場合は大変なので、
&lt;code&gt;DockerCompose&lt;/code&gt;を用いて管理する。&lt;/p&gt;

&lt;h4 id=&#34;事前準備&#34;&gt;事前準備&lt;/h4&gt;

&lt;p&gt;まずは適当な場所に、コンテナ毎の&lt;code&gt;Dockerfile&lt;/code&gt;や設定ファイルなどを
まとめておくディレクトリを作ってカレントディレクトリとする。
今回のディレクトリ構成は、以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker
 ├─ docker-compose.yml
 ├─ mariadb              # MariaDB用のフォルダ
 |   └─ my.cnf
 ├─ php                  # PHP用のフォルダ
 |   ├─ Dockerfile
 |   └─ php.ini
 └─ www                  # Apacheのドキュメントルート
     └─ index.html       # 動作確認用のHTML
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;apache-php&#34;&gt;Apache+PHP&lt;/h4&gt;

&lt;p&gt;ApacheはPHPに同梱されているものを使うのが便利なので、&lt;code&gt;apache&lt;/code&gt;がついているタグのものを使う。
今回は&lt;a href=&#34;https://hub.docker.com/_/php/&#34;&gt;公式&lt;/a&gt;で5系の一番新しいバージョンの&lt;code&gt;5.6.18-apache&lt;/code&gt;を選択。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;php.ini&lt;/code&gt;の設定と追加で入れたい拡張モジュール（特に&lt;code&gt;Xdebug&lt;/code&gt;）を&lt;code&gt;Dockerfile&lt;/code&gt;でカスタムしておく。&lt;/p&gt;

&lt;p&gt;DockerComposeの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php:
  build: ./php/　　　　　　　　# php/Dockerfileからビルド
  ports:
    - &amp;quot;80:80&amp;quot;　　　　　　　　　# 80ポートを公開
  volumes:
    - ./www:/var/www/html   # ドキュメントルートを指定
  links:
    - mariadb:mysql         # DBとの接続を指定
  container_name: php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでMac上からは、&lt;code&gt;http://192.168.99.100/index.html&lt;/code&gt;へアクセスすると、
&lt;code&gt;www/index.html&lt;/code&gt;が表示される。&lt;/p&gt;

&lt;h4 id=&#34;mariadb-phpmyadmin&#34;&gt;MariaDB+phpMyAdmin&lt;/h4&gt;

&lt;p&gt;特に変更点もないのでイメージは公式の最新をそのままを使う。&lt;/p&gt;

&lt;p&gt;DockerComposeの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mariadb:
  image: mariadb:latest           # 常に最新版を使う
  environment:
    MYSQL_ROOT_PASSWORD: pass     # ルートのパスワード
    MYSQL_DATABASE: docker        # DB名
    MYSQL_USER: docker            # ユーザ名
    MYSQL_PASSWORD: docker        # パスワード
  volumes:                        # my.cnfの設定
    - ./mariadb/my.cnf:/etc/mysql/conf.d/my.cnf
  container_name: mariadb

phpmyadmin:
  image: phpmyadmin/phpmyadmin:latest
  container_name: myadmin
  ports:
    - &amp;quot;8080:80&amp;quot;                   # 8080ポートを公開して80へフォワード
  links:
    - mariadb:db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでMac上からは、&lt;code&gt;http://192.168.99.100:8080&lt;/code&gt;へアクセスすると、
&lt;code&gt;phpMyAdmin&lt;/code&gt;のログイン画面が表示され、&lt;code&gt;docker/docker&lt;/code&gt;でログインが可能。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意点としてこの状態ではDBの永続化はできていないので、コンテナを削除するとDBの内容も消える&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;ios端末からのアクセス&#34;&gt;iOS端末からのアクセス&lt;/h3&gt;

&lt;p&gt;ここまでの状態だとMacからしかアクセスできないので、Mac上で&lt;code&gt;nginx&lt;/code&gt;をリバースプロキシとして動かし、
他のiOS端末からアクセスできるようにする。&lt;/p&gt;

&lt;p&gt;また、iOS9のATSへ対応する為にSSLでアクセスできるようにする。ただしローカル環境なのでオレオレ証明書を利用する。&lt;/p&gt;

&lt;h4 id=&#34;nginxのインストール&#34;&gt;nginxのインストール&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Homebrew&lt;/code&gt;でインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールできたら、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx -t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で設定ファイルの場所を確認し、適当なエディタで開いてリバースプロキシの設定をする。
コメントにしてあるのがデフォルトの設定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
  server {
    #listen       8080;
    listen       80;
    location / {
      # root   html;
      # index  index.html index.htm;
      proxy_pass http://127.0.0.1:8080;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sslの証明書について&#34;&gt;SSLの証明書について&lt;/h4&gt;

&lt;p&gt;今回はnginx部分だけSSLに対応させる。（dockerはHTTPのまま）&lt;/p&gt;

&lt;p&gt;オレオレ証明書作成のiOS向けの設定のポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SHA256で証明書を作成する&lt;br /&gt;
(デフォルトだとSHA1になる)&lt;/li&gt;
&lt;li&gt;Safari以外からアクセスする場合は、証明書作成時のCommonNameをIPアドレスにする&lt;br /&gt;
(つまりIP固定が必要)&lt;/li&gt;
&lt;li&gt;端末へ証明書のインストールが必要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もし、上の条件が満たせない場合は、ATSの設定を変えるとか個別に認証処理を書くなどして回避する必要がある。
（回避できないのもあるけど）&lt;/p&gt;

&lt;h4 id=&#34;sslの証明書の作成&#34;&gt;SSLの証明書の作成&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out server.key 2048 -sha256
openssl req -new -sha256 -key server.key &amp;gt; server.csr
openssl x509 -days 3650 -sha256 -req -signkey server.key &amp;lt; server.csr &amp;gt; server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（オレオレ証明書の各項目は&lt;code&gt;CommonName&lt;/code&gt;以外は空白でも動作する）&lt;/p&gt;

&lt;p&gt;生成された&lt;code&gt;server.key&lt;/code&gt;と&lt;code&gt;server.crt&lt;/code&gt;をnginxの設定ファイルと同じディレクトリに置く。&lt;/p&gt;

&lt;p&gt;iOS端末へは&lt;code&gt;server.crt&lt;/code&gt;をインストールする。
（メール添付か適当なWEB上に置いてインストール）&lt;/p&gt;

&lt;p&gt;nginxの設定ファイルに以下を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
  listen       443 ssl;
  server_name  localhost;

  ssl_certificate      server.crt;
  ssl_certificate_key  server.key;

  location / {
    proxy_pass http://127.0.0.1:8080;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vmの設定&#34;&gt;VMの設定&lt;/h4&gt;

&lt;p&gt;DockerはVirtualBox上で動いているので、VMのポートフォワードを設定が必要となる。
設定は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VBoxManage controlvm &amp;quot;default&amp;quot; natpf1 &amp;quot;nginx,tcp,127.0.0.1,8080,,80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする。VirtualBoxを起動して、&lt;code&gt;default-設定-ネットワーク-アダプター1-ポートフォワーディング&lt;/code&gt;からでもOK。&lt;/p&gt;

&lt;h2 id=&#34;起動&#34;&gt;起動&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dockerを起動させる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;を置いた場所をカレントディレクトリにする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt;でコンテナを起動&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo nginx&lt;/code&gt;でnginxを起動&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでiPhone上からは、&lt;code&gt;https://192.168.0.2/index.html&lt;/code&gt;へアクセスすると、
&lt;code&gt;www/index.html&lt;/code&gt;が表示される。
（ただし、オレオレ証明書なので認証の警告などは出る）&lt;/p&gt;

&lt;h1 id=&#34;追記&#34;&gt;追記&lt;/h1&gt;

&lt;p&gt;Docker起動時に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: Couldn&#39;t connect to Docker daemon - you might need to run `docker-machine start default`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーが出る場合は、VMの設定の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VBoxManage controlvm &amp;quot;default&amp;quot; natpf1 &amp;quot;nginx,tcp,127.0.0.1,8080,,80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をしてから起動し直すと大丈夫っぽい。なお、原因は不明・・・&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;開発環境をプラグインみたいな感じで構築していけるのと構築内容がテキストで残るのはあとあと楽。&lt;/p&gt;

&lt;p&gt;ただ、サーバ環境とまるまる同じものを構築するならVagrantの方が良いのかも・・・
でも、Dockerはいろいろな環境を次々に試すのには便利なので、使い分けが大事そう。&lt;/p&gt;

&lt;h1 id=&#34;ファイル一式&#34;&gt;ファイル一式&lt;/h1&gt;

&lt;p&gt;実際の各イメージのDockerfileや設定ファイルをまとめたものは
&lt;a href=&#34;https://github.com/mike-neko/Docker/tree/master/SSLWebServer&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dockerのコマンド備忘録</title>
      <link>https://mike-neko.github.io/blog/docker-cmd/</link>
      <pubDate>Sat, 02 Apr 2016 14:00:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/docker-cmd/</guid>
      <description>

&lt;h2 id=&#34;dockerでよく使うコマンド&#34;&gt;Dockerでよく使うコマンド&lt;/h2&gt;

&lt;h3 id=&#34;イメージ操作&#34;&gt;イメージ操作&lt;/h3&gt;

&lt;h4 id=&#34;イメージのリスト表示&#34;&gt;イメージのリスト表示&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;指定したイメージの削除&#34;&gt;指定したイメージの削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi [イメージの名前かID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージの指定は&lt;code&gt;IMAGE ID&lt;/code&gt;の先頭数文字での特定が便利&lt;/p&gt;

&lt;h4 id=&#34;イメージの全削除&#34;&gt;イメージの全削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ操作&#34;&gt;コンテナ操作&lt;/h3&gt;

&lt;h4 id=&#34;コンテナのリスト表示&#34;&gt;コンテナのリスト表示&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;全部停止&#34;&gt;全部停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;全部削除&#34;&gt;全部削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dockercompose&#34;&gt;DockerCompose&lt;/h3&gt;

&lt;h4 id=&#34;起動&#34;&gt;起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;cd [docker-copose.ymlを置いてる場所]
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで&lt;code&gt;build&lt;/code&gt;と&lt;code&gt;pull&lt;/code&gt;と&lt;code&gt;run&lt;/code&gt;を一気にしてくれる&lt;/p&gt;

&lt;h4 id=&#34;停止&#34;&gt;停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker-compose stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nginx&#34;&gt;nginx&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;80ポートを使う場合はsudoが必要&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;起動-1&#34;&gt;起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;停止-1&#34;&gt;停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx -s stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;再起動&#34;&gt;再起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;php&#34;&gt;PHP&lt;/h2&gt;

&lt;h3 id=&#34;オプション&#34;&gt;オプション&lt;/h3&gt;

&lt;h4 id=&#34;docker-php-ext-installで指定できるもの&#34;&gt;docker-php-ext-installで指定できるもの&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bcmath bz2 calendar ctype curl dba dom enchant exif fileinfo filter ftp gd gettext gmp hash iconv imap interbase intl json ldap mbstring mcrypt mssql mysql mysqli oci8 odbc opcache pcntl pdo pdo_dblib pdo_firebird pdo_mysql pdo_oci pdo_odbc pdo_pgsql pdo_sqlite pgsql phar posix pspell readline recode reflection session shmop simplexml snmp soap sockets spl standard sybase_ct sysvmsg sysvsem sysvshm tidy tokenizer wddx xml xmlreader xmlrpc xmlwriter xsl zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(デフォルトのPHPイメージは最低限の状態なのでDockerfileで指定して追加する)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPアドレス取得のサンプル(Swift)</title>
      <link>https://mike-neko.github.io/blog/ipaddress/</link>
      <pubDate>Mon, 07 Mar 2016 23:59:45 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/ipaddress/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のIPアドレスを取得するサンプル。Cの関数呼び出し周りも含めてSwiftにて実装。&lt;/p&gt;

&lt;p&gt;一応、Apple公式の方法でIPv6only環境でも動作確認済。&lt;/p&gt;

&lt;h3 id=&#34;実装概要&#34;&gt;実装概要&lt;/h3&gt;

&lt;p&gt;アドレス取得の実装は&lt;code&gt;NetworkInfo&lt;/code&gt;にまとまっている。
実装の中身自体はよくあるIPアドレスの取得のコード。&lt;/p&gt;

&lt;p&gt;サンプルでは、IPアドレスの一覧を取得して&lt;code&gt;TableView&lt;/code&gt;に表示している。&lt;/p&gt;

&lt;p&gt;細かい点は実際のソースを参照のこと。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;cの関数呼び出し&#34;&gt;Cの関数呼び出し&lt;/h3&gt;

&lt;p&gt;端末内部のネットワーク情報を取得する為に、&lt;code&gt;getifaddrs&lt;/code&gt;や&lt;code&gt;inet_ntop&lt;/code&gt;などの関数を呼び出すが、
通常のCであればファイルの頭で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ifaddrs.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするが、Swiftなので&lt;code&gt;Bridging-Header.h&lt;/code&gt;を用意して、そこに&lt;code&gt;include&lt;/code&gt;を書く。&lt;/p&gt;

&lt;p&gt;あと、ヘッダを追加した後にはビルド設定の&lt;code&gt;Objective-C Bridging Header&lt;/code&gt;も忘れずに変更。&lt;/p&gt;

&lt;h3 id=&#34;デバイス&#34;&gt;デバイス&lt;/h3&gt;

&lt;p&gt;とりあえず今回は、IPアドレスを取りたいだけなので、WiFi(&lt;code&gt;en0&lt;/code&gt;)とCellular(&lt;code&gt;pdp_ip0&lt;/code&gt;)の
デバイスのみチェックしている。&lt;/p&gt;

&lt;h3 id=&#34;swiftの言語的なこと&#34;&gt;Swiftの言語的なこと&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;がとっても便利。これのおかげでリソースの解放のような後始末が必要なコードが、
とても簡単にかけるし処理漏れもなくなるので素晴らしい！&lt;br /&gt;
(これが無いと今回のように処理の中でエラーで返すような場合はコードが面倒になる)&lt;/p&gt;

&lt;p&gt;ポインタが見えなくなったり、型が厳格になってC系のソースの移植が面倒に思えるけど、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対応する型への変換（特に&lt;code&gt;UnsafePointer&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;C++の&lt;code&gt;-&amp;gt;&lt;/code&gt;に相当するのが&lt;code&gt;memory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;[]&lt;/code&gt;に相当するのが&lt;code&gt;advancedBy&lt;/code&gt;(今回は出てこないけど)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と言ったあたりを押さえておけばOKな気がする。&lt;/p&gt;

&lt;p&gt;確かに冗長な感じは否めないが、型は書かなくても済むことが多いし、
逆に一度正しく変換しておけば後はコンパイラで型チェックが行われるのは安心できる。&lt;/p&gt;

&lt;p&gt;この辺りのバランス感覚がSwiftは絶妙だと思う。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html&#34;&gt;IPv6only環境の確認方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html&#34;&gt;CのAPIをSwiftで使う方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;li&gt;Mac OS 10.11.3(NAT64ネットワーク)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/NetworkInfo&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>