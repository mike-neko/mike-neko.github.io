<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/post/</link>
    <description>Recent content in Posts on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Wed, 07 Dec 2016 19:18:57 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Provisioning Profileの有効期限をアプリ内で取得</title>
      <link>https://mike-neko.github.io/blog/provisioning/</link>
      <pubDate>Wed, 07 Dec 2016 19:18:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/provisioning/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AdHoc&lt;/code&gt;で作成したiOSアプリ(ipa)にはプロビジョニングプロファイルの有効期限が存在するが、
その有効期限をアプリ内から確認する方法&lt;/p&gt;

&lt;p&gt;確認自体はipaを解凍して見れば良いのだけど、エンタープライズの様にアプリ内で出したい場合は、
この方法であらかじめ設定画面とかに仕込むと良いかもしれない&lt;/p&gt;

&lt;p&gt;もちろん&lt;code&gt;Settings.bundle&lt;/code&gt;や直接アプリ内にリテラルとして持たすのも方法の一つだが、
それだと更新の度に余分な作業が発生したり更新忘れとかのミスも発生したりしがちなので、
この方法に行き着いた感じ&lt;/p&gt;

&lt;p&gt;（プロビジョニングプロファイルはアーカイブ時に確定されるので、
アプリバージョンのようにビルドスクリプトに仕込んでといった技は使えない。
Xcode7以前はdryrunでビルド設定を出力させてそこから特定ということもできたが、
Xcode8からの自動にした場合は使えないっぽい）&lt;/p&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;ipa作成時のプロビジョニングプロファイルについてまとめると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;プロビジョニングプロファイルの中身はほぼ&lt;code&gt;plist&lt;/code&gt;(XML)&lt;/li&gt;
&lt;li&gt;有効期限はプロビジョニングプロファイルの中の&lt;code&gt;ExpirationDate&lt;/code&gt;に&lt;code&gt;Date&lt;/code&gt;(NSDate)で記載&lt;/li&gt;
&lt;li&gt;プロビジョニングプロファイルはアプリのパッケージの中に
&lt;code&gt;embedded.mobileprovision&lt;/code&gt;という名前で同梱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを踏まえてコードにすると、以下の感じになる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/bdbedbb280883dff96b6a5a7062c67bd.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;まずは1行目にあるように、同梱されているプロビジョニングを取得する&lt;br /&gt;
&lt;strong&gt;デバッグ実行時には正しく取得できないので注意！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;次に5〜14行目にあるように、&lt;code&gt;plist&lt;/code&gt;として必要な部分のみに加工。
（不要部分があると変換に失敗するので）&lt;br /&gt;
抜き出したら&lt;code&gt;PropertyListSerialization&lt;/code&gt;で&lt;code&gt;Dictionary&lt;/code&gt;に変換して有効期限を抜き出す&lt;/p&gt;

&lt;p&gt;あとは、画面に表示させる為に文字列に変換してやって完了
（例では余裕を持って1日前の日付にしている）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>multipart/form-dataによるファイルのアップロード</title>
      <link>https://mike-neko.github.io/blog/multipart/</link>
      <pubDate>Tue, 06 Dec 2016 22:04:28 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/multipart/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;（&lt;code&gt;Alamofire&lt;/code&gt;とかのライブラリを使った方が幸せになれると思うが）
HTMLのフォームからの送信と同じ様な&lt;code&gt;multipart&lt;/code&gt;によるアップロードをiOSからする方法&lt;/p&gt;

&lt;h2 id=&#34;要件&#34;&gt;要件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;タイトル（文字列）とファイルを一緒にサーバへアップロード&lt;/li&gt;
&lt;li&gt;アップロード先は同じホストの&lt;code&gt;upload.php&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;サーバからはjsonで結果が返ってくる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;htmlの場合&#34;&gt;HTMLの場合&lt;/h2&gt;

&lt;p&gt;上記要件でかつアップロードと同じ画面内で結果を表示させたい場合、
&lt;code&gt;jQuery&lt;/code&gt;などを全く使わずに素のHTMLで書くと&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/9c53de2d62a4be94dd26131479b52c6f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;もし、ajaxではなく送信結果は次の画面で表示させる様な場合だと&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;タグは
&lt;code&gt;&amp;lt;form name=&amp;quot;upload&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;&lt;/code&gt;
とする必要がある&lt;/p&gt;

&lt;h2 id=&#34;iosの場合&#34;&gt;iOSの場合&lt;/h2&gt;

&lt;p&gt;もし単一のファイルのアップロードだけなら、&lt;code&gt;URLSession&lt;/code&gt;の&lt;code&gt;uploadTask(with:〜&lt;/code&gt;でOKだが、
他のデータやファイルも付加したい場合は自分で&lt;code&gt;multipart&lt;/code&gt;のリクエストを生成する必要がある&lt;/p&gt;

&lt;p&gt;とりあえずHTMLと同じものをベタ書き(+エラー省略)すると、&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/3825cf1ea22cb4f1a1469a33c44097ff.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;boundary文字列&#34;&gt;boundary文字列&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;multipart&lt;/code&gt;の場合、データの区切りを表すためにデータ内に含まれない様なバウンダリ文字列が必要となる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let boundary = String(format: &amp;quot;----iOSURLSessionBoundary.%08x%08x&amp;quot;, arc4random(), arc4random())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は&lt;code&gt;Alamofire&lt;/code&gt;を参考に送信元のプログラムとランダムな数字を組合せた文字列を生成している&lt;/p&gt;

&lt;h3 id=&#34;bodyの生成&#34;&gt;bodyの生成&lt;/h3&gt;

&lt;p&gt;フォームのデータの場合の構造は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)[CRLF]
Content-Disposition: form-data; name=&amp;quot;フォームの名前&amp;quot;[CRLF]
[CRLF]
(フォームのデータ)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;ファイルの場合の構造は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)[CRLF]
Content-Disposition: form-data; name=&amp;quot;フォームの名前&amp;quot;; filename=&amp;quot;ファイル名&amp;quot;[CRLF]
Content-Type: &amp;quot;ファイルのタイプ&amp;quot;[CRLF]
[CRLF]
(ファイルのデータ)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;各構造をバイナリ(&lt;code&gt;Data&lt;/code&gt;型)にしたものを必要な分だけ組合せて、最後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--(バウンダリ文字列)--[CRLF]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をつけたものがbody部分のデータとなる&lt;/p&gt;

&lt;p&gt;今回の例だとフォームデータが一つとファイルデータが一つなので、
それぞれ一つずつを追加し最後にフッタを付けたものをbodyに入れている&lt;/p&gt;

&lt;h3 id=&#34;headerの生成&#34;&gt;headerの生成&lt;/h3&gt;

&lt;p&gt;フィールドにセットすべきなのは以下の2つ&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ldquo;Content-Type&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Content-Length&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;Content-Type&lt;/code&gt;にはタイプとバウンダリ文字列を以下のように指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;multipart/form-data; boundary=（バウンダリ文字列）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;は普通にbodyのサイズを入れればOK&lt;/p&gt;

&lt;h3 id=&#34;送信&#34;&gt;送信&lt;/h3&gt;

&lt;p&gt;送信は&lt;code&gt;uploadTask&lt;/code&gt;だと&lt;code&gt;multipart&lt;/code&gt;指定ができないので&lt;code&gt;dataTask&lt;/code&gt;で行う。
それ以外は通常の&lt;code&gt;dataTask&lt;/code&gt;のやり方でOK&lt;/p&gt;

&lt;h2 id=&#34;参考-サーバの処理-php&#34;&gt;参考：サーバの処理(PHP)&lt;/h2&gt;

&lt;p&gt;今回サーバ側で検証用に使ったのは以下のソース&lt;br /&gt;
（送信されてきたファイルはそのまま専用のディレクトリに格納し結果をJSONで返すだけ）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// &amp;quot;upload&amp;quot;のディレクトリに書き込み権限が必要
$dir = __DIR__ . &#39;/upload/&#39;;
$path = $dir . basename($_FILES[&#39;filename&#39;][&#39;name&#39;]);

$data[&#39;result&#39;] = &#39;アップロード失敗&#39;;
if (move_uploaded_file($_FILES[&#39;filename&#39;][&#39;tmp_name&#39;], $path)) {
    chmod($path, 0666);
    $data[&#39;result&#39;] = date(&amp;quot;H:i:s&amp;quot;) . &#39; &#39; . $_POST[&#39;title&#39;] . &#39; アップロード成功&#39;;
}

header(&#39;Content-Type: application/json&#39;);
echo json_encode($data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式：&lt;a href=&#34;http://php.net/manual/ja/features.file-upload.post-method.php&#34;&gt;POST メソッドによるアップロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MDN公式：&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/Guide/Using_FormData_Objects&#34;&gt;FormData オブジェクトの利用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;li&gt;PHP 7&lt;/li&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>WebRTCをiOSネイティブで使う(実装編)</title>
      <link>https://mike-neko.github.io/blog/webrtc-ios/</link>
      <pubDate>Wed, 30 Nov 2016 01:38:22 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/webrtc-ios/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSで&lt;code&gt;WebRTC&lt;/code&gt;を使ったビデオチャットを作る方法&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../webrtc-build&#34;&gt;準備編&lt;/a&gt;を参考にフレームワークを組み込む&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt;に以下を書き込む（※）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Privacy - Camera Usage Description&lt;/code&gt;（カメラを使うのに必要）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Privacy - Microphone Usage Description&lt;/code&gt;（マイクを使うのに必要）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;※iOS10から必須。ないとアプリが強制終了する。
それぞれの値は使う理由の説明を入れておく&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;シグナリング&#34;&gt;シグナリング&lt;/h2&gt;

&lt;p&gt;WebRTCはP2P通信なので何らかの方法で相手と端末(&lt;code&gt;Peer&lt;/code&gt;)や
通信経路(&lt;code&gt;ICE Candidate&lt;/code&gt;)の情報をやり取りする必要がある&lt;/p&gt;

&lt;p&gt;つまり、何らかのWebRTCとは別の方法で端末間の通信を確立させておくことが必要となる&lt;/p&gt;

&lt;p&gt;といってもテキストベースの情報をやり取りできれば良いので、
特にややこしい訳ではない（もちろん接続管理はそれなりに必要だが）ので、
node.jsのsocket.ioで自前のサーバを立てるのも良いし、
サービスとして提供されているサーバを介してやりとりしても良い&lt;/p&gt;

&lt;p&gt;今回のサンプルでは完全にローカルなネットワークで、かつ、iOS同士限定なので
サーバが不要な&lt;code&gt;Multipeer Connectivity Framework&lt;/code&gt;を使っている
（詳細は&lt;a href=&#34;../multipeer/&#34;&gt;こちら&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;ビデオチャットは1対1で動画と音声をやりとりするタイプとする&lt;/p&gt;

&lt;p&gt;&lt;em&gt;生成したコネクション(&lt;code&gt;RTCPeerConnection&lt;/code&gt;)とローカル / リモートストリーム(&lt;code&gt;RTCMediaStream&lt;/code&gt;)はクラスのプロパティにして、
必ずstrongで保持されるようにしておくこと&lt;br /&gt;
これを忘れると正常に接続ができていても画像が出ない原因となるので注意！&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;接続の準備&#34;&gt;接続の準備&lt;/h3&gt;

&lt;p&gt;最初に自分が相手に送る動画と音声のストリームを準備する。
なお、カメラへのアクセスやカメラのライブ映像の表示はほぼフレームワークがカバーしてくれる&lt;/p&gt;

&lt;h4 id=&#34;ローカルストリームの生成&#34;&gt;ローカルストリームの生成&lt;/h4&gt;

&lt;p&gt;ビデオ（ライブ映像）ストリームを生成して端末のカメラと紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let factory = RTCPeerConnectionFactory()
localStream = factory.mediaStream(withStreamId: &amp;quot;MIKE-VIDEOCHAT&amp;quot;)
let video = factory.avFoundationVideoSource(with: nil)
let track = factory.videoTrack(with: video, trackId: &amp;quot;MIKE-VIDEOCHAT-V0&amp;quot;)
localStream.addVideoTrack(track)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オーディオ（音声）ストリームを生成する
（こちらは特に指定しなくても端末のマイクと紐付けされるみたい）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localStream.addAudioTrack(factory.audioTrack(withTrackId: &amp;quot;MIKE-VIDEOCHAT-A0&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;表示用のビューの生成&#34;&gt;表示用のビューの生成&lt;/h4&gt;

&lt;p&gt;相手に送信している映像を確認できるよう、表示用のView
(&lt;code&gt;RTCEAGLVideoView&lt;/code&gt;というOpenGLを利用して動画を表示する専用のView)
と端末のカメラを紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// localView: ViewController内に置いた表示用ビューのコンテナ
let local = RTCEAGLVideoView(frame: localView.bounds)
localView.addSubview(local)
track.add(local)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで端末のフロントカメラの映像が自動で表示されるようになる&lt;/p&gt;

&lt;h4 id=&#34;接続の生成&#34;&gt;接続の生成&lt;/h4&gt;

&lt;p&gt;ビデオチャットなのでVideoとAudioを必須と指定して&lt;code&gt;RTCPeerConnection&lt;/code&gt;を生成する。
またローカルストリームを接続と紐づけて相手に送信できるようにする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// peer: RTCPeerConnection
let constraints = RTCMediaConstraints(
  mandatoryConstraints: [&amp;quot;OfferToReceiveVideo&amp;quot;: kRTCMediaConstraintsValueTrue,
                         &amp;quot;OfferToReceiveAudio&amp;quot;: kRTCMediaConstraintsValueTrue],
   optionalConstraints: nil)
peer = factory.peerConnection(with: RTCConfiguration(),
                       constraints: constraints,
                          delegate: self)
peer.add(localStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;接続の開始&#34;&gt;接続の開始&lt;/h3&gt;

&lt;p&gt;接続の準備ができればシグナリングを行なって相手と接続を確立させる&lt;/p&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;端末Aがofferを送信&lt;/li&gt;
&lt;li&gt;端末Bが端末Aのofferを受信&lt;/li&gt;
&lt;li&gt;端末Bが端末Aへanswerを送信&lt;/li&gt;
&lt;li&gt;端末Aが端末Bのanswerを受信&lt;/li&gt;
&lt;li&gt;ICEをやりとりしてP2Pで接続を確立&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;h4 id=&#34;端末a-offerの送信&#34;&gt;[端末A] offerの送信&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;peer.offer&lt;/code&gt;で生成したローカルの情報を&lt;code&gt;peer.setLocalDescription&lt;/code&gt;で設定すると、
offerとなる&lt;code&gt;SDP&lt;/code&gt;（Peerの情報）が取得できるので、それを相手へ送信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peer.offer(for: constraints) { (description, error) in
  guard let localDescription = description, error == nil else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
  self.peer.setLocalDescription(localDescription) { error in
    guard error == nil,
          let state = self.peer.signalingState,
          case .haveLocalOffer = state else {
      print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
      return
    }
    // localDescription.sdp(=offer)を相手へ送信する
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;端末b-offerの受信-answerの送信&#34;&gt;[端末B] offerの受信 / answerの送信&lt;/h4&gt;

&lt;p&gt;受信した&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCSessionDescription&lt;/code&gt;でリモートの情報を生成し&lt;code&gt;peer.setRemoteDescription&lt;/code&gt;で設定する&lt;/p&gt;

&lt;p&gt;offerを正常に設定できれば、&lt;code&gt;peer.answer&lt;/code&gt;でローカルの情報を生成し&lt;code&gt;peer.setLocalDescription&lt;/code&gt;で設定すると、
answerとなる&lt;code&gt;SDP&lt;/code&gt;が取得できるので、それを相手へ返信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sdp: 受信した端末Aのoffer
let remoteDescription = RTCSessionDescription(type: .offer, sdp: sdp)
peer.setRemoteDescription(remoteDescription) { error in
  guard error == nil,
        let state = self.peer.signalingState, 
        case .haveRemoteOffer = state else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
  self.peer.answer(for: constraints) { (description, error) in
    guard let localDescription = description, error == nil else {
      print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
      return
    }
    self.peer.setLocalDescription(localDescription) { error in
      guard error == nil else {
        print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
        return
      }
      // localDescription.sdp(=answer)を相手へ送信する
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;端末a-answerの受信&#34;&gt;[端末A] answerの受信&lt;/h4&gt;

&lt;p&gt;相手から返信された&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCSessionDescription&lt;/code&gt;でリモートの情報を生成し&lt;code&gt;peer.setRemoteDescription&lt;/code&gt;で設定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sdp: 受信した端末Bのanswer
let remoteDescription = RTCSessionDescription(type: .answer, sdp: sdp)
peer.setRemoteDescription(remoteDescription) { error in
  guard error == nil else {
    print(&amp;quot;Error: \(error?.localizedDescription ?? &amp;quot;&amp;quot;)&amp;quot;)
    return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;iceの送受信&#34;&gt;ICEの送受信&lt;/h4&gt;

&lt;p&gt;SDPのやり取りとは別に通信経路(&lt;code&gt;ICE Candidate&lt;/code&gt;)もやり取りする必要がある&lt;/p&gt;

&lt;p&gt;こちらは単純に相手に渡すべき&lt;code&gt;ICE Candidate&lt;/code&gt;があると、&lt;code&gt;RTCPeerConnectionDelegate&lt;/code&gt;の&lt;code&gt;didGenerate&lt;/code&gt;が呼ばれるのでそれを相手へ送信する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func peerConnection(_ peerConnection: RTCPeerConnection, didGenerate candidate: RTCIceCandidate) {
  // candidate.sdp(=ICE)を相手へ送信する
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;受信した側は、&lt;code&gt;SDP&lt;/code&gt;から&lt;code&gt;RTCIceCandidate&lt;/code&gt;を生成して&lt;code&gt;RTCPeerConnection&lt;/code&gt;に追加する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let can = RTCIceCandidate(sdp: sdp, sdpMLineIndex: 0, sdpMid: nil)
peer.add(can)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは何度か行われる&lt;/p&gt;

&lt;h3 id=&#34;リモートストリームの受信&#34;&gt;リモートストリームの受信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ICE&lt;/code&gt;のやり取りで接続が確立されると、&lt;code&gt;RTCPeerConnectionDelegate&lt;/code&gt;の&lt;code&gt;didAdd&lt;/code&gt;が呼び出されて、
相手側からのリモートストリームが渡される&lt;/p&gt;

&lt;p&gt;今回はVideoとAudioの両方のストリームがくるはずなので、それを表示用のViewと紐づける&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func peerConnection(_ peerConnection: RTCPeerConnection, 
                       didAdd stream: RTCMediaStream) {
  // remoteView: ViewController内に置いた表示用ビューのコンテナ
  let remote = RTCEAGLVideoView(frame: remoteView.bounds)
  remoteView.addSubview(remote)
  stream.videoTracks.last?.add(remote)
  remoteStream = stream
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで相手の映像が表示されてチャットができるようになる&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12&lt;/li&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/WebRTCVideoChat&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WebRTCをiOSネイティブで使う(準備編)</title>
      <link>https://mike-neko.github.io/blog/webrtc-build/</link>
      <pubDate>Tue, 29 Nov 2016 23:24:55 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/webrtc-build/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOSのブラウザでは&lt;code&gt;WebRTC&lt;/code&gt;がサポートされていないので、利用したい場合は
ネイティブのフレームワークを使う必要がある。&lt;/p&gt;

&lt;p&gt;今回の準備編では公式のフレームワークを使うにあたってフレームワークの生成と組み込みまでの手順について&lt;/p&gt;

&lt;p&gt;ただ、これが結構面倒で、ソースをダウンロードして一からビルドしないといけないし、
その方法が公式に明記されていないというおまけ付き&lt;/p&gt;

&lt;p&gt;普段、GitHubやCarthageに頼りきっている身には大変だった・・・&lt;/p&gt;

&lt;h2 id=&#34;フレームワークの生成&#34;&gt;フレームワークの生成&lt;/h2&gt;

&lt;p&gt;まずは、作業用の適当なフォルダを作っておく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir 作業用のフォルダ
cd 作業用のフォルダ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルド用のツールをインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install git
brew install python
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースをダウンロードする&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;以下、ものすごく時間と容量をくうので注意！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=`pwd`/depot_tools:&amp;quot;$PATH&amp;quot;
fetch --nohooks webrtc_ios
gclient sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd src
webrtc/build/ios/build_ios_libs.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功すれば、&lt;code&gt;src/out_ios_libs/&lt;/code&gt;の中に&lt;code&gt;WebRTC.framework&lt;/code&gt;ができている&lt;/p&gt;

&lt;h2 id=&#34;組み込み&#34;&gt;組み込み&lt;/h2&gt;

&lt;p&gt;組み込み自体は他のサードパーティのフレームワークと一緒だが、ポイントは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Embedded Binaries&lt;/code&gt;で追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Build Settings&lt;/code&gt;で&lt;code&gt;Bitcode&lt;/code&gt;を無効にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というあたり&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;Video&lt;/code&gt;を使う場合はシミュレータが使えないので注意&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://webrtc.org/native-code/&#34;&gt;WebRTC公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.12&lt;/li&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MultipeerConnectivityでP2P通信</title>
      <link>https://mike-neko.github.io/blog/multipeer/</link>
      <pubDate>Tue, 29 Nov 2016 18:40:09 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/multipeer/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS同士限定になるが、&lt;code&gt;Multipeer Connectivity Framework&lt;/code&gt;でお手軽にP2P通信をさせる方法&lt;/p&gt;

&lt;p&gt;今回は特に&lt;code&gt;MCBrowserViewController&lt;/code&gt;を使わずに実装してみた&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;おおまかな流れは&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MCSession&lt;/code&gt;で接続を開く&lt;br /&gt;
同時に&lt;code&gt;MCNearbyServiceAdvertiser&lt;/code&gt;で他の端末からの接続を待機&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MCNearbyServiceBrowser&lt;/code&gt;で待機している端末を探す&lt;br /&gt;
見つかれば、招待して接続を確立する&lt;/li&gt;
&lt;li&gt;招待された側が招待を受け入れれば接続が確立されるので、データをやりとりできる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、各種デリゲートはメインスレッドで呼び出されるとは限らないので、
UIを操作する場合は注意すること&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;接続の開始&#34;&gt;接続の開始&lt;/h3&gt;

&lt;p&gt;各端末は&lt;code&gt;Peer&lt;/code&gt;（ピア）と呼ばれ、相手に表示させる表示名を設定できる。
自端末をあらわす&lt;code&gt;Peer&lt;/code&gt;を生成したら、それを使って接続を開始する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let peerID = MCPeerID(displayName: &amp;quot;表示名&amp;quot;)
session = MCSession(peer: peerID, securityIdentity: nil, encryptionPreference: .none)
session.delegate = self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに他の端末から見える状態にする為に&lt;code&gt;MCNearbyServiceAdvertiser&lt;/code&gt;を設定する。
サービス名は相手を検索するのに使用するIDの様なものなので、かぶらないものを指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;advertiser = MCNearbyServiceAdvertiser(peer: peerID, discoveryInfo: nil, serviceType: &amp;quot;サービス名&amp;quot;)
advertiser.delegate = self
advertiser.startAdvertisingPeer()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまでの手順でいわば接続の待ち受け状態となる&lt;/p&gt;

&lt;h3 id=&#34;相手の検索と接続の確立&#34;&gt;相手の検索と接続の確立&lt;/h3&gt;

&lt;p&gt;相手を検索するには、&lt;code&gt;MCNearbyServiceBrowser&lt;/code&gt;を利用する。
サービス名には&lt;code&gt;Advertiser&lt;/code&gt;で設定したのと同じものを指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;browser = MCNearbyServiceBrowser(peer: peerID, serviceType: &amp;quot;サービス名&amp;quot;)
browser.delegate = self
browser.startBrowsingForPeers()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定したサービス名と同じPeerが見つかると&lt;code&gt;MCNearbyServiceBrowserDelegate&lt;/code&gt;の&lt;code&gt;foundPeer&lt;/code&gt;が呼び出される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func browser(_ browser: MCNearbyServiceBrowser,
      foundPeer peerID: MCPeerID,
withDiscoveryInfo info: [String : String]?) {
    print(&amp;quot;found: \(peerID)&amp;quot;)
    browser.invitePeer(peerID, to: session, withContext: nil, timeout: 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見つかった相手に、&lt;code&gt;invitePeer&lt;/code&gt;で接続を招待することができる。
招待された側には、&lt;code&gt;MCNearbyServiceAdvertiserDelegate&lt;/code&gt;の&lt;code&gt;didReceiveInvitationFromPeer&lt;/code&gt;が呼び出される&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func advertiser(_ advertiser: MCNearbyServiceAdvertiser,
  didReceiveInvitationFromPeer peerID: MCPeerID,
                  withContext context: Data?,
                    invitationHandler: @escaping (Bool, MCSession?) -&amp;gt; Void) {
    print(&amp;quot;InvitationFrom: \(peerID)&amp;quot;)
    invitationHandler(true, session)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;invitationHandler&lt;/code&gt;の第一引数で&lt;code&gt;true&lt;/code&gt;を渡すと招待を受け入れたことになり接続が確立される。&lt;/p&gt;

&lt;h3 id=&#34;データの送受信&#34;&gt;データの送受信&lt;/h3&gt;

&lt;p&gt;接続が確立されればデータのやりとりが出来る様になる。
データのやりとりには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data / NSData&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URL / NSURL&lt;/code&gt;でのリソース&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stream / NSStream&lt;/code&gt;でのストリーム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のどれかを使う&lt;/p&gt;

&lt;p&gt;一番シンプルな&lt;code&gt;Data&lt;/code&gt;の場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.send(data, toPeers: session.connectedPeers, with: .reliable)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、接続を確立しているPeer全てにデータを送信できる。
&lt;code&gt;.reliable&lt;/code&gt;にするとデータの送信順が保証され、
&lt;code&gt;.unreliable&lt;/code&gt;にすると送信順が保証されない代わりに即時にデータが送られる&lt;/p&gt;

&lt;p&gt;送信されたデータは、&lt;code&gt;MCSessionDelegate&lt;/code&gt;の各メソッドで受け取ることができる。
&lt;code&gt;Data&lt;/code&gt;の場合だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で受け取れる&lt;/p&gt;

&lt;h1 id=&#34;ソース&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;上記を元に2台の端末同士でP2Pで単純なテキストを送受信するクラスのソースは以下のとおり&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/00e0e04fd7bdf4c3e9378fc6d8e0a11a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;使い方は、&lt;/p&gt;

&lt;h4 id=&#34;接続の開始-1&#34;&gt;接続の開始&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;P2PConnectivity.manager.start(
    serviceType: &amp;quot;MIKE-SIMPLE-P2P&amp;quot;,
    displayName: UIDevice.current.name,
    stateChangeHandler: { state in
        // 接続状況の変化した時の処理
    }, recieveHandler: { data in
        // データを受信した時の処理
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;データの送信&#34;&gt;データの送信&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 送信
P2PConnectivity.manager.send(message: &amp;quot;送信するテキスト&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;終了&#34;&gt;終了&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;P2PConnectivity.manager.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じ&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2 / 10.1.1&lt;/li&gt;
&lt;li&gt;iPhone 6+ / 7+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>VPN上のWindows機へ接続</title>
      <link>https://mike-neko.github.io/blog/vpn-win/</link>
      <pubDate>Sun, 27 Nov 2016 22:50:47 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/vpn-win/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt;が入っていないVPN上のWindowsへアクセスする方法&lt;/p&gt;

&lt;p&gt;この場合、踏み台となる&lt;code&gt;SSH&lt;/code&gt;が入った別のマシンが必要となる&lt;/p&gt;

&lt;p&gt;今回の検証環境は以下の通り&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ローカル：Mac OS 10.11(※)&lt;/li&gt;
&lt;li&gt;VPN

&lt;ul&gt;
&lt;li&gt;CentOS 6.8(踏み台)&lt;/li&gt;
&lt;li&gt;Windows(SQLServer)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;※ macOS 10.12(sierra)は&lt;code&gt;PPTP&lt;/code&gt;でのVPN接続がOSではサポートされていないので注意！&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;接続のイメージは以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Mac
     |
(VPN / SSH)
     |
   CentOS(192.168.10.1 / 踏み台) - Windows(192.168.10.2 / SQLServer)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remotedesktopでログイン&#34;&gt;RemoteDesktopでログイン&lt;/h2&gt;

&lt;p&gt;Windowsなので遠隔で操作するには&lt;code&gt;RemoteDesktop&lt;/code&gt;を利用&lt;/p&gt;

&lt;h3 id=&#34;sshの接続方法&#34;&gt;SSHの接続方法&lt;/h3&gt;

&lt;p&gt;以下の形式でSSH接続する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -C -L 3389:(WindowsのIP):3389 (踏み台のIP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば、上述の環境でCentOSの&lt;code&gt;user&lt;/code&gt;でログインする場合だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -C -L 3389:192.168.10.2:3389 user@192.168.10.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で接続する&lt;/p&gt;

&lt;h3 id=&#34;remotedesktopの設定&#34;&gt;RemoteDesktopの設定&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;PC name:&lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;User name: Windowsのユーザ名&lt;/li&gt;
&lt;li&gt;Password: Windowsのパスワード&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ポイントはホストが&lt;code&gt;localhost&lt;/code&gt;になること&lt;/p&gt;

&lt;h2 id=&#34;sql-serverへ接続&#34;&gt;SQL Serverへ接続&lt;/h2&gt;

&lt;h3 id=&#34;sshの接続方法-1&#34;&gt;SSHの接続方法&lt;/h3&gt;

&lt;p&gt;以下の形式でSSH接続する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -C -L (DBのポート):(WindowsのIP):(DBのポート) (踏み台のIP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば、上述の環境でCentOSの&lt;code&gt;user&lt;/code&gt;、SQLServerのポートが&lt;code&gt;1433&lt;/code&gt;でログインする場合だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -C -L 1433:192.168.10.2:1433 user@192.168.10.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で接続する&lt;/p&gt;

&lt;h3 id=&#34;db接続設定&#34;&gt;DB接続設定&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ホスト:&lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ポート:1433&lt;/li&gt;
&lt;li&gt;DB名: そのまま&lt;/li&gt;
&lt;li&gt;DBユーザ: そのまま&lt;/li&gt;
&lt;li&gt;DBパスワード: そのまま&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>VagrantでCentOS6.8を使う </title>
      <link>https://mike-neko.github.io/blog/vagrant-cent/</link>
      <pubDate>Tue, 08 Nov 2016 21:32:51 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/vagrant-cent/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;野良BOXは自力で問題ないか検証するほどの腕がないので、公式BOXを利用しようとしたら、いろいろと落とし穴があったのでメモ&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Vagrantfile&lt;/code&gt;を作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p （適当なフォルダ）
cd （上で作ったフォルダ）
vagrant init bento/centos-6.8
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Vagrantfile&lt;/code&gt;を編集(サーバとして使いたいので以下のように編集)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# config.vm.network &amp;quot;forwarded_port&amp;quot;, guest: 80, host: 8080
# ↓コメントを外す＋ポートは空いているものを指定
config.vm.network &amp;quot;forwarded_port&amp;quot;, guest: 8010, host: 8010
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.33.10&amp;quot;
# ↓コメントを外す＋IPは空いているものを指定
config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.33.10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# Centos6.8限定で以下も追記(※1 詳細は後述)
config.vm.provider &amp;quot;virtualbox&amp;quot; do |vb|
vb.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--cableconnected1&amp;quot;, &amp;quot;on&amp;quot;]
end
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;起動する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant up
vagrant ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;トラブルシューティング&#34;&gt;トラブルシューティング&lt;/h2&gt;

&lt;h3 id=&#34;vagrant-up-で-private-key-で先に進まずエラーになる&#34;&gt;vagrant up で private key で先に進まずエラーになる&lt;/h3&gt;

&lt;p&gt;エラーは以下の感じでCentOS6.8で発生(6.7は問題無し)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Timed out while waiting for the machine to boot. This means that
Vagrant was unable to communicate with the guest machine within
the configured (&amp;quot;config.vm.boot_timeout&amp;quot; value) time period.

If you look above, you should be able to see the error(s) that
Vagrant had when attempting to connect to the machine. These errors
are usually good hints as to what may be wrong.

If you&#39;re using a custom box, make sure that networking is properly
working and you&#39;re able to connect to the machine. It is a common
problem that networking isn&#39;t setup properly in these boxes.
Verify that authentication configurations are also setup properly,
as well.

If the box appears to be booting properly, you may want to increase
the timeout (&amp;quot;config.vm.boot_timeout&amp;quot;) value.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;対応策&#34;&gt;対応策&lt;/h4&gt;

&lt;p&gt;ググると色々出てくるが、CentOS6.8で発生する場合は、前述の※1を&lt;code&gt;Vagrantfile&lt;/code&gt;に追記しておけば大丈夫。&lt;br /&gt;
（というか他の方法は効果なしだった・・・）&lt;/p&gt;

&lt;h3 id=&#34;ファイルの共有ができない&#34;&gt;ファイルの共有ができない&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;vagrant up&lt;/code&gt;で以下のエラーが出ている&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vagrant was unable to mount VirtualBox shared folders. This is usually
because the filesystem &amp;quot;vboxsf&amp;quot; is not available. This filesystem is
made available via the VirtualBox Guest Additions and kernel module.
Please verify that these guest additions are properly installed in the
guest. This is not a bug in Vagrant and is usually caused by a faulty
Vagrant box. For context, the command attempted was:
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;対応策-1&#34;&gt;対応策&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;まずはエラーを一旦無視してログインし、カーネルをアップデート&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh
su                     # pass:&amp;quot;vagrant&amp;quot;
yum -y update kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;アップデートが完了すれば&lt;code&gt;exit&lt;/code&gt;を2回でログアウトする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Guest Additions&lt;/code&gt;をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant plugin install vagrant-vbguest
vagrant vbguest
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;リロードをかけてエラーが出なければOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant reload
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;環境&#34;&gt;環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Mac 10.11&lt;/li&gt;
&lt;li&gt;VirtualBox 5.0.28&lt;/li&gt;
&lt;li&gt;Vagrant 1.8.6

&lt;ul&gt;
&lt;li&gt;CentOS6.7&lt;/li&gt;
&lt;li&gt;CentOS6.8&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CentOSからOracleへ接続</title>
      <link>https://mike-neko.github.io/blog/oracle-cent/</link>
      <pubDate>Thu, 03 Nov 2016 19:24:51 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/oracle-cent/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;CentOSのPHP5.6から別サーバで動いているOracleのDBへ&lt;code&gt;oci8&lt;/code&gt;で接続する方法&lt;/p&gt;

&lt;p&gt;Macの場合は&lt;a href=&#34;../oracle-mac/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;oracleのドライバのインストール&#34;&gt;Oracleのドライバのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;サーバのアーキテクチャを確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/database/features/instant-client/index.html&#34;&gt;Oracle Instant Client&lt;/a&gt;から
1で確認した環境の&lt;code&gt;basic&lt;/code&gt;と&lt;code&gt;SDK&lt;/code&gt;をダウンロードしサーバへ保存&lt;br /&gt;
(今回は&lt;code&gt;x86_64&lt;/code&gt;だったので&lt;code&gt;Version 12.1.0.2 (x86_64)&lt;/code&gt;の&lt;code&gt;rpm&lt;/code&gt;を選択。以降このバージョンが前提)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以下でインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd (保存した場所)
su
rpm -ivh oracle-instantclient12.1-basic-12.1.0.2.0-1.x86_64.rpm
rpm -ivh oracle-instantclient12.1-devel-12.1.0.2.0-1.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パスを通す&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/profile
# 以下の行を追加
export LD_LIBRARY_PATH=/usr/lib/oracle/12.1/client64/lib:$LD_LIBRARY_PATH
export PATH=/usr/lib/oracle/12.1/client64/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追記したら保存して終了し&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で強制反映させる&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;peclのインストール&#34;&gt;peclのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;以下でインストール
&lt;code&gt;
yum -y install --enablerepo=remi --enablerepo=remi-php56 php-pear
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;oci8のインストール&#34;&gt;oci8のインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pecl&lt;/code&gt;からインストールするので&lt;code&gt;DTrace&lt;/code&gt;サポートを有効にする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install systemtap-sdt-devel
export PHP_DTRACE=yes
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;ちなみにこれをしないと&lt;code&gt;error: oci8_dtrace_gen.h: No such file or director&lt;/code&gt;というエラーになる。
詳細は&lt;a href=&#34;http://php.net/manual/ja/oci8.dtrace.php&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;oci8&lt;/code&gt;をバージョン（Ver.2.0.12）を指定してインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pecl install oci8-2.0.12
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;oci8の最新版だとPHP7以降の為、2.0系を指定する&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インストール中にプロンプトが出れば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;instantclient,/usr/lib/oracle/12.1/client64/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PHPの設定
&lt;code&gt;php.ini&lt;/code&gt;に以下を設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension=oci8.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（場所が判らない時は&lt;code&gt;php -i | grep php.ini&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;設定の確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php --ri oci8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（略）
OCI8 Support =&amp;gt; enabled
（略）
OCI8 Version =&amp;gt; 2.0.12
（略）
Oracle Run-time Client Library Version =&amp;gt; 12.1.0.2.0
Oracle Compile-time Instant Client Version =&amp;gt; 12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出ていればOK&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phpからの接続&#34;&gt;PHPからの接続&lt;/h2&gt;

&lt;p&gt;Macの場合の&lt;a href=&#34;../oracle-mac/&#34;&gt;PHPからの接続&lt;/a&gt;を参照&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式 &lt;a href=&#34;http://php.net/manual/ja/book.oci8.php&#34;&gt;Oracle OCI8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pecl公式 &lt;a href=&#34;https://pecl.php.net/package/oci8&#34;&gt;oci8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html&#34;&gt;Orcale Instant Client&lt;/a&gt;
(下の方にインストール方法)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CentOS6.8&lt;/li&gt;
&lt;li&gt;PHP 5.6.27 + OCI8 2.0.12&lt;/li&gt;
&lt;li&gt;Oracle Instant Client 12.1.0.2.0&lt;/li&gt;
&lt;li&gt;DBサーバ OracleDB(Win)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CentOSからSQLServerへ接続</title>
      <link>https://mike-neko.github.io/blog/mssql-cent/</link>
      <pubDate>Thu, 03 Nov 2016 19:24:51 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/mssql-cent/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;CentOSのPHP5.6から&lt;code&gt;PDO_ODBC&lt;/code&gt;でSQLServer(MSSQL)へ接続する方法&lt;/p&gt;

&lt;p&gt;Macの場合は&lt;a href=&#34;../mssql-mac/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なおCentOSからであれば&lt;code&gt;PDO_DBLIB&lt;/code&gt;+&lt;code&gt;FreeTDS&lt;/code&gt;も可能だが、公式ドライバがあるこちらを試してみた&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;sqlserverのドライバのインストール&#34;&gt;SQLServerのドライバのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下でインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su
yum -y update
yum -y install yum-utils
yum-config-manager --add-repo https://apt-mo.trafficmanager.net/yumrepos/mssql-rhel6-release/
yum-config-manager --enable mssql-rhel6-release
wget &amp;quot;http://aka.ms/msodbcrhelpublickey/dpgswdist.v1.asc&amp;quot;
rpm --import dpgswdist.v1.asc
yum -y remove unixODBC
yum -y install msodbcsql # 途中にライセンスの承諾確認あり
yum -y install unixODBC-utf16-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ODBCドライバの確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/odbcinst.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として、以下のような文言があればOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ODBC Driver 13 for SQL Server]
Description=Microsoft ODBC Driver 13 for SQL Server
Driver=/opt/microsoft/msodbcsql/lib64/libmsodbcsql-13.0.so.1.0
UsageCount=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;odbcドライバの設定&#34;&gt;ODBCドライバの設定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo vi /etc/odbcinst.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として、次のような設定を追記する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(ドライバ名として判り易い名称)]
Driver = （odbcinst.iniの[]で囲まれたドライバ名）
Description = (適当な説明)
Trace = Yes
Server = (サーバのIP)
Port = (サーバのポート)
Database = (データベース名)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の例の場合だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[SQLServer]
Driver = ODBC Driver 13 for SQL Server
Description = For Develop
Trace = Yes
Server = 192.168.0.10
Port = 1433
Database = sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じになる&lt;/p&gt;

&lt;h3 id=&#34;pdo-odbcのインストール&#34;&gt;PDO_ODBCのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下でインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install --enablerepo=remi --enablerepo=remi-php56 php-pdo php-odbc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;設定の確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php -i | grep odbc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して、&lt;code&gt;PDO drivers&lt;/code&gt;に&lt;code&gt;odbc&lt;/code&gt;が表示されていればOK&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phpからの接続&#34;&gt;PHPからの接続&lt;/h2&gt;

&lt;p&gt;PDOのDSNの指定は以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$driver = &#39;SQLServer&#39;;      // odbc.iniで設定したドライバ名
$user = &#39;test&#39;;             // ユーザ名
$pass = &#39;1234&#39;;             // パスワード

$pdo = new PDO(&#39;odbc:&#39; . $driver, $user, $pass); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式 &lt;a href=&#34;http://php.net/manual/ja/ref.pdo-odbc.php&#34;&gt;PDO_ODBC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Microsoft公式 &lt;a href=&#34;https://blogs.technet.microsoft.com/dataplatforminsider/2016/10/25/odbc-driver-13-0-for-sql-server-linux-is-now-released/&#34;&gt;ODBC Driver 13.0 for SQL Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;CentOS6.8&lt;/li&gt;
&lt;li&gt;PHP 5.6.27 + PDO_ODBC&lt;/li&gt;
&lt;li&gt;ODBC Driver 13.0 for SQL Server&lt;/li&gt;
&lt;li&gt;DBサーバ SQLServer Express 2016(Win)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MacからOracleへ接続</title>
      <link>https://mike-neko.github.io/blog/oracle-mac/</link>
      <pubDate>Thu, 03 Nov 2016 19:24:51 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/oracle-mac/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;MacのPHP5.6から別サーバで動いているOracleのDBへ&lt;code&gt;oci8&lt;/code&gt;で接続する方法&lt;/p&gt;

&lt;p&gt;CentOSの場合は&lt;a href=&#34;../oracle-cent/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;oracleのドライバのインストール&#34;&gt;Oracleのドライバのインストール&lt;/h3&gt;

&lt;p&gt;今回は&lt;code&gt;Version 12.1.0.2 (64-bit)&lt;/code&gt;は選択。手順などはこのバージョンが前提&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/database/features/instant-client/index.html&#34;&gt;Oracle Instant Client&lt;/a&gt;から&lt;code&gt;basic&lt;/code&gt;と&lt;code&gt;SDK&lt;/code&gt;をダウンロード&lt;br /&gt;
&lt;em&gt;公式の&lt;a href=&#34;http://php.net/manual/ja/oci8.requirements.php&#34;&gt;要件&lt;/a&gt;にあるように&lt;code&gt;OracleDB&lt;/code&gt;と&lt;code&gt;PHP&lt;/code&gt;のバージョンに合ったものを選択&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1を全て同じフォルダへ解凍する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd （ダウンロード先）
unzip instantclient-basic-macos.x64-12.1.0.2.0.zip
unzip instantclient-sdk-macos.x64-12.1.0.2.0.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Ver.12であれば&lt;code&gt;instantclient_12_1&lt;/code&gt;というフォルダ内に全ファイルが解凍された状態になればOK)&lt;br /&gt;
&lt;strong&gt;フォルダ名がバージョンになっているので解凍したフォルダ名をそのまま使うこと！&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2をフォルダごと適当な場所に移動&lt;br /&gt;
（今回は&lt;code&gt;/Library/Oracle/&lt;/code&gt;へ移動）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ライブラリのシンボリックリンクを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /Library/Oracle/instantclient_12_1/
ln -s libclntsh.dylib.12.1 libclntsh.dylib
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パスを通す&lt;br /&gt;
&lt;code&gt;.bash_profile&lt;/code&gt;に以下を追記&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export DYLD_LIBRARY_PATH=/Library/Oracle/instantclient_12_1
export PATH=$PATH:$DYLD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追記したら保存し、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で強制反映させる&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;oci8をインストール&#34;&gt;OCI8をインストール&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;以下はすでにPHPをインストール済かつ&lt;code&gt;PECL&lt;/code&gt;が使えない場合なので、
通常はPHPインストールと同時にしてしまうか&lt;code&gt;PECL&lt;/code&gt;で追加が恐らく楽&lt;/em&gt;&lt;br /&gt;
（手持ちの環境では&lt;code&gt;PECL&lt;/code&gt;がなぜか使えなかったので以下の手順）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OCI8（Ver.2.0.12）を&lt;code&gt;PECL&lt;/code&gt;の&lt;a href=&#34;https://pecl.php.net/package/oci8&#34;&gt;該当ページ&lt;/a&gt;からダウンロード&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解凍する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd （ダウンロード先）
tar -zxf oci8-2.0.12.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;makeする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd oci8-2.0.12
phpize
./configure -with-oci8=shared,instantclient,/Library/Oracle/instantclient_12_1
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;modules&lt;/code&gt;の中に&lt;code&gt;oci8.so&lt;/code&gt;ができていればOK&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ライブラリを移動&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mv modules/oci8.so /Library/Oracle 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（とりあえず今回はここで）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PHPの設定
&lt;code&gt;php.ini&lt;/code&gt;に以下の2つの項目を設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension_dir = &amp;quot;/Library/Oracle&amp;quot; # oci8.soを置いた場所
extension=oci8.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（ファイルの場所が判らない時は&lt;code&gt;php -i | grep php.ini&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;設定の確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php --ri oci8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（略）
OCI8 Support =&amp;gt; enabled
（略）
OCI8 Version =&amp;gt; 2.0.12
（略）
Oracle Run-time Client Library Version =&amp;gt; 12.1.0.2.0
Oracle Compile-time Instant Client Version =&amp;gt; 12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出ていればOK&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phpからの接続&#34;&gt;PHPからの接続&lt;/h2&gt;

&lt;p&gt;フレームワークなどを使わずにそのまま接続する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$user = &#39;test&#39;;             // ユーザ名
$pass = &#39;1234&#39;;             // パスワード
$host = &#39;192.168.0.10&#39;;     // ホスト
$port = &#39;1521&#39;;             // ポート番号
$db = &#39;sample&#39;;             // データベース名（サービス名）

$conn = oci_connect(
  $user,
  $pass,
  &#39;(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)&#39;
  . &#39;(HOST=&#39; . $host . &#39;)(PORT=&#39; . $port . &#39;)))&#39; 
  . &#39;(CONNECT_DATA=(SERVICE_NAME=&#39; . $db . &#39;)))&#39;]
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じで接続できる&lt;/p&gt;

&lt;h2 id=&#34;phpstormの設定&#34;&gt;PHPStormの設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PHPStorm&lt;/code&gt;から接続したい場合は、&lt;code&gt;Oracle Instant Client&lt;/code&gt;はVer.12以上が必要&lt;/p&gt;

&lt;p&gt;設定は以下の感じ&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-11-03-oracle-mac/phpstorm.png&#34; /&gt;
&lt;/figure&gt;


&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式 &lt;a href=&#34;http://php.net/manual/ja/book.oci8.php&#34;&gt;Oracle OCI8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html&#34;&gt;Orcale Instant Client&lt;/a&gt;
(下の方にインストール方法)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Mac 10.11&lt;/li&gt;
&lt;li&gt;PHP 5.6.27 + OCI8 2.0.12&lt;/li&gt;
&lt;li&gt;Oracle Instant Client 12.1.0.2.0&lt;/li&gt;
&lt;li&gt;DBサーバ OracleDB(Win)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MacからSQLServerへ接続</title>
      <link>https://mike-neko.github.io/blog/mssql-mac/</link>
      <pubDate>Thu, 03 Nov 2016 19:24:51 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/mssql-mac/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;MacのPHP5.6からSQLServer(MSSQL)へ接続する方法&lt;/p&gt;

&lt;p&gt;CentOSの場合は&lt;a href=&#34;../mssql-cent/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;子ネタ&#34;&gt;子ネタ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SQLServer&lt;/code&gt;へPHPから接続するには以下の方法がある&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/ja/ref.pdo-sqlsrv.php&#34;&gt;PDO_SQLSR&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows版のPHPでしか使えない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/ja/ref.pdo-dblib.php&#34;&gt;PDO_DBLIB&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FreeTDS&lt;/code&gt;ライブラリを利用する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows版はPHP5.3以降使えない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/ja/ref.pdo-odbc.php&#34;&gt;PDO_ODBC&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Microsoftのドライバが必要(Win or Linuxのみ) =&amp;gt; &lt;strong&gt;Macは使えない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という訳で、Macからの場合は&lt;code&gt;PDO_DBLIB&lt;/code&gt;+&lt;code&gt;FreeTDS&lt;/code&gt;一択、
Linuxの場合は&lt;code&gt;PDO_ODBC&lt;/code&gt;+公式ドライバ（おすすめ？） or &lt;code&gt;PDO_DBLIB&lt;/code&gt;+&lt;code&gt;FreeTDS&lt;/code&gt;となる&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;freetdsのインストール&#34;&gt;FreeTDSのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Homebrew&lt;/code&gt;で&lt;code&gt;FreeTDS&lt;/code&gt;をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install freetds
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;FreeTDS&lt;/code&gt;の接続確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tsql -H (SQLServerのアドレス) -p (ポート) -U (ユーザ名) -P (パスワード)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locale is &amp;quot;ja_JP.UTF-8&amp;quot;
locale charset is &amp;quot;UTF-8&amp;quot;
using default charset &amp;quot;UTF-8&amp;quot;
1&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようになれば&lt;code&gt;exit&lt;/code&gt;で終了&lt;br /&gt;
&lt;code&gt;1&amp;gt;&lt;/code&gt;の部分の数字が変わっていく場合は接続がうまくいっていない&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;試した開発環境ではかなりの頻度でタイムアウトのエラーが出ていたので何度か試してみること&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;pdo-dblibのインストール&#34;&gt;PDO_DBLIBのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Homebrew&lt;/code&gt;で&lt;code&gt;PDO_DBLIB&lt;/code&gt;をインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install homebrew/php/php56-pdo-dblib
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;設定の確認&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php --ri pdo_dblib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PDO Driver for FreeTDS/Sybase DB-lib =&amp;gt; enabled
Flavour =&amp;gt; freetds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出ていればOK&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;phpからの接続&#34;&gt;PHPからの接続&lt;/h2&gt;

&lt;p&gt;PDOのDSNの指定は以下の通り&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$user = &#39;test&#39;;             // ユーザ名
$pass = &#39;1234&#39;;             // パスワード
$host = &#39;192.168.0.10&#39;;     // ホスト
$port = &#39;1433&#39;;             // ポート番号
$db = &#39;sample&#39;;             // データベース名

$pdo = new PDO(&#39;dblib:host=&#39; . $host . &#39;:&#39; . $port . &#39;;dbname=&#39; $db, 
               $user, $pass); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;phpstormの設定&#34;&gt;PHPStormの設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PHPStorm&lt;/code&gt;から接続したい場合の設定は以下の感じ&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-11-03-mssql-mac/phpstorm.png&#34; /&gt;
&lt;/figure&gt;


&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP公式 &lt;a href=&#34;http://php.net/manual/ja/ref.pdo-dblib.php&#34;&gt;PDO_DBLIB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FreeTDS &lt;a href=&#34;http://www.freetds.org/&#34;&gt;公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Mac 10.11&lt;/li&gt;
&lt;li&gt;PHP 5.6.27 + PDO_DBLIB&lt;/li&gt;
&lt;li&gt;FreeTDS 1.00.15 (TDS 7.3)&lt;/li&gt;
&lt;li&gt;DBサーバ SQLServer Express 2016(Win)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Guzzle(PHP)でAPNsの同時配信を行う</title>
      <link>https://mike-neko.github.io/blog/guzzle-apns/</link>
      <pubDate>Sat, 29 Oct 2016 22:40:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle-apns/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;でiOSのAPNs(Push通知)をお手軽に同時配信する方法&lt;/p&gt;

&lt;p&gt;APNs自体については&lt;a href=&#34;../http2apns/&#34;&gt;APNs Provider API(http2)を利用する(Node.js)&lt;/a&gt;を参照&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;自体は&lt;a href=&#34;../guzzle/&#34;&gt;以前の記事&lt;/a&gt;を参照&lt;/p&gt;

&lt;h3 id=&#34;curlの更新&#34;&gt;curlの更新&lt;/h3&gt;

&lt;p&gt;APNsを使うには&lt;code&gt;http2&lt;/code&gt;が必要かつ非同期で実行したいので、&lt;code&gt;curl&lt;/code&gt;をインストールし直す&lt;/p&gt;

&lt;p&gt;&lt;code&gt;homebrew&lt;/code&gt;を使っている場合は以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install curl --with-nghttp2 --with-openssl
brew link curl --force
brew reinstall php56 --with-homebrew-curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、自分で試した時は上記だけでは&lt;code&gt;http2&lt;/code&gt;が有効にならなかったので、
アンイストールした方が確実かもしれない&lt;/p&gt;

&lt;p&gt;更新後に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として&lt;code&gt;http2&lt;/code&gt;が出ていればOK&lt;/p&gt;

&lt;h2 id=&#34;guzzleの使い方&#34;&gt;Guzzleの使い方&lt;/h2&gt;

&lt;h3 id=&#34;http2で通信する&#34;&gt;http2で通信する&lt;/h3&gt;

&lt;p&gt;オプションで指定するだけでOK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;version&#39; =&amp;gt; 2.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post送信&#34;&gt;POST送信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;はリクエスト時のオプションとして以下の感じで指定する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client();
$response = $client-&amp;gt;request(&#39;POST&#39;, $url, [&#39;body&#39; =&amp;gt; $body]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;body&lt;/code&gt;の中身を&lt;code&gt;JSON&lt;/code&gt;にしたい時は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;body&#39; =&amp;gt; json_encode($json])]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形にして渡す&lt;/p&gt;

&lt;h3 id=&#34;クライアント証明書をつける&#34;&gt;クライアント証明書をつける&lt;/h3&gt;

&lt;p&gt;これもオプションで指定するだけでOK&lt;/p&gt;

&lt;p&gt;例えば同じ階層内に&lt;code&gt;apns_dev.pem&lt;/code&gt;という証明書（パスフレーズ&lt;code&gt;0000&lt;/code&gt;）に置いた場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;cert&#39; =&amp;gt; [&#39;apns_dev.pem&#39;, &#39;0000&#39;]]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あえていうなら、&lt;code&gt;pem&lt;/code&gt;形式の証明書を作るのがちょっと面倒&lt;/p&gt;

&lt;h2 id=&#34;apnsの同時配信&#34;&gt;APNsの同時配信&lt;/h2&gt;

&lt;p&gt;APNsは通知内容をJSONで指定することと、前回の並列リクエストを併せると、以下のコードで同時配信が実現できる&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/dcc15bedbc4d42e4e8b1c31119f3c63a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;（※配信環境はSandBox向け）&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Guzzleで非同期の並列リクエストを行う</title>
      <link>https://mike-neko.github.io/blog/guzzle/</link>
      <pubDate>Sat, 29 Oct 2016 16:50:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/guzzle/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PHP&lt;/code&gt;のHTTPクライアント(&lt;a href=&#34;http://docs.guzzlephp.org/en/latest/&#34;&gt;Guzzle&lt;/a&gt;)で非同期の並列リクエストを行う方法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Guzzle&lt;/code&gt;は内部では&lt;code&gt;curl&lt;/code&gt;を使っており、便利な&lt;code&gt;curl&lt;/code&gt;を面倒な設定をせずに使えるというありがたいもの
（なお&lt;code&gt;curl&lt;/code&gt;がなくても動くがその場合は非同期が使えないなど機能が制限されるらしい）&lt;/p&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;動作環境は以下のとおり&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.5.0以上&lt;/li&gt;
&lt;li&gt;curl 7.19.4以上
(要openSSL/zlib)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;composer&lt;/code&gt;で&lt;code&gt;guzzlehttp/guzzle&lt;/code&gt;を入れる&lt;br /&gt;
(&lt;code&gt;guzzle/guzzle&lt;/code&gt;は古いバージョンなので注意)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;composer&lt;/code&gt;を使っているので、使う時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;vendor/autoload.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を忘れないこと&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;php-iniの設定&#34;&gt;php.iniの設定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;allow_url_fopen = ON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を設定しておく&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;複数のURLに並列に非同期にリクエストをかける方法は以下のとおり&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/07e16ffece9ecfbffa4959f875897418.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;まずは、&lt;code&gt;$requests&lt;/code&gt;に実際のリクエストを生成する処理をクロージャとして登録する。&lt;br /&gt;
今回であれば、URLのリストから単純にURLを取り出し、&lt;code&gt;$client-&amp;gt;getAsync($url)&lt;/code&gt;としてリクエストを生成している&lt;br /&gt;
（URLのエンドポイントだけが違うような場合は&lt;code&gt;base_uri&lt;/code&gt;を指定した方がスマート）&lt;/p&gt;

&lt;p&gt;ポイントは&lt;code&gt;yield&lt;/code&gt;でジェネレータを使っていること。&lt;br /&gt;
通常は&lt;code&gt;foreach&lt;/code&gt;をした時点でそのループの回数分中の処理が実行されてメモリなどのリソースを消費するが、
ジェネレータを使うと実際に必要になる（今回であれば&lt;code&gt;Pool&lt;/code&gt;で順次実行される時）まで実行されずリソースを消費しないメリットがある&lt;/p&gt;

&lt;p&gt;リクエストの生成処理ができれば、&lt;code&gt;Pool&lt;/code&gt;オブジェクトに渡して&lt;code&gt;Promise&lt;/code&gt;を生成する。
その際、&lt;code&gt;concurrency&lt;/code&gt;で同時リクエスト数を、&lt;code&gt;fulfilled&lt;/code&gt;で成功時の処理、&lt;code&gt;rejected&lt;/code&gt;で失敗時の処理が行われる。
非同期の場合、リクエストは生成順に実行されるが、当然、処理結果は順不同で返ってくる。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;code&gt;Promise&lt;/code&gt;の&lt;code&gt;wait()&lt;/code&gt;の部分で全ての並列処理が終わるまで待機される。
これを忘れると完了しないまま処理が終わってしまう&lt;/p&gt;

&lt;p&gt;つまり、例えばあるページにアクセスした時にバックグラウンドの非同期でダウンロードを行うといったことはできない。
そういったことをしたい場合は、&lt;code&gt;Laravel&lt;/code&gt;の&lt;a href=&#34;https://readouble.com/laravel/5.1/ja/queues.html&#34;&gt;キュー&lt;/a&gt;なんかがおすすめ&lt;/p&gt;

&lt;h2 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$client = new Client([&#39;debug&#39; =&amp;gt; true]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としておくと細かな通信状況が出力されるので便利&lt;/p&gt;

&lt;h1 id=&#34;参考リンク&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;http://docs.guzzlephp.org/en/latest/&#34;&gt;Guzzle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ジェネレータ:&lt;a href=&#34;http://php.net/manual/ja/language.generators.overview.php&#34;&gt;PHP公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PHP 5.6&lt;/li&gt;
&lt;li&gt;Guzzle 6.2.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UIScrollViewのAutoLayoutをStoryboardのみで設定</title>
      <link>https://mike-neko.github.io/blog/scrollview/</link>
      <pubDate>Sun, 23 Oct 2016 22:28:33 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/scrollview/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Storyboard上だけでUIScrollViewのAutoLayoutを完結させる方法。
中のUIを動的に追加や削除しないのであればコードを書く必要もないし、
&lt;code&gt;UILabel&lt;/code&gt;のようにコンテンツに応じて動的に高さが変わるようなものにも対応可能&lt;/p&gt;

&lt;p&gt;ポイントは&lt;code&gt;ContainerView&lt;/code&gt;を利用してScrollViewを別のViewControllerに持っていくこと&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;サンプルとしてViewControllerの全画面に縦スクロールするScrollViewを配置する例を考える&lt;/p&gt;

&lt;h4 id=&#34;1-viewcontrollerのscrollviewを置きたい場所に-containerview-を置き制約を設定する&#34;&gt;1. ViewControllerのScrollViewを置きたい場所に&lt;code&gt;ContainerView&lt;/code&gt;を置き制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;&lt;code&gt;Layout Guide&lt;/code&gt;に対して制約を設定するとステータスバーなどに合わせて位置が変わる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1で追加した子viewcontrollerをアウトライン上で選択し-viewcontrollerのサイズを-freeform-へ変更する&#34;&gt;2. 1で追加した子ViewControllerをアウトライン上で選択し、ViewControllerのサイズを&lt;code&gt;Freeform&lt;/code&gt;へ変更する&lt;/h4&gt;

&lt;p&gt;変更すると&lt;code&gt;Height&lt;/code&gt;の部分が変更できるようになるので、
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step2.png&#34; /&gt;
&lt;/figure&gt;

ScrollViewの&lt;code&gt;ContentSize&lt;/code&gt;の高さがあらかじめ決まっているのであれば同じに、
そうでないなら余裕を持った数字に変えておく&lt;/p&gt;

&lt;p&gt;&lt;em&gt;サイズを変更しなくても組めるが変更した方がスクロールせずに作業が行えるので楽&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-1で追加した子viewcontrollerのviewにscrollviewを追加し任意の制約を設定する&#34;&gt;3. 1で追加した子ViewControllerのViewにScrollViewを追加し任意の制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）全画面にしたいのでViewに対して今回も&lt;code&gt;0&lt;/code&gt;で設定
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step1.png&#34; /&gt;
&lt;/figure&gt;

&lt;em&gt;もしスクロールしないヘッダとつけたりしたいなら、この子ViewControllerのViewに対して追加しておくと便利&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-3で追加したscrollviewにviewを追加し制約を設定する&#34;&gt;4. 3で追加したScrollViewにViewを追加し制約を設定する&lt;/h4&gt;

&lt;p&gt;（サンプル）縦スクロールにしたいので制約は以下の通り
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/step4.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;縦と横はそれぞれ親(Scrollview)に対して&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;横幅は親(Scrollview)と同じ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ここで追加したViewがいわば&lt;code&gt;ContentView&lt;/code&gt;となる&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-4のviewに各パーツを配置していく&#34;&gt;5. 4のviewに各パーツを配置していく&lt;/h4&gt;

&lt;p&gt;この工程は普段通りのAutoLayoutの設定でOK。
&lt;code&gt;UILabel&lt;/code&gt;の高さをコンテンツに応じて変えたいなら高さを設定せずにマージンだけを設定する&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scrollviewの中身の高さが固定でないなら&lt;code&gt;height&lt;/code&gt;は設定しないこと&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考-viewの階層&#34;&gt;参考：Viewの階層&lt;/h3&gt;

&lt;p&gt;子ViewControllerのアウトライン
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-10-23-scrollview/view.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AutoLayout&lt;/code&gt;って使い方のコツを見つけるまでが大変だけど、このサンプルみたいにやり方を見つけてしまうと楽すぎ〜〜&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>NotificationCenter(Swift3)の使い方</title>
      <link>https://mike-neko.github.io/blog/notification/</link>
      <pubDate>Sun, 23 Oct 2016 18:30:34 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/notification/</guid>
      <description>

&lt;p&gt;旧&lt;code&gt;NSNotification&lt;/code&gt;がSwift3でちょっと変更が入ったので使い方と＋αのエクステンションのまとめ&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;h3 id=&#34;通知の送信&#34;&gt;通知の送信&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Change&amp;rdquo;という名前の通知を送信するときは以下の2パターン&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.post(
    Notification(name: Notification.Name(&amp;quot;Change&amp;quot;)))

NotificationCenter.default.post(name: Notification.Name(&amp;quot;Change&amp;quot;),
                                object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通知の受信&#34;&gt;通知の受信&lt;/h3&gt;

&lt;p&gt;上述の通知を受信したい場合は、&lt;/p&gt;

&lt;h4 id=&#34;受信先の登録&#34;&gt;受信先の登録&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    name: Notification.Name(&amp;quot;Change&amp;quot;),
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、登録した場合は解除も忘れずにすること！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考: UIKeyboardWillShowNotificationとかは&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.addObserver(self,
    selector: #selector(keyboardWillShow),
    name: .UIKeyboardWillShow,
    object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに名前が定義されているので省略形で良い&lt;/p&gt;

&lt;h4 id=&#34;受信するメソッド&#34;&gt;受信するメソッド&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func recieveHoge(notification: NSNotification) {
    // ここで処理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アクセス制限は&lt;code&gt;internal&lt;/code&gt;以上が必要（&lt;code&gt;private&lt;/code&gt;/&lt;code&gt;fileprivate&lt;/code&gt;は不可）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;post&lt;/code&gt;時に送った&lt;code&gt;object&lt;/code&gt;を利用したい場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let hoge = notification.object as? Hoge else { return }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というように変換して使う&lt;/p&gt;

&lt;p&gt;また、特に指定をしないとメイン以外のスレッドで呼び出されることがあるので、
UI絡みの部分は&lt;code&gt;DispatchQueue.main.async&lt;/code&gt;を使った方が良い&lt;/p&gt;

&lt;h4 id=&#34;受信の解除&#34;&gt;受信の解除&lt;/h4&gt;

&lt;p&gt;特定の通知のみ解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self,
                                          name: Notification.Name(&amp;quot;Change&amp;quot;),
                                          object: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自身が登録している受信を全て解除する場合は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NotificationCenter.default.removeObserver(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;エクステンション&#34;&gt;エクステンション&lt;/h2&gt;

&lt;p&gt;今回のSwift3から&lt;code&gt;Notification.Name&lt;/code&gt;の部分で、以前と比べて手間がかかるようになってしまった
（元からOSで用意されているものは逆に楽）&lt;/p&gt;

&lt;p&gt;それとは別に、名前がアプリの他とかぶらないようになるべく一元管理をしたいので、以下のようなエクステンションと&lt;code&gt;enum&lt;/code&gt;を利用する&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5c92a36705ebcc3c49022a534d4df157.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;em&gt;※&lt;code&gt;enum&lt;/code&gt;はガイドライン的には小文字が良いが文字定数を強調したいので大文字になっている&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;特にエクステンションといっても特別なことはしていなくて単に専用の&lt;code&gt;enum&lt;/code&gt;を使えるようにしただけ。&lt;br /&gt;
でも、これを実際に使うと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通知の送信
NotificationCenter.default.post(key: .ChangeStatus)

// 通知の受信先の登録
NotificationCenter.default.addObserver(self,
    selector: #selector(recieveHoge),
    key: .ChangeStatus)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;って感じですっきりする&lt;/p&gt;

&lt;p&gt;本来は、&lt;code&gt;Notification.Name&lt;/code&gt;をエクステンションして使うのが想定されているようだが、
&lt;code&gt;enum&lt;/code&gt;により一意になることが保証されるのと、リテラルが出てこないので、個人的にはこっちがお気に入り&lt;/p&gt;

&lt;h1 id=&#34;開発環境&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.12.0&lt;/li&gt;
&lt;li&gt;Xcode 8.0 / Swift3&lt;/li&gt;
&lt;li&gt;iOS 10.0.2&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>