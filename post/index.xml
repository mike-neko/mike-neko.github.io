<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on M.Ikeの小ネタ集</title>
    <link>https://mike-neko.github.io/post/</link>
    <description>Recent content in Posts on M.Ikeの小ネタ集</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <lastBuildDate>Thu, 16 Jun 2016 21:17:36 +0900</lastBuildDate>
    <atom:link href="https://mike-neko.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>QRコードの読み取りサンプル(Swift) その2</title>
      <link>https://mike-neko.github.io/blog/qr-reader/</link>
      <pubDate>Thu, 16 Jun 2016 21:17:36 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/qr-reader/</guid>
      <description>

&lt;h2 id=&#34;概要:864526975070042dd27a73a748ee1dfb&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;以前に書いた&lt;a href=&#34;../code-reader/&#34;&gt;QRコードの読み取りサンプル&lt;/a&gt;の別バージョン。
今回はカメラ不要で画像データから直接QRコードを読み取りが可能。&lt;/p&gt;

&lt;p&gt;サンプルでは、カメラロールから画像を取得し、認識できたQRコードを切り出して表示している。&lt;/p&gt;

&lt;p&gt;今回の認識部分は、&lt;code&gt;CoreImage&lt;/code&gt;の&lt;code&gt;CIDetector&lt;/code&gt;を利用している。
&lt;code&gt;CIDetector&lt;/code&gt;は顔認識や文字認識もできる優れもの。&lt;/p&gt;

&lt;h3 id=&#34;相違点:864526975070042dd27a73a748ee1dfb&#34;&gt;相違点&lt;/h3&gt;

&lt;p&gt;前回の&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;を利用した方法との違いは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;画像データから読み取り可能&lt;/li&gt;
&lt;li&gt;読み取り可能なコードはQRコードのみ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった辺り。複数認識可能なのは変わらない。&lt;/p&gt;

&lt;p&gt;画像データは&lt;code&gt;UIImage&lt;/code&gt;が生成できるデータを用意すれば良いので、
元データはローカルファイルでもネット上でも、当然カメラからでもOK。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:864526975070042dd27a73a748ee1dfb&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;qr検出:864526975070042dd27a73a748ee1dfb&#34;&gt;QR検出&lt;/h3&gt;

&lt;p&gt;検出のコードはとてもシンプル。&lt;/p&gt;

&lt;p&gt;画像データを&lt;code&gt;CoreImage&lt;/code&gt;の形式へ変換し、検出器にかけるだけ。&lt;/p&gt;

&lt;p&gt;エラー処理を省略して抜粋すると以下の感じ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let ciimg = CIImage(image: image)!
let detector = CIDetector(ofType: CIDetectorTypeQRCode,
                         context: nil, options: nil)
let results = detector.featuresInImage(ciimg) as! [CIQRCodeFeature]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、検出されたコードの配列が取得される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CIQRCodeFeature&lt;/code&gt;には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bounds&lt;/code&gt;：コードを検出した領域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bottomLeft bottomRight topLeft topRight&lt;/code&gt;：コードを検出した位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;messageString&lt;/code&gt;：コードに含まれるデータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が入っている。&lt;/p&gt;

&lt;h3 id=&#34;検出位置:864526975070042dd27a73a748ee1dfb&#34;&gt;検出位置&lt;/h3&gt;

&lt;p&gt;位置の座標は、画面ではなく画像の座標を基準とした座標で取得される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bounds&lt;/code&gt;とそれ以外の&lt;code&gt;bottom〜&lt;/code&gt;や&lt;code&gt;top〜&lt;/code&gt;で取れる座標は、
検出したQRコードが回転していた場合に異なってくる。&lt;/p&gt;

&lt;p&gt;例えば、斜めの状態のQRコードが検出された場合、
&lt;code&gt;bounds&lt;/code&gt;は周りの余白部分を含めた正方形の領域が入る。
それ以外のものにはQRコードの各頂点の座標がそれぞれ入る。&lt;br /&gt;
（この辺りは実際に斜めの画像を読み込んで見ればよくわかる）&lt;/p&gt;

&lt;h2 id=&#34;感想:864526975070042dd27a73a748ee1dfb&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;このQRコードの検出は&lt;code&gt;iOS8&lt;/code&gt;から可能になっているが、全然把握できていなかったので反省。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;CIDetector&lt;/code&gt;は他にもいろいろ検出できるので楽しみ。
他にもまだこういう知らないものがいっぱいあるんだろうな・・・&lt;/p&gt;

&lt;p&gt;なお、&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;との性能などの差は未調査。。。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:864526975070042dd27a73a748ee1dfb&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:864526975070042dd27a73a748ee1dfb&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/QRReader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QRコードの読み取りサンプル(Swift) その1</title>
      <link>https://mike-neko.github.io/blog/code-reader/</link>
      <pubDate>Wed, 15 Jun 2016 22:52:40 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/code-reader/</guid>
      <description>

&lt;h2 id=&#34;概要:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のカメラでQRコードを読み取り、認識されたコードを枠線で強調表示するサンプル。&lt;/p&gt;

&lt;p&gt;なお、QRコードに限らず、他のバーコードや顔認識にも対応。対応形式は&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/AVFoundation/Reference/AVMetadataMachineReadableCodeObject_Class/index.html#//apple_ref/doc/constant_group/Machine_Readable_Object_Types&#34;&gt;公式&lt;/a&gt;を参照。地味にiOS8から対応形式が増えている。&lt;/p&gt;

&lt;p&gt;あと、2次元なら同時認識できたりするが、その辺りの詳細は参考リンクの公式FAQが詳しい。&lt;/p&gt;

&lt;p&gt;コード認識自体はもっと詳しい説明がいろんなとこにあるので、ここは他で説明していなそうなところだけ。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;シリアルキューの利用:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;シリアルキューの利用&lt;/h3&gt;

&lt;p&gt;カメラの起動や画像認識は処理が重いので、それぞれ専用のシリアルキューを作成して利用している。&lt;/p&gt;

&lt;p&gt;カメラの設定周りはフリーズ状態になるのを防ぐためだが、最近の端末は起動が早いらしく、キューを使わなくても特に問題無い感じ。&lt;/p&gt;

&lt;h3 id=&#34;avmetadatamachinereadablecodeobject:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;AVMetadataMachineReadableCodeObject&lt;/h3&gt;

&lt;p&gt;認識されたコードは&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;のオブジェクトの配列で渡される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：認識されたコードのフォーマットが逆DNS形式で返ってくる&lt;br /&gt;
(QRの場合は&lt;code&gt;org.iso.QRCode&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringValue&lt;/code&gt;：コードに含まれるデータ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;プレビュー画面上に認識したコードの枠を表示する:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;プレビュー画面上に認識したコードの枠を表示する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AVMetadataMachineReadableCodeObject&lt;/code&gt;の中の&lt;code&gt;corners&lt;/code&gt;にコードの座標位置が含まれているが、これはプレビューのViewの座標系とは異なるので、そのままでは使えない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の&lt;code&gt;transformedMetadataObjectForMetadataObject&lt;/code&gt;で変換後の座標が入った&lt;code&gt;AVMetadataObject&lt;/code&gt;が取得できるので、その中の&lt;code&gt;bounds&lt;/code&gt;を使って枠線を描画している。&lt;/p&gt;

&lt;p&gt;（以前は手動でちゃんとプレビュー画面上の座標に変換していたが、今回、この簡単に変換できるメソッドを発見！&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;の方もちゃんと調べていれば・・・）&lt;/p&gt;

&lt;h2 id=&#34;感想:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;昔iOS7で使えるようになった時に試したものを、Swiftで書き直し＋αしたコード。やはりSwiftはわかりやすく、かつエラー処理もしっかり書いても、Objective-Cよりコードが少ないので良い。&lt;/p&gt;

&lt;p&gt;以前は結構カメラの起動もコードの読み取りも時間がかかっていたのだが、今回はかなりスピードアップした感じがした。iPhoneのカメラの進化もすごいということか。ただ、バッテリーには優しくないので常に使うのは厳しそう・・・&lt;/p&gt;

&lt;p&gt;&lt;del&gt;あと、カメラをわざわざ起動しなくても画像を直接認識してくれるようになって欲しい。&lt;/del&gt;
(6/17追記：方法が判ったので&lt;a href=&#34;../qr-reader/&#34;&gt;その2&lt;/a&gt;を作成した)&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/technotes/tn2325/_index.html&#34;&gt;AV Foundation iOS Machine Readable Code Detection FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:a5cf36e06059d329ad01bad1fdbb45c5&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/CodeReader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;カメラ不要なバージョンは&lt;a href=&#34;../qr-reader/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UnityからOpenCVを利用する(iOS)</title>
      <link>https://mike-neko.github.io/blog/unity-opencv/</link>
      <pubDate>Tue, 07 Jun 2016 00:56:50 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/unity-opencv/</guid>
      <description>

&lt;h2 id=&#34;概要:571ed67a2af601d4cff30db4980e4e99&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;UnityからiOSのネイティブプラグイン経由で&lt;code&gt;OpenCV&lt;/code&gt;でカメラを利用するサンプル。&lt;/p&gt;

&lt;p&gt;内容としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OpenCV経由で端末のカメラ画像を取得&lt;/li&gt;
&lt;li&gt;取得した画像をOpenCVで処理（シンプルにグレースケールへ変換）&lt;/li&gt;
&lt;li&gt;ネイティブプラグイン経由でUnity側(C#)へ渡す&lt;/li&gt;
&lt;li&gt;Unity側でテクスチャを生成して表示する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れになる。&lt;/p&gt;

&lt;h2 id=&#34;手順:571ed67a2af601d4cff30db4980e4e99&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;opencvのフレームワークの準備:571ed67a2af601d4cff30db4980e4e99&#34;&gt;OpenCVのフレームワークの準備&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://opencv.org/downloads.html&#34;&gt;公式のダウンロードページ&lt;/a&gt;から&lt;code&gt;for iOS&lt;/code&gt;の&lt;strong&gt;Ver.2系&lt;/strong&gt;をダウンロードする&lt;br /&gt;
（サンプルでは&lt;a href=&#34;https://sourceforge.net/projects/opencvlibrary/files/opencv-ios/2.4.13/opencv2.framework.zip/download&#34;&gt;Ver.2.4.13&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ダウンロードしたファイルを解凍して&lt;code&gt;opencv2.framework&lt;/code&gt;を取り出しておく&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、Ver.2を利用したのは、作成時点ではVer.3だとエラーが出てしまったので。
多分ソースからビルドするかバージョン上がれば、Ver.3系でも問題ないかと。&lt;/p&gt;

&lt;h3 id=&#34;iosネイティブ部分のソースを作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;iOSネイティブ部分のソースを作成&lt;/h3&gt;

&lt;p&gt;OpenCVがC++なので、言語は&lt;code&gt;Objective-C++&lt;/code&gt;を利用する。&lt;br /&gt;
(残念ながらSwiftはC++を扱うことができないのでObjC一択)&lt;/p&gt;

&lt;p&gt;それに伴い、忘れずにファイルの拡張子を&lt;code&gt;.mm&lt;/code&gt;にしておくこと。&lt;br /&gt;
ただその場合、ヘッダファイル（&lt;code&gt;.hpp&lt;/code&gt;）はUnityがプラグインのファイルとして認識してくれないので、
今回は一つのファイルに収まるように書いている。&lt;br /&gt;
（通常の&lt;code&gt;.h&lt;/code&gt;はちゃんと認識してくれるのに・・・）&lt;/p&gt;

&lt;p&gt;プラグインの呼び出しは以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[iOS]
OpenCV(C++)での処理
 |
ObjC++のクラスでラップ
 |
Cの関数でラッパークラスをエクスポート
 |
[Unity]
C#でDLLimportして呼び出し
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ObjC++で一旦ラップしているのは、OpenCV部分の開発は別にXCode上で行う為。
ただ、場合によってはメソッド呼び出しが遅いのでそこは注意。&lt;/p&gt;

&lt;p&gt;ネイティブ側のソースの全文は以下の通り。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/bf258536e5414e25b1e147c8b5e7834d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h4 id=&#34;通常のopencv周りの処理-4-51行目あたり:571ed67a2af601d4cff30db4980e4e99&#34;&gt;通常のOpenCV周りの処理（4〜51行目あたり）&lt;/h4&gt;

&lt;p&gt;ややこしいのが、C++はARC管理外の為、手動でメモリ管理が必要。
今回はメモリの確保/破棄をラッパークラスの初期化/破棄と合わせて、
ラッパークラスの生存期間とOpenCVのオブジェクトの生存期間が一致するようにしてある。&lt;/p&gt;

&lt;p&gt;カメラの画像の取得は、初期化と同時に&lt;code&gt;cv::VideoCapture&lt;/code&gt;を生成し、
その後は毎フレーム&lt;code&gt;*camera &amp;gt;&amp;gt; img&lt;/code&gt;で画像を読み込んでいる。&lt;/p&gt;

&lt;p&gt;この時、取得された画像のフォーマットは&lt;code&gt;BGR&lt;/code&gt;なのがポイント。
最終的にUnityのテクスチャのサイズとフォーマット&lt;code&gt;RGBA&lt;/code&gt;に変換してUnity側へ渡す。&lt;br /&gt;
（Unity側では&lt;code&gt;ARGB&lt;/code&gt;の表記なので、最初それで変換してハマってた・・・）&lt;/p&gt;

&lt;h4 id=&#34;プラグインのエントリポイントを用意-54-77行目あたり:571ed67a2af601d4cff30db4980e4e99&#34;&gt;プラグインのエントリポイントを用意（54〜77行目あたり）&lt;/h4&gt;

&lt;p&gt;用意するのはラッパークラス&lt;code&gt;VideoCapture&lt;/code&gt;の生成、毎フレーム呼び出す用、破棄の3つのCの関数。&lt;/p&gt;

&lt;p&gt;これを55〜59行目のように宣言してC#へエクスポートする。
このファイルはC++の扱いになっているので&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;が必要。&lt;br /&gt;
（逆に言うと、C#からはこれ以外が見えない状態となっている）&lt;/p&gt;

&lt;p&gt;関数の本体は61行目以降にあるように、単純にブリッジしているだけ。&lt;/p&gt;

&lt;h3 id=&#34;unityでネイティブプラグイン作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;Unityでネイティブプラグイン作成&lt;/h3&gt;

&lt;h4 id=&#34;unityにネイティブのソース類を組み込む:571ed67a2af601d4cff30db4980e4e99&#34;&gt;Unityにネイティブのソース類を組み込む&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Assets&lt;/code&gt;直下に&lt;code&gt;Plugins&lt;/code&gt;フォルダを作る&lt;/li&gt;
&lt;li&gt;作成した&lt;code&gt;Plugins&lt;/code&gt;フォルダにiOSネイティブ用のソースファイルを入れる&lt;br /&gt;
Unityのエディタ上のインスペクタの設定を念のため確認

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Select platforms for plugin&lt;/code&gt;：iOS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Platform settings&lt;/code&gt;：チェック不要&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;Plugins&lt;/code&gt;フォルダにダウンロードしておいた&lt;code&gt;opencv2.framework&lt;/code&gt;を丸ごと入れる&lt;br /&gt;
Unity上ではフォルダとして認識されて、中にいろいろあればOK&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;コンポーネントの作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;コンポーネントの作成&lt;/h4&gt;

&lt;p&gt;ネイティブの画像データからテクスチャを生成し、
そのテクスチャを指定した&lt;code&gt;Renderer&lt;/code&gt;のマテリアルにセットするコンポーネントを作成。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5ea8d851f18b163ae6a70f6a05ccd4d1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;当然、ネイティブプラグイン部分は、iOS上での実行時しか動かないので、
該当部分は&lt;code&gt;#if UNITY_IOS&lt;/code&gt;〜&lt;code&gt;#endif&lt;/code&gt;でエディタ実行時にエラーにならないようにしておく。&lt;/p&gt;

&lt;p&gt;ネイティブ側で準備したエントリポイントを利用する為にインポートの宣言（16〜26行目あたり）が必要。&lt;/p&gt;

&lt;p&gt;Cの関数宣言をそのままC#での宣言にするが、同じデータ型がC#にない場合は対応するデータ型を代わりに指定する。
（今回だと&lt;code&gt;void*&lt;/code&gt;が&lt;code&gt;IntPtr&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;なお、構造体をやりとりするような場合は&lt;code&gt;マーシャリング&lt;/code&gt;が必要となるので結構面倒。&lt;/p&gt;

&lt;p&gt;宣言すれば後は通常のメソッドと同じ様に利用できる。ただし、C側と引数などが異なっていた場合は、
実行時にエラーとなるので注意。&lt;/p&gt;

&lt;p&gt;後は、コンポーネントのライフサイクルと、キャプチャ用とテクスチャのオブジェクトのライフサイクルを一致させればOK。&lt;/p&gt;

&lt;h4 id=&#34;シーン作成:571ed67a2af601d4cff30db4980e4e99&#34;&gt;シーン作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;キャプチャしたテクスチャ用の&lt;code&gt;Material&lt;/code&gt;を作成

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shader&lt;/code&gt;で&lt;code&gt;Unlit/Texture&lt;/code&gt;を選択&lt;br /&gt;
（キャプチャ画像にライトが反映して光らないように）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quad&lt;/code&gt;でテクスチャを貼るオブジェクトを作成

&lt;ul&gt;
&lt;li&gt;Scaleを&lt;code&gt;X:3, Y:4, Z:1&lt;/code&gt;にする&lt;br /&gt;
（数値はキャプチャ画像のアスペクト比と合わせる）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Material&lt;/code&gt;に1で作成したマテリアルをセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プラグインのコンポーネントを追加

&lt;ul&gt;
&lt;li&gt;プラグインの&lt;code&gt;renderTarget&lt;/code&gt;に自身をセット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;感想:571ed67a2af601d4cff30db4980e4e99&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;サンプルでは出てこないけど、C#のアンマネージドの辺りが、ObjCやSwiftに比べると結構大変な気がした。
慣れてないからかも知れないけど、特にメモリ周りやマーシャリングはいずれちゃんと勉強しないと。&lt;/p&gt;

&lt;p&gt;あと、OpenCV周りの細かい挙動もまだ把握しきれていないので調べたい。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:571ed67a2af601d4cff30db4980e4e99&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Unity 5.3.4f1&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:571ed67a2af601d4cff30db4980e4e99&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/UnityOpenCV&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただし、上記ソースには&lt;code&gt;opencv2.framework&lt;/code&gt;が含まれていない。&lt;br /&gt;
（Githubの100MB制限にかかってしまったので）&lt;br /&gt;
動かすには、&lt;code&gt;OpenCVのフレームワークの準備&lt;/code&gt;の項目で準備した
&lt;code&gt;opencv2.framework&lt;/code&gt;を手動で&lt;code&gt;UnityOpenCV/Assets/Plugins/&lt;/code&gt;直下に追加する必要がある。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nginxをhttp2に対応させる</title>
      <link>https://mike-neko.github.io/blog/nginx-http2/</link>
      <pubDate>Fri, 03 Jun 2016 21:29:36 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/nginx-http2/</guid>
      <description>

&lt;h2 id=&#34;概要:6214d744b42492b1045fac72bc277c04&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;以前に構築した&lt;a href=&#34;../docker/&#34;&gt;Dockerでの開発環境&lt;/a&gt;で使ったnginxを&lt;code&gt;http2&lt;/code&gt;に対応させた時のメモ。&lt;/p&gt;

&lt;h3 id=&#34;環境:6214d744b42492b1045fac72bc277c04&#34;&gt;環境&lt;/h3&gt;

&lt;p&gt;ベースは前回構築したnginx+Dockerで通信はオレオレ証明書によるSSLを前提。&lt;/p&gt;

&lt;p&gt;主な変更点は以下の通り&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenSSL 1.0.2&lt;/li&gt;
&lt;li&gt;nginx 1.10.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いずれもhttp2対応させる為にバージョンアップが必要。&lt;/p&gt;

&lt;p&gt;なお、iOSは&lt;strong&gt;iOS9&lt;/strong&gt;からhttp2へ対応している。&lt;/p&gt;

&lt;h2 id=&#34;手順:6214d744b42492b1045fac72bc277c04&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;事前準備:6214d744b42492b1045fac72bc277c04&#34;&gt;事前準備&lt;/h3&gt;

&lt;p&gt;http2での通信かどうかの確認用に以下のChromeのプラグインを入れておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=ja&#34;&gt;HTTP/2 and SPDY indicator&lt;/a&gt;&lt;br /&gt;
（Firefox用もあるみたいなのでお好きな方で）&lt;/p&gt;

&lt;p&gt;http2での通信だと稲妻が青色になるので確認が楽。&lt;/p&gt;

&lt;h3 id=&#34;macでの作業:6214d744b42492b1045fac72bc277c04&#34;&gt;Macでの作業&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OpenSSLを最新にあげる&lt;br /&gt;
OpenSSLの更新方法：&lt;a href=&#34;http://qiita.com/Chrowa3/items/b04e772be959cdda9ac3&#34;&gt;Mac OS X の openssl を最新の状態にする&lt;/a&gt;&lt;br /&gt;
ポイントは&lt;code&gt;upgrade&lt;/code&gt;にすること（普段使う&lt;code&gt;update&lt;/code&gt;ではない）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをアンイストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew uninstall nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install nginx --with-http2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginxのconfを編集&lt;br /&gt;
&lt;code&gt;HTTPS server&lt;/code&gt;の設定が&lt;code&gt;listen  443 ssl;&lt;/code&gt;となっているはずなので、&lt;code&gt;http2&lt;/code&gt;を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
listen  443 ssl http2;
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追加したらnginxを再起動する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ChromeからMacへアクセスしてみて青い稲妻になっていれば&lt;code&gt;nginx&lt;/code&gt;の設定は成功&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ios端末での通信:6214d744b42492b1045fac72bc277c04&#34;&gt;iOS端末での通信&lt;/h3&gt;

&lt;p&gt;iOS9以降の&lt;code&gt;NSURLSession&lt;/code&gt;での通信であれば、特に設定など不要で自動で&lt;code&gt;http2&lt;/code&gt;になる。&lt;/p&gt;

&lt;p&gt;なお、規格上は&lt;code&gt;http&lt;/code&gt;のみでも対応しているがiOSでどうかは未検証。&lt;/p&gt;

&lt;h3 id=&#34;ログ設定:6214d744b42492b1045fac72bc277c04&#34;&gt;ログ設定&lt;/h3&gt;

&lt;p&gt;iOS端末からの通信も&lt;code&gt;http2&lt;/code&gt;になっているかの確認は、&lt;code&gt;nginx&lt;/code&gt;のログで判別する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http2&lt;/code&gt;の場合は、&lt;code&gt;log_format&lt;/code&gt;の&lt;code&gt;$http2&lt;/code&gt;に&lt;code&gt;h2&lt;/code&gt;と入ってくる。&lt;br /&gt;
詳細は以下のページを参考に&lt;br /&gt;
&lt;a href=&#34;http://d.hatena.ne.jp/ASnoKaze/20150818/1439896998&#34;&gt;nginxでアクセスログにhttp2の通信か出力する&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;過去情報:6214d744b42492b1045fac72bc277c04&#34;&gt;過去情報&lt;/h2&gt;

&lt;p&gt;標準の&lt;code&gt;nginx&lt;/code&gt;に&lt;code&gt;http2&lt;/code&gt;モジュールがないと思っていたら、
実はちゃんとあったので訂正。&lt;/p&gt;

&lt;p&gt;もったいないので、&lt;code&gt;nginx-full&lt;/code&gt;の情報を残しておく。&lt;/p&gt;

&lt;h3 id=&#34;nginx-full:6214d744b42492b1045fac72bc277c04&#34;&gt;nginx-full&lt;/h3&gt;

&lt;p&gt;通常の&lt;code&gt;Homebrew&lt;/code&gt;の&lt;code&gt;nginx&lt;/code&gt;ではオプションのモジュールが少ないので、
標準では足りないモジュールをインストールしたい時は&lt;code&gt;nginx-full&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;p&gt;例） nginxをhttp2モジュール付きでインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew tap homebrew/nginx
brew install nginx-full --with-http2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールの一覧は以下で確認すること。
（&lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_v2_module.html&#34;&gt;公式&lt;/a&gt;のモジュールの情報?とは違うようなのでこれで確認）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew info nginx-full
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考リンク:6214d744b42492b1045fac72bc277c04&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kannokanno.hatenablog.com/entry/2014/02/10/134920&#34;&gt;Mac - homebrewでnginxを入れるときはnginx-fullを入れよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:6214d744b42492b1045fac72bc277c04&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.5&lt;/li&gt;
&lt;li&gt;Xcode 7.3.1&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect APNs編</title>
      <link>https://mike-neko.github.io/blog/perfect-push/</link>
      <pubDate>Mon, 11 Apr 2016 19:45:28 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-push/</guid>
      <description>

&lt;h2 id=&#34;概要:895c24bcebc238bc55d3833602dde15b&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその3&lt;/p&gt;

&lt;p&gt;今回はiOSのプッシュ通知を送信する方法について&lt;/p&gt;

&lt;p&gt;Perfectは最新のAPNsの通信形式に対応していて、細かなエラーレスポンスを取れるのがメリット。
なので、開発用としては大変使いやすい。&lt;/p&gt;

&lt;h2 id=&#34;手順:895c24bcebc238bc55d3833602dde15b&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;Push通知はサーバ側で微妙に必要とされる証明書が変わったりするのがややこしいところ。
PerfectでPush通知を送るのに必要なものは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サーバ

&lt;ul&gt;
&lt;li&gt;APNs用証明書と秘密鍵&lt;/li&gt;
&lt;li&gt;CAルート証明書&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;クライアント

&lt;ul&gt;
&lt;li&gt;プロビジョニングプロファイル&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;登録-プロビジョニングプロファイルと証明書の作成:895c24bcebc238bc55d3833602dde15b&#34;&gt;登録〜プロビジョニングプロファイルと証明書の作成&lt;/h3&gt;

&lt;p&gt;証明書の取得には&lt;code&gt;AppID&lt;/code&gt;の登録やら結構手順があって大変だが、まずは以下のリンク先の通りに作業をすればOK。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Qiita:&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb#7-apns%E7%94%A8%E8%A8%BC%E6%98%8E%E6%9B%B8p12%E3%81%AE%E4%BD%9C%E6%88%90&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なお、最後の手順の&lt;code&gt;APNs用証明書(.p12)&lt;/code&gt;を書き出す時のファイル名は&lt;code&gt;apns.p12&lt;/code&gt;とする&lt;/p&gt;

&lt;h3 id=&#34;サーバ用の証明書の準備:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバ用の証明書の準備&lt;/h3&gt;

&lt;h4 id=&#34;apns用証明書-pem:895c24bcebc238bc55d3833602dde15b&#34;&gt;APNs用証明書(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_cert.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -clcerts -nokeys -out apns_dev_cert.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;秘密鍵-pem:895c24bcebc238bc55d3833602dde15b&#34;&gt;秘密鍵(.pem)&lt;/h4&gt;

&lt;p&gt;ターミナルで以下を実行して&lt;code&gt;apns_dev_key.pem&lt;/code&gt;を作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd [apns.p12を書き出した場所]
openssl pkcs12 -nocerts -out apns_dev_key.pem -in apns.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enter PEM pass phrase:&lt;/code&gt;と秘密鍵のパスフレーズを聞かれるので、適当なものを入れる。
後でサーバに設定するので忘れないように・・・&lt;/p&gt;

&lt;h4 id=&#34;caルート証明書:895c24bcebc238bc55d3833602dde15b&#34;&gt;CAルート証明書&lt;/h4&gt;

&lt;p&gt;APNsとサーバで接続する為に&lt;code&gt;Entrust&lt;/code&gt;の証明書が必要なので、以下からダウンロードする。&lt;/p&gt;

&lt;p&gt;Entrust.net Certificate Authority (2048)：
&lt;a href=&#34;https://www.entrust.com/root-certificates/entrust_2048_ca.cer&#34;&gt;entrust_2048_ca.cer&lt;/a&gt;&lt;br /&gt;
（&lt;a href=&#34;https://www.entrust.com/get-support/ssl-certificate-support/root-certificate-downloads/&#34;&gt;Entrustの証明書DLページ&lt;/a&gt; - Entrust.net Certificate Authority (2048) - Download）&lt;/p&gt;

&lt;h3 id=&#34;iosアプリの作成:895c24bcebc238bc55d3833602dde15b&#34;&gt;iOSアプリの作成&lt;/h3&gt;

&lt;p&gt;とりあえず、必要最低限でPush通知を受信できる状態にする。
デバイストークンの更新等には未対応なので注意。&lt;/p&gt;

&lt;h4 id=&#34;プロジェクトの設定:895c24bcebc238bc55d3833602dde15b&#34;&gt;プロジェクトの設定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ダウンロードしたプロビジョニングプロファイルをダブルクリックしてインストール&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bundle Identifier&lt;/code&gt;を&lt;code&gt;AppID&lt;/code&gt;取得時のものと一緒にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Provisioning Profile&lt;/code&gt;をインストールしたプロビジョニングプロファイルにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;アプリの実装:895c24bcebc238bc55d3833602dde15b&#34;&gt;アプリの実装&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;AppDelegate&lt;/code&gt;に以下の実装をする&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;でPush通知の登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRegisterForRemoteNotificationsWithDeviceToken&lt;/code&gt;でデバイストークンを受信&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;コードにすると以下の通り
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/8000f2d8dc5b37773323065e867e2e4d.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これを実機上で実行すると、端末のデバイストークンがログ出力される。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;デバッグ実行を停止させると、Push通知が届かない場合があるので、デバッグ実行したままにするか
再度実機上からアクティブにしてバックグラウンドに落としておく。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;また、マルチタスクから終了させても届かない場合があるので、注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;サーバへ証明書の設置:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバへ証明書の設置&lt;/h3&gt;

&lt;p&gt;基礎編の&lt;a href=&#34;../perfect-2/&#34;&gt;ビルドでファイルを配置する&lt;/a&gt;の方法で証明書を配置する&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対象のファイル

&lt;ul&gt;
&lt;li&gt;apns_dev_cert.pem&lt;/li&gt;
&lt;li&gt;apns_dev_key.pem&lt;/li&gt;
&lt;li&gt;entrust_2048_ca.cer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Copy Files&lt;/code&gt;の設定

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;:Products Directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subpath&lt;/code&gt;:空白&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（&lt;code&gt;webroot&lt;/code&gt;へのドキュメントの配置とは別に&lt;code&gt;Copy Files&lt;/code&gt;を設定する）&lt;/p&gt;

&lt;h3 id=&#34;サーバの実装:895c24bcebc238bc55d3833602dde15b&#34;&gt;サーバの実装&lt;/h3&gt;

&lt;p&gt;サーバ側での実装は主に2つ。
ひとつは証明書を&lt;code&gt;NotificationPusher&lt;/code&gt;に初期設定するのと、
もう一つは実際にPush通知を送る実装。&lt;/p&gt;

&lt;p&gt;初期設定は一度だけ行えばOKなので、（実環境では送信毎にチェックした方が良いけど）
今回は&lt;code&gt;PerfectServerModuleInit&lt;/code&gt;で行う。&lt;/p&gt;

&lt;p&gt;Push通知の送信は、&lt;code&gt;IOSNotificationItem&lt;/code&gt;の配列
（ここのenumの使い方は参考になる）で送信内容を作成し、
&lt;code&gt;NotificationPusher().pushIOS&lt;/code&gt;で送信を行う。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/821b3dced86e0eb741563e23c43fed0f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;この実装でサーバにアクセスする度に、Push通知が端末へ送られる。
送信時の結果は、ブラウザに表示される（エラーであればエラー内容）。&lt;/p&gt;

&lt;h2 id=&#34;感想:895c24bcebc238bc55d3833602dde15b&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回の一番大変だったのはEntrustの証明書の置き場が変わっていたこと。。。
逆に言えばそれ以外はとても簡単にPush通知を送れる環境を作れた感じ。&lt;/p&gt;

&lt;p&gt;巷にはたくさんAPNsに対応したフレームワークやサービスがあるけど、
開発用としては、このPerfectが一番手軽で確実だと思う。
なにせ環境構築は不要で、Xcodeでプロジェクトを作って
少し実装すれば良いだけという素晴らしさ！&lt;/p&gt;

&lt;p&gt;もちろん、商用はAWSとかがオススメだけど。。。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:895c24bcebc238bc55d3833602dde15b&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/natsumo/items/d5cc1d0be427ca3af1cb&#34;&gt;プッシュ通知に必要な証明書の作り方2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:895c24bcebc238bc55d3833602dde15b&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;li&gt;iOS 9.3.2&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iPhone 6+&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 基礎編&lt;a href=&#34;../perfect-2/&#34;&gt;その2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect 基礎編</title>
      <link>https://mike-neko.github.io/blog/perfect-2/</link>
      <pubDate>Sun, 10 Apr 2016 23:09:11 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-2/</guid>
      <description>

&lt;h2 id=&#34;概要:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその2&lt;/p&gt;

&lt;p&gt;基礎編ではルーティングやリクエストの処理方法のあたりまで&lt;/p&gt;

&lt;h2 id=&#34;urlルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;URLルーティング&lt;/h2&gt;

&lt;p&gt;サンプルを見ると、ルーティングは大きくわけて&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mustache&lt;/code&gt;テンプレートエンジンのページを&lt;code&gt;PageHandler&lt;/code&gt;に登録&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Routing&lt;/code&gt;に&lt;code&gt;RequestHandler&lt;/code&gt;を登録&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2種類がある様子。&lt;/p&gt;

&lt;p&gt;設定はいずれも&lt;code&gt;PerfectServerModuleInit()&lt;/code&gt;の中で行う。&lt;/p&gt;

&lt;h3 id=&#34;pagehandlerでのルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;PageHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;Webアプリなどでの固定ページの表示向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/Authenticator/#authenticator&#34;&gt;Authenticator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;http://0.0.0.0:8181/admin/&lt;/code&gt;というページを表示させたい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;表示するページを-mustache-のテンプレートで作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;表示するページを&lt;code&gt;mustache&lt;/code&gt;のテンプレートで作成&lt;/h4&gt;

&lt;p&gt;例だと&lt;code&gt;admin.mustache&lt;/code&gt;というファイル名にし、先頭のところで&lt;code&gt;handler:AdminHandler&lt;/code&gt;と指定する。&lt;br /&gt;
ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先頭の&lt;code&gt;handler:&lt;/code&gt;の部分で対応する&lt;code&gt;PageHandler&lt;/code&gt;の名前を指定&lt;/li&gt;
&lt;li&gt;ファイル名がアクセスする際のディレクトリと対応&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;テンプレートをプロジェクトへ追加:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;テンプレートをプロジェクトへ追加&lt;/h4&gt;

&lt;p&gt;後述の小ネタにある「ドキュメントの配置」の方法で、&lt;code&gt;admin.mustache&lt;/code&gt;がドキュメントルートへ配置されるように設定する。&lt;/p&gt;

&lt;h4 id=&#34;pagehandler-を作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;&lt;code&gt;PageHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;ページにアクセスがあった時の処理を行う為の&lt;code&gt;PageHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;AdminHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;作ったクラスを&lt;code&gt;PageHandlerRegistry.addPageHandler&lt;/code&gt;で登録する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PageHandlerRegistry.addPageHandler(&amp;quot;AdminHandler&amp;quot;) {
// (r: WebResponse) -&amp;gt; PageHandler in
  return AdminHandler()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addPageHandler&lt;/code&gt;の一つ目の引数の文字列は、テンプレートの中で指定したhandlerと同じにする&lt;/li&gt;
&lt;li&gt;リクエストの詳細な情報で分岐させたい時は、コメントアウトを外し&lt;code&gt;WebResponse&lt;/code&gt;の情報を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;PageHandler&lt;/code&gt;の中では、テンプレートに流し込む変数のDictionaryを生成する。&lt;/p&gt;

&lt;h3 id=&#34;requesthandlerでのルーティング:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;RequestHandlerでのルーティング&lt;/h3&gt;

&lt;p&gt;APIとかブログのような動的なページ向け。&lt;br /&gt;
公式の参考になるサンプルは&lt;a href=&#34;https://github.com/PerfectlySoft/PerfectExamples/blob/master/Sources/URL%20Routing/#url-routing&#34;&gt;URL Routing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例えば、REST APIで&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;の&lt;code&gt;GET&lt;/code&gt;でmikeというユーザの情報を取得したい時の流れとしては、&lt;/p&gt;

&lt;h4 id=&#34;ルーティングを設定:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ルーティングを設定&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing&lt;/code&gt;でルーティングのルール（HTTPのメソッドやURLなど）を&lt;code&gt;RouteMap&lt;/code&gt;を使って設定する。&lt;/p&gt;

&lt;p&gt;例だと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Routing.Routes[&amp;quot;GET&amp;quot;, &amp;quot;/user/{id}&amp;quot;] = { _ in return UserHandler() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。ポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPのメソッドが指定できる&lt;br /&gt;
（指定する場合は一つ目にする）&lt;/li&gt;
&lt;li&gt;URL部分は配列で複数指定できる&lt;/li&gt;
&lt;li&gt;ルール部分では&lt;code&gt;{}&lt;/code&gt;で囲うと&lt;code&gt;RequestHandler&lt;/code&gt;へ値を渡せる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;が使える&lt;/li&gt;
&lt;li&gt;クロージャで対応する&lt;code&gt;RequestHandler&lt;/code&gt;を指定する&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;requesthandler-を作成:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;&lt;code&gt;RequestHandler&lt;/code&gt;を作成&lt;/h4&gt;

&lt;p&gt;クライアントへ返すレスポンスを生成する為の&lt;code&gt;RequestHandler&lt;/code&gt;を継承したクラスを作る。&lt;br /&gt;
（クラス名は任意だが、わかりやすいように&lt;code&gt;UserHandler&lt;/code&gt;としておく）&lt;/p&gt;

&lt;p&gt;URLで指定されたユーザ名をそのままJSONで返す場合は以下の感じ。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/55c5d91b5b1d7a309289f5d0b2a12edd.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これで、&lt;code&gt;http://0.0.0.0:8181/user/mike&lt;/code&gt;にアクセスすると&lt;code&gt;{ user: &amp;quot;mike&amp;quot; }&lt;/code&gt;と返ってくる。&lt;/p&gt;

&lt;h4 id=&#34;ルーティング設定の確認:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ルーティング設定の確認&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Routing.Routes.description&lt;/code&gt;で設定をダンプできる。これ、かなり便利！&lt;/p&gt;

&lt;h2 id=&#34;リクエストの処理:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;リクエストの処理&lt;/h2&gt;

&lt;p&gt;URLパラメータやPOSTのボディの中身は、&lt;code&gt;WebRequest&lt;/code&gt;の中に格納されている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://0.0.0.0:8181/hoge?key1=value1&amp;amp;key2=value2&lt;/code&gt;とした場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  request.queryString()  // key1=value1&amp;amp;key2=value2
  request.queryParams    // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.params()       // [(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;), (&amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;)]
  request.param(&amp;quot;key1&amp;quot;)  // value1
  request.param(&amp;quot;key3&amp;quot;, defaultValue: &amp;quot;value3&amp;quot;)  // value3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POSTで&lt;code&gt;{ &amp;quot;count&amp;quot;=100 }&lt;/code&gt;を送った場合、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func handleRequest(request: WebRequest, response: WebResponse) {
  let body = request.postBodyString
  let json = try! JSONDecoder().decode(body) as! JSONDictionaryType
  json[&amp;quot;count&amp;quot;]  // 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じで取得できる。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;ドキュメントの配置:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ドキュメントの配置&lt;/h3&gt;

&lt;p&gt;Xcode経由で起動している時に、サーバからドキュメントへアクセスできるようにする方法。なお、ドキュメントルートはデフォルトで&lt;code&gt;./webroot/&lt;/code&gt;が設定されている。&lt;/p&gt;

&lt;h4 id=&#34;documentrootのパスを変更する:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;DocumentRootのパスを変更する&lt;/h4&gt;

&lt;p&gt;状況によってはソースから改変するのもアリだが、起動時に立ち上がるGUIから変更するのが手軽。&lt;code&gt;Choose...&lt;/code&gt;でフォルダ位置を選択できる。ただし、注意すべきなのは&lt;code&gt;Document Root&lt;/code&gt;のテキストフィールド内でキー操作(return)しないと変更と認識されずに保存されない点（これにはまってソースまで見てようやく気付いた・・・）。変更後はサーバの再起動が必要（というか勝手にされるはず）。&lt;/p&gt;

&lt;p&gt;この方法だとサーバを起動したままでもドキュメントを変更できるが、一方でパスの設定が必要となる。&lt;/p&gt;

&lt;h4 id=&#34;ビルドでファイルを配置する:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;ビルドでファイルを配置する&lt;/h4&gt;

&lt;p&gt;前回の導入編で使った方法で、デフォルトの&lt;code&gt;./webroot/&lt;/code&gt;を使いたい場合用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作成したプロジェクトを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TARGETS&lt;/code&gt;でプロジェクト名と同じもの、&lt;code&gt;Build Phases&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;左上の&lt;code&gt;＋&lt;/code&gt;をクリックして、&lt;code&gt;New Copy Files Phases&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;で&lt;code&gt;Products Directory&lt;/code&gt;を選択&lt;br /&gt;
&lt;code&gt;Subpath&lt;/code&gt;に&lt;code&gt;webroot&lt;/code&gt;と入力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;の下の方にある&lt;code&gt;＋&lt;/code&gt;をクリックし、追加ファイルを選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;
（プロジェクトに未追加のファイルの場合は&lt;code&gt;Add Other...&lt;/code&gt;からで）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;同一lan内からのアクセス:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;同一LAN内からのアクセス&lt;/h3&gt;

&lt;p&gt;例えば同じルータに繋がっているiPhoneから、Mac上で動いているPerfectのサーバに接続する方法。&lt;/p&gt;

&lt;p&gt;起動時に立ち上がるGUIの&lt;code&gt;Server Address&lt;/code&gt;をMacに割り当てられているIPアドレスに変更すればOK。
（変更後にreturnで確定を忘れずに・・・）
ポートも変更できるが、&lt;code&gt;80&lt;/code&gt;とかはroot権限が必要と怒られて変更できないので注意。&lt;/p&gt;

&lt;p&gt;（今回は既に&lt;a href=&#34;../docker/&#34;&gt;Docker+nginxを構築&lt;/a&gt;してあったので、nginxのリバースプロキシの設定でさくっと対応）&lt;/p&gt;

&lt;h1 id=&#34;感想:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;普段、クライアント（iOSアプリ）側で使っている開発環境と全く同じ環境でサーバの開発が出来るというのは、
想像以上に便利というかストレスフリーな感じ。&lt;/p&gt;

&lt;p&gt;もちろん、PerfectではCocoaが使えないというのはあるし、物足りない感じはしなくも無いが。。。&lt;/p&gt;

&lt;p&gt;ただ、そのあたりのカバーを目指しての&lt;code&gt;Perfect&lt;/code&gt;という命名なんだろうと勝手に想像。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chrismanahan.com/creating-a-web-service-swift-perfect&#34;&gt;Creating a Web Service for Your App in Swift with Perfect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:421c6f0fa67c2dade0dfb3230a5c0297&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Xcode 7.3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect 導入編&lt;a href=&#34;../perfect-1/&#34;&gt;その1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perfect APNs編&lt;a href=&#34;../perfect-push/&#34;&gt;その3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Perfect 導入編</title>
      <link>https://mike-neko.github.io/blog/perfect-1/</link>
      <pubDate>Fri, 08 Apr 2016 22:25:06 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/perfect-1/</guid>
      <description>

&lt;h2 id=&#34;概要:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;サーバーサイドSwiftフレームワークの&lt;a href=&#34;https://perfect.org/&#34;&gt;Perfect&lt;/a&gt;の使い方のメモその1&lt;/p&gt;

&lt;p&gt;導入編ではベースとなるプロジェクトを一から作るあたりまで&lt;/p&gt;

&lt;h2 id=&#34;きっかけ:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;きっかけ&lt;/h2&gt;

&lt;p&gt;Perfectがついに1.0になったというのを聞きつけてGitHubのREADMEを見てると、、、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;WebSockets &amp;amp; iOS Push Notifications&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Perfect now includes a &lt;strong&gt;WebSockets&lt;/strong&gt; server and support for handling your own server-side &lt;strong&gt;iOS push notifications&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ってのを発見！&lt;/p&gt;

&lt;p&gt;ちょうど、Push通知周りの実験をしたかったこともあり、さっそく手を出すことに〜&lt;/p&gt;

&lt;h2 id=&#34;手順:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;手順&lt;/h2&gt;

&lt;h3 id=&#34;下準備:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;下準備&lt;/h3&gt;

&lt;h4 id=&#34;github-https-github-com-perfectlysoft-perfect-からperfectをダウンロードする:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;&lt;a href=&#34;https://github.com/PerfectlySoft/Perfect&#34;&gt;GitHub&lt;/a&gt;からPerfectをダウンロードする&lt;/h4&gt;

&lt;p&gt;ダウンロードしたら適当な場所に展開しておく&lt;/p&gt;

&lt;h4 id=&#34;xcodeにテンプレートを追加:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;Xcodeにテンプレートを追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;~/Library/Developer/Xcode&lt;/code&gt;をFinderで開く&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Xcode&lt;/code&gt;直下に(無ければ)&lt;code&gt;Templates&lt;/code&gt;というフォルダを作成&lt;/li&gt;
&lt;li&gt;その&lt;code&gt;Templates&lt;/code&gt;直下に(無ければ)&lt;code&gt;Project Template&lt;/code&gt;というフォルダを作成&lt;/li&gt;
&lt;li&gt;ダウンロードしておいたPerfectのプロジェクトの中（&lt;code&gt;Perfect-master/Extras/Xcode Templates/Perfect/&lt;/code&gt;）にある&lt;code&gt;Perfect Server Framework.xctemplate&lt;/code&gt;のフォルダを丸ごとコピー&lt;/li&gt;
&lt;li&gt;3で作ったフォルダに4のフォルダを貼り付け&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;プロジェクトの作成:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;プロジェクトの作成&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;ワークスペース名：&lt;code&gt;SmapleBasePerfect&lt;/code&gt;&lt;br /&gt;
 プロジェクト名：&lt;code&gt;SampleServer&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
で作成する前提での手順&lt;/p&gt;

&lt;h4 id=&#34;ワークスペースの作成:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;ワークスペースの作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;File&lt;/code&gt;-&lt;code&gt;New&lt;/code&gt;-&lt;code&gt;Workspace...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;ワークスペース名と保存先のフォルダを選択(作成)して&lt;code&gt;Save&lt;/code&gt;&lt;br /&gt;
（ワークスペースはプロジェクトと違ってフォルダは自動作成されないので注意）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自動で空のワークスペースの画面が開かれるので、そのままの状態で次の手順へ&lt;/p&gt;

&lt;h4 id=&#34;プロジェクトの作成-1:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;プロジェクトの作成&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;File&lt;/code&gt;-&lt;code&gt;New&lt;/code&gt;-&lt;code&gt;Project...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側の&lt;code&gt;OS X&lt;/code&gt;-&lt;code&gt;Project Template&lt;/code&gt;の中から&lt;code&gt;Perfect Server Framework&lt;/code&gt;を選択して&lt;code&gt;Next&lt;/code&gt;（下図）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/template.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;プロジェクト名などを適宜入力して&lt;code&gt;Next&lt;/code&gt;&lt;br /&gt;
（プロジェクト名はワークスペースと同じにできない）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add to:&lt;/code&gt;でワークスペース名を選択する&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存先を選択して&lt;code&gt;Create&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;デフォルトで下のようなプロジェクトが生成される
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/project.png&#34; /&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;h4 id=&#34;perfectを追加:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;Perfectを追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;ダウンロードしておいたPerfectのプロジェクト直下にある&lt;code&gt;PerfectLib&lt;/code&gt;と&lt;code&gt;PerfectServer&lt;/code&gt;のフォルダを丸ごとコピー&lt;/li&gt;
&lt;li&gt;プロジェクトのフォルダと同じ階層に貼り付け&lt;/li&gt;
&lt;li&gt;XcodeのProject Navigator(上のイメージの部分)の何もないところで右クリック&lt;/li&gt;
&lt;li&gt;出てきたメニューから&lt;code&gt;Add files to &amp;quot;ワークスペース名&amp;quot;...&lt;/code&gt;を選択&lt;br /&gt;
（もしプロジェクト名が出てきたら3からやり直し）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Copy items into ...&lt;/code&gt;はチェック無、&lt;code&gt;Create groups ...&lt;/code&gt;にチェック有にする&lt;br /&gt;
（無い場合は&lt;code&gt;Option&lt;/code&gt;をクリック）&lt;/li&gt;
&lt;li&gt;1と2でコピーしたフォルダの中から&lt;code&gt;PerfectLib.xcodeproj&lt;/code&gt;を選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PerfectServer.xcodeproj&lt;/code&gt;についても3からの同じ手順で追加&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;スキームの設定:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;スキームの設定&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Xcodeのメニューの&lt;code&gt;Product&lt;/code&gt;-&lt;code&gt;Scheme&lt;/code&gt;-&lt;code&gt;Manage Schemes...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;プロジェクト名と同じスキームを選択して&lt;code&gt;Edit...&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;左側で&lt;code&gt;Run&lt;/code&gt;、右側の&lt;code&gt;Info&lt;/code&gt;タグを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executable&lt;/code&gt;で&lt;code&gt;PerfectServer HTTP.app&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;下の方にある&lt;code&gt;Shared&lt;/code&gt;にチェック&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Close&lt;/code&gt;で閉じる&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;フレームワークの追加:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;フレームワークの追加&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;作成したプロジェクトを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TARGETS&lt;/code&gt;でプロジェクト名と同じもの、&lt;code&gt;General&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linked Frameworks and Libraries&lt;/code&gt;の&lt;code&gt;＋&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PerfectLib.framework&lt;/code&gt;で&lt;code&gt;OSX&lt;/code&gt;の方を選択して&lt;code&gt;Add&lt;/code&gt;
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-04-08-perfect-1/framework.png&#34; /&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;ドキュメントを配置:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;ドキュメントを配置&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Build Phases&lt;/code&gt;タブを選択&lt;/li&gt;
&lt;li&gt;左上の&lt;code&gt;＋&lt;/code&gt;をクリックして、&lt;code&gt;New Copy Files Phases&lt;/code&gt;を選択&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Destination&lt;/code&gt;で&lt;code&gt;Products Directory&lt;/code&gt;を選択&lt;br /&gt;
&lt;code&gt;Subpath&lt;/code&gt;に&lt;code&gt;webroot&lt;/code&gt;と入力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt;の下の方にある&lt;code&gt;＋&lt;/code&gt;をクリックし、&lt;code&gt;index.mustache&lt;/code&gt;を選択して&lt;code&gt;Add&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;動作確認:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;Xcodeで&lt;code&gt;SampleServer&lt;/code&gt;のスキームで&lt;code&gt;Run&lt;/code&gt;して、GUIが立ち上がるとサーバが動作した状態となる。&lt;/p&gt;

&lt;p&gt;その状態で&lt;code&gt;http://0.0.0.0:8181/&lt;/code&gt;にアクセスして、「Hello, world!」と出ればひとまずOK。&lt;/p&gt;

&lt;h1 id=&#34;感想:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;意外に日本語の、特にMac上で動かす場合の資料が少なくて苦労した。&lt;br /&gt;
それとこういうのを触る度にサーバ周りの知識が足りないのを痛感する・・・&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://code-me-dirty.blogspot.jp/2016/02/creating-perfect-swift-server.html&#34;&gt;Create a Perfect Swift Server Project(from scratch) in Xcode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;OS X 10.11.4&lt;/li&gt;
&lt;li&gt;Xcode 7.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:e823dad6a53c6c55cc48d4a6d6460216&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/SmapleBasePerfect&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perfect 基礎編&lt;a href=&#34;../perfect-2/&#34;&gt;その2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perfect APNs編&lt;a href=&#34;../perfect-push/&#34;&gt;その3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker構築メモ</title>
      <link>https://mike-neko.github.io/blog/docker/</link>
      <pubDate>Mon, 04 Apr 2016 00:35:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/docker/</guid>
      <description>

&lt;h2 id=&#34;概要:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS用のサーバ環境をDockerでローカルに構築した時のメモ。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;なお、ローカルの開発用ということでセキュリティは考慮していないので注意&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;要件:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;要件&lt;/h3&gt;

&lt;p&gt;主にAPIでサーバとやりとりするアプリの開発用なので以下の感じ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PHPとDBが使えること&lt;/li&gt;
&lt;li&gt;同一LAN内の別の端末からアクセスできること&lt;/li&gt;
&lt;li&gt;SSLが使えること（iOS用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;環境:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;環境&lt;/h3&gt;

&lt;h4 id=&#34;構成イメージ:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;構成イメージ&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Mac   (192.168.0.2) == ルータ(192.168.0.1) == iPhone(192.168.0.3)  
｜  
VM    (192.168.99.1)  
｜  
Docker(192.168.99.100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;()内はIPアドレス&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ゴールは、iPhone上から&lt;code&gt;https://192.168.0.2&lt;/code&gt;へアクセスするとページが表示(APIの通信)できればOK。&lt;/p&gt;

&lt;h4 id=&#34;mac上-ホストos:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;Mac上(ホストOS)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;MacOS 10.11.3(El Capitan)&lt;/li&gt;
&lt;li&gt;VirtualBox 5.0.14&lt;/li&gt;
&lt;li&gt;DockerToolBox 1.10.2&lt;/li&gt;
&lt;li&gt;nginx 1.8.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;docker上-ゲストos:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;Docker上(ゲストOS)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;PHP 5系の最新&lt;br /&gt;
(Xdebug)&lt;/li&gt;
&lt;li&gt;MariaDB&lt;br /&gt;
(phpmyadmin)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;手順:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;手順&lt;/h1&gt;

&lt;h3 id=&#34;dockerのインストール:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;Dockerのインストール&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/products/docker-toolbox&#34;&gt;公式&lt;/a&gt;から&lt;code&gt;DockerToolBox&lt;/code&gt;をダウンロードしてインストールを実行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;途中で&lt;code&gt;Docker Quickstart Terminal&lt;/code&gt;のアイコンがでてきたら起動させる&lt;br /&gt;
（忘れたらアプリケーションにもあるのでそちらから）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;すると勝手にVM作成やらネットワーク設定をしてくれる親切設計なのでクジラが出てくるまで待つ&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;dockercomposeの設定:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;DockerComposeの設定&lt;/h3&gt;

&lt;p&gt;Dockerはコンテナをパーツのように組み合わせて環境を作っていく。&lt;/p&gt;

&lt;p&gt;そのコンテナを作成する際の基本的な流れは&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使いたいもののイメージを見つける&lt;br /&gt;
(無ければ&lt;code&gt;Dockerfile&lt;/code&gt;を自力で書く)&lt;/li&gt;
&lt;li&gt;タグを指定してイメージをダウンロード&lt;/li&gt;
&lt;li&gt;コンテナの作成&lt;br /&gt;
(もし足りない設定などあれば&lt;code&gt;Dockerfile&lt;/code&gt;でカスマイズ)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;p&gt;イメージの検索からコンテナの取得は公式GUIの&lt;code&gt;Kitematic (Beta)&lt;/code&gt;を使うと一気にしてくれるので便利。&lt;/p&gt;

&lt;p&gt;ただ、この方法だと引数の指定が多かったり複数のコンテナを利用する場合は大変なので、
&lt;code&gt;DockerCompose&lt;/code&gt;を用いて管理する。&lt;/p&gt;

&lt;h4 id=&#34;事前準備:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;事前準備&lt;/h4&gt;

&lt;p&gt;まずは適当な場所に、コンテナ毎の&lt;code&gt;Dockerfile&lt;/code&gt;や設定ファイルなどを
まとめておくディレクトリを作ってカレントディレクトリとする。
今回のディレクトリ構成は、以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker
 ├─ docker-compose.yml
 ├─ mariadb              # MariaDB用のフォルダ
 |   └─ my.cnf
 ├─ php                  # PHP用のフォルダ
 |   ├─ Dockerfile
 |   └─ php.ini
 └─ www                  # Apacheのドキュメントルート
     └─ index.html       # 動作確認用のHTML
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;apache-php:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;Apache+PHP&lt;/h4&gt;

&lt;p&gt;ApacheはPHPに同梱されているものを使うのが便利なので、&lt;code&gt;apache&lt;/code&gt;がついているタグのものを使う。
今回は&lt;a href=&#34;https://hub.docker.com/_/php/&#34;&gt;公式&lt;/a&gt;で5系の一番新しいバージョンの&lt;code&gt;5.6.18-apache&lt;/code&gt;を選択。&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;php.ini&lt;/code&gt;の設定と追加で入れたい拡張モジュール（特に&lt;code&gt;Xdebug&lt;/code&gt;）を&lt;code&gt;Dockerfile&lt;/code&gt;でカスタムしておく。&lt;/p&gt;

&lt;p&gt;DockerComposeの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php:
  build: ./php/　　　　　　　　# php/Dockerfileからビルド
  ports:
    - &amp;quot;80:80&amp;quot;　　　　　　　　　# 80ポートを公開
  volumes:
    - ./www:/var/www/html   # ドキュメントルートを指定
  links:
    - mariadb:mysql         # DBとの接続を指定
  container_name: php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでMac上からは、&lt;code&gt;http://192.168.99.100/index.html&lt;/code&gt;へアクセスすると、
&lt;code&gt;www/index.html&lt;/code&gt;が表示される。&lt;/p&gt;

&lt;h4 id=&#34;mariadb-phpmyadmin:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;MariaDB+phpMyAdmin&lt;/h4&gt;

&lt;p&gt;特に変更点もないのでイメージは公式の最新をそのままを使う。&lt;/p&gt;

&lt;p&gt;DockerComposeの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mariadb:
  image: mariadb:latest           # 常に最新版を使う
  environment:
    MYSQL_ROOT_PASSWORD: pass     # ルートのパスワード
    MYSQL_DATABASE: docker        # DB名
    MYSQL_USER: docker            # ユーザ名
    MYSQL_PASSWORD: docker        # パスワード
  volumes:                        # my.cnfの設定
    - ./mariadb/my.cnf:/etc/mysql/conf.d/my.cnf
  container_name: mariadb

phpmyadmin:
  image: phpmyadmin/phpmyadmin:latest
  container_name: myadmin
  ports:
    - &amp;quot;8080:80&amp;quot;                   # 8080ポートを公開して80へフォワード
  links:
    - mariadb:db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでMac上からは、&lt;code&gt;http://192.168.99.100:8080&lt;/code&gt;へアクセスすると、
&lt;code&gt;phpMyAdmin&lt;/code&gt;のログイン画面が表示され、&lt;code&gt;docker/docker&lt;/code&gt;でログインが可能。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意点としてこの状態ではDBの永続化はできていないので、コンテナを削除するとDBの内容も消える&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;ios端末からのアクセス:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;iOS端末からのアクセス&lt;/h3&gt;

&lt;p&gt;ここまでの状態だとMacからしかアクセスできないので、Mac上で&lt;code&gt;nginx&lt;/code&gt;をリバースプロキシとして動かし、
他のiOS端末からアクセスできるようにする。&lt;/p&gt;

&lt;p&gt;また、iOS9のATSへ対応する為にSSLでアクセスできるようにする。ただしローカル環境なのでオレオレ証明書を利用する。&lt;/p&gt;

&lt;h4 id=&#34;nginxのインストール:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;nginxのインストール&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Homebrew&lt;/code&gt;でインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストールできたら、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx -t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で設定ファイルの場所を確認し、適当なエディタで開いてリバースプロキシの設定をする。
コメントにしてあるのがデフォルトの設定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
  server {
    #listen       8080;
    listen       80;
    location / {
      # root   html;
      # index  index.html index.htm;
      proxy_pass http://127.0.0.1:8080;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sslの証明書について:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;SSLの証明書について&lt;/h4&gt;

&lt;p&gt;今回はnginx部分だけSSLに対応させる。（dockerはHTTPのまま）&lt;/p&gt;

&lt;p&gt;オレオレ証明書作成のiOS向けの設定のポイントは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SHA256で証明書を作成する&lt;br /&gt;
(デフォルトだとSHA1になる)&lt;/li&gt;
&lt;li&gt;Safari以外からアクセスする場合は、証明書作成時のCommonNameをIPアドレスにする&lt;br /&gt;
(つまりIP固定が必要)&lt;/li&gt;
&lt;li&gt;端末へ証明書のインストールが必要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もし、上の条件が満たせない場合は、ATSの設定を変えるとか個別に認証処理を書くなどして回避する必要がある。
（回避できないのもあるけど）&lt;/p&gt;

&lt;h4 id=&#34;sslの証明書の作成:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;SSLの証明書の作成&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out server.key 2048 -sha256
openssl req -new -sha256 -key server.key &amp;gt; server.csr
openssl x509 -days 3650 -sha256 -req -signkey server.key &amp;lt; server.csr &amp;gt; server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（オレオレ証明書の各項目は&lt;code&gt;CommonName&lt;/code&gt;以外は空白でも動作する）&lt;/p&gt;

&lt;p&gt;生成された&lt;code&gt;server.key&lt;/code&gt;と&lt;code&gt;server.crt&lt;/code&gt;をnginxの設定ファイルと同じディレクトリに置く。&lt;/p&gt;

&lt;p&gt;iOS端末へは&lt;code&gt;server.crt&lt;/code&gt;をインストールする。
（メール添付か適当なWEB上に置いてインストール）&lt;/p&gt;

&lt;p&gt;nginxの設定ファイルに以下を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
  listen       443 ssl;
  server_name  localhost;

  ssl_certificate      server.crt;
  ssl_certificate_key  server.key;

  location / {
    proxy_pass http://127.0.0.1:8080;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vmの設定:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;VMの設定&lt;/h4&gt;

&lt;p&gt;DockerはVirtualBox上で動いているので、VMのポートフォワードを設定が必要となる。
設定は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VBoxManage controlvm &amp;quot;default&amp;quot; natpf1 &amp;quot;nginx,tcp,127.0.0.1,8080,,80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする。VirtualBoxを起動して、&lt;code&gt;default-設定-ネットワーク-アダプター1-ポートフォワーディング&lt;/code&gt;からでもOK。&lt;/p&gt;

&lt;h2 id=&#34;起動:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;起動&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dockerを起動させる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;を置いた場所をカレントディレクトリにする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt;でコンテナを起動&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo nginx&lt;/code&gt;でnginxを起動&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでiPhone上からは、&lt;code&gt;https://192.168.0.2/index.html&lt;/code&gt;へアクセスすると、
&lt;code&gt;www/index.html&lt;/code&gt;が表示される。
（ただし、オレオレ証明書なので認証の警告などは出る）&lt;/p&gt;

&lt;h1 id=&#34;追記:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;追記&lt;/h1&gt;

&lt;p&gt;Docker起動時に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: Couldn&#39;t connect to Docker daemon - you might need to run `docker-machine start default`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーが出る場合は、VMの設定の&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VBoxManage controlvm &amp;quot;default&amp;quot; natpf1 &amp;quot;nginx,tcp,127.0.0.1,8080,,80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;をしてから起動し直すと大丈夫っぽい。なお、原因は不明・・・&lt;/p&gt;

&lt;h1 id=&#34;感想:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;開発環境をプラグインみたいな感じで構築していけるのと構築内容がテキストで残るのはあとあと楽。&lt;/p&gt;

&lt;p&gt;ただ、サーバ環境とまるまる同じものを構築するならVagrantの方が良いのかも・・・
でも、Dockerはいろいろな環境を次々に試すのには便利なので、使い分けが大事そう。&lt;/p&gt;

&lt;h1 id=&#34;ファイル一式:9f4de33edfbe837dbb3e37ebe79037f8&#34;&gt;ファイル一式&lt;/h1&gt;

&lt;p&gt;実際の各イメージのDockerfileや設定ファイルをまとめたものは
&lt;a href=&#34;https://github.com/mike-neko/Docker/tree/master/SSLWebServer&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dockerのコマンド備忘録</title>
      <link>https://mike-neko.github.io/blog/docker-cmd/</link>
      <pubDate>Sat, 02 Apr 2016 14:00:57 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/docker-cmd/</guid>
      <description>

&lt;h2 id=&#34;dockerでよく使うコマンド:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;Dockerでよく使うコマンド&lt;/h2&gt;

&lt;h3 id=&#34;イメージ操作:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;イメージ操作&lt;/h3&gt;

&lt;h4 id=&#34;イメージのリスト表示:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;イメージのリスト表示&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;指定したイメージの削除:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;指定したイメージの削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi [イメージの名前かID]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージの指定は&lt;code&gt;IMAGE ID&lt;/code&gt;の先頭数文字での特定が便利&lt;/p&gt;

&lt;h4 id=&#34;イメージの全削除:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;イメージの全削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンテナ操作:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;コンテナ操作&lt;/h3&gt;

&lt;h4 id=&#34;コンテナのリスト表示:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;コンテナのリスト表示&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;全部停止:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;全部停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;全部削除:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;全部削除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dockercompose:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;DockerCompose&lt;/h3&gt;

&lt;h4 id=&#34;起動:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;cd [docker-copose.ymlを置いてる場所]
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで&lt;code&gt;build&lt;/code&gt;と&lt;code&gt;pull&lt;/code&gt;と&lt;code&gt;run&lt;/code&gt;を一気にしてくれる&lt;/p&gt;

&lt;h4 id=&#34;停止:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker-compose stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nginx:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;nginx&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;80ポートを使う場合はsudoが必要&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;起動-1:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;停止-1:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;停止&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx -s stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;再起動:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;再起動&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;php:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;PHP&lt;/h2&gt;

&lt;h3 id=&#34;オプション:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;オプション&lt;/h3&gt;

&lt;h4 id=&#34;docker-php-ext-installで指定できるもの:1c4ea1d59e18285c6c3ba7b5bb3a3b42&#34;&gt;docker-php-ext-installで指定できるもの&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bcmath bz2 calendar ctype curl dba dom enchant exif fileinfo filter ftp gd gettext gmp hash iconv imap interbase intl json ldap mbstring mcrypt mssql mysql mysqli oci8 odbc opcache pcntl pdo pdo_dblib pdo_firebird pdo_mysql pdo_oci pdo_odbc pdo_pgsql pdo_sqlite pgsql phar posix pspell readline recode reflection session shmop simplexml snmp soap sockets spl standard sybase_ct sysvmsg sysvsem sysvshm tidy tokenizer wddx xml xmlreader xmlrpc xmlwriter xsl zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(デフォルトのPHPイメージは最低限の状態なのでDockerfileで指定して追加する)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPアドレス取得のサンプル(Swift)</title>
      <link>https://mike-neko.github.io/blog/ipaddress/</link>
      <pubDate>Mon, 07 Mar 2016 23:59:45 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/ipaddress/</guid>
      <description>

&lt;h2 id=&#34;概要:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;iOS端末のIPアドレスを取得するサンプル。Cの関数呼び出し周りも含めてSwiftにて実装。&lt;/p&gt;

&lt;p&gt;一応、Apple公式の方法でIPv6only環境でも動作確認済。&lt;/p&gt;

&lt;h3 id=&#34;実装概要:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;実装概要&lt;/h3&gt;

&lt;p&gt;アドレス取得の実装は&lt;code&gt;NetworkInfo&lt;/code&gt;にまとまっている。
実装の中身自体はよくあるIPアドレスの取得のコード。&lt;/p&gt;

&lt;p&gt;サンプルでは、IPアドレスの一覧を取得して&lt;code&gt;TableView&lt;/code&gt;に表示している。&lt;/p&gt;

&lt;p&gt;細かい点は実際のソースを参照のこと。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;cの関数呼び出し:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;Cの関数呼び出し&lt;/h3&gt;

&lt;p&gt;端末内部のネットワーク情報を取得する為に、&lt;code&gt;getifaddrs&lt;/code&gt;や&lt;code&gt;inet_ntop&lt;/code&gt;などの関数を呼び出すが、
通常のCであればファイルの頭で&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ifaddrs.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするが、Swiftなので&lt;code&gt;Bridging-Header.h&lt;/code&gt;を用意して、そこに&lt;code&gt;include&lt;/code&gt;を書く。&lt;/p&gt;

&lt;p&gt;あと、ヘッダを追加した後にはビルド設定の&lt;code&gt;Objective-C Bridging Header&lt;/code&gt;も忘れずに変更。&lt;/p&gt;

&lt;h3 id=&#34;デバイス:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;デバイス&lt;/h3&gt;

&lt;p&gt;とりあえず今回は、IPアドレスを取りたいだけなので、WiFi(&lt;code&gt;en0&lt;/code&gt;)とCellular(&lt;code&gt;pdp_ip0&lt;/code&gt;)の
デバイスのみチェックしている。&lt;/p&gt;

&lt;h3 id=&#34;swiftの言語的なこと:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;Swiftの言語的なこと&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;がとっても便利。これのおかげでリソースの解放のような後始末が必要なコードが、
とても簡単にかけるし処理漏れもなくなるので素晴らしい！&lt;br /&gt;
(これが無いと今回のように処理の中でエラーで返すような場合はコードが面倒になる)&lt;/p&gt;

&lt;p&gt;ポインタが見えなくなったり、型が厳格になってC系のソースの移植が面倒に思えるけど、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;対応する型への変換（特に&lt;code&gt;UnsafePointer&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;C++の&lt;code&gt;-&amp;gt;&lt;/code&gt;に相当するのが&lt;code&gt;memory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同じく&lt;code&gt;[]&lt;/code&gt;に相当するのが&lt;code&gt;advancedBy&lt;/code&gt;(今回は出てこないけど)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と言ったあたりを押さえておけばOKな気がする。&lt;/p&gt;

&lt;p&gt;確かに冗長な感じは否めないが、型は書かなくても済むことが多いし、
逆に一度正しく変換しておけば後はコンパイラで型チェックが行われるのは安心できる。&lt;/p&gt;

&lt;p&gt;この辺りのバランス感覚がSwiftは絶妙だと思う。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html&#34;&gt;IPv6only環境の確認方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html&#34;&gt;CのAPIをSwiftで使う方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;li&gt;Mac OS 10.11.3(NAT64ネットワーク)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:b896621a8ba2c96e1312fe1998076f7a&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/NetworkInfo&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metalによる砂のシミュレーションもどき</title>
      <link>https://mike-neko.github.io/blog/metal-sand/</link>
      <pubDate>Thu, 25 Feb 2016 22:05:16 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-sand/</guid>
      <description>

&lt;h2 id=&#34;概要:41585ab4c2e78900081a05c039c1f55d&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;MetalのGPGPUによる大量のパーティクル処理能力を活かしたデモ。
パーティクルをそれぞれ砂の一粒に見立てており、上から落下してきた砂粒が山のように積みあがっていく様子をシュミレートしている。&lt;/p&gt;

&lt;p&gt;なお、これも約26万パーティクルで60FPSを維持している。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BCX1ylEFQd_/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-29T13:51:35+00:00&#34;&gt;2016 2月 29 5:51午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;（2色にして拡大してみたけど、動画だとイマイチになってしまった・・・）&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:41585ab4c2e78900081a05c039c1f55d&#34;&gt;小ネタ&lt;/h2&gt;

&lt;h3 id=&#34;砂の動き:41585ab4c2e78900081a05c039c1f55d&#34;&gt;砂の動き&lt;/h3&gt;

&lt;p&gt;タイトルに「もどき」とある通り、砂の動きは粒子法などのちゃんとした物理計算をしているわけではないが、GameGems本の中の地形生成の粒子堆積を参考にしている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;フラクタル地形生成-粒子堆積:41585ab4c2e78900081a05c039c1f55d&#34;&gt;フラクタル地形生成-粒子堆積&lt;/h4&gt;

&lt;p&gt;&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-25-metal-sand/gems4-19-3.png&#34; /&gt;
&lt;/figure&gt;

出典：Game Programming Gems&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上図にあるように、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;粒子を地面（粒子）にぶつかるまで落下させる&lt;/li&gt;
&lt;li&gt;ぶつかった地点の周囲で最も低い地点を探す&lt;br /&gt;
見つからなければそこに粒子を固定（地面化）させて終了&lt;/li&gt;
&lt;li&gt;2で見つかった地点に粒子を移動させる&lt;/li&gt;
&lt;li&gt;1に戻って落下させ続ける&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という動きをGPUで計算している。&lt;/p&gt;

&lt;h3 id=&#34;コンピュートシェーダのコード:41585ab4c2e78900081a05c039c1f55d&#34;&gt;コンピュートシェーダのコード&lt;/h3&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/c6997165804cbaa25402.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;流れとしては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU側で砂の初期位置とy軸への落下速度を設定&lt;/li&gt;
&lt;li&gt;コンピュートシェーダで砂の動きを計算して描画用バッファへ書き出し&lt;/li&gt;
&lt;li&gt;バーテックスシェーダとフラグメントシェーダはシンプルにパーティクルを描画&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;h4 id=&#34;地面との衝突判定:41585ab4c2e78900081a05c039c1f55d&#34;&gt;地面との衝突判定&lt;/h4&gt;

&lt;p&gt;今回は地面との衝突の判定のみで、粒子間の衝突などは考慮しない。よって、512*512のバッファ&lt;code&gt;laminateBuffer&lt;/code&gt;を地面に見立てて、各座標の高さを記録している。ここでテクスチャを使っていないのは、コンピュートシェーダではテクスチャの読み書きを同時に行うことができない為。&lt;/p&gt;

&lt;p&gt;地面にぶつかったら、元の位置からそれぞれ30度+αずつずらした位置の地面の高さを見て、一番低いところを探す。なお、ここで手を抜いてsincosを使わなければ、四角い山ができてしまう・・・&lt;/p&gt;

&lt;p&gt;一番低いところの判定を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = mix((float)min_id, 1.f, not(step(h[1], h[min_id])));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としているが、これは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;min_id = (h[1] &amp;lt;= h[min_id]) ? min_id : 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と同じである。(Metalの座標系のy軸は上が-になる)&lt;/p&gt;

&lt;p&gt;現在位置が一番低い場所であれば、y軸の速度を0にして粒子を固定する。同時に地面の高さも更新し、次回参照時からはそこが地面の扱いとなる。&lt;/p&gt;

&lt;p&gt;あとはこれをひたすら繰り返していくと山のように積み重なっていく。&lt;/p&gt;

&lt;h2 id=&#34;感想:41585ab4c2e78900081a05c039c1f55d&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;パラメータの調整とかバッファへの書き込みの精度を上げたりするなど、まだまだ改良の余地はありそう。。。&lt;/p&gt;

&lt;p&gt;なんにしても単純な方法を力任せに処理してもちゃんと動くあたり、GPGPUは頼もしい。&lt;/p&gt;

&lt;p&gt;あと、GameGemsの1以外も電子書籍で出ないかなぁ。内容的には古くても色々参考になるし、紙版は置く場所考えるとどうしても買いづらいので&lt;/p&gt;

&lt;h1 id=&#34;開発環境:41585ab4c2e78900081a05c039c1f55d&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:41585ab4c2e78900081a05c039c1f55d&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalSand&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SwiftでNSExceptionを処理する</title>
      <link>https://mike-neko.github.io/blog/objc-exception/</link>
      <pubDate>Sat, 20 Feb 2016 08:10:44 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/objc-exception/</guid>
      <description>

&lt;h2 id=&#34;概要:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;ObjectiveCで書かれた&lt;code&gt;NSException&lt;/code&gt;を発生させるソースをSwiftから利用したい時の処理方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NSException&lt;/code&gt;は、ObjectiveCの&lt;code&gt;@try ~ @catch ~ @finally&lt;/code&gt;でしか例外処理を行えない。例外処理を書いていない時は、実行時エラーとして処理される。つまり、Swiftから&lt;code&gt;NSException&lt;/code&gt;を発生させるコードを呼び出して例外が起きると、問答無用でアプリが落ちてしまう・・・&lt;/p&gt;

&lt;p&gt;対応策としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;元のコードもSwiftで書き換えてしまう&lt;/li&gt;
&lt;li&gt;そもそも例外は起きるはずがないので&lt;del&gt;落ちていい&lt;/del&gt;無視する&lt;/li&gt;
&lt;li&gt;該当のメソッドを呼び出す部分をブリッジするラッパを作る&lt;/li&gt;
&lt;li&gt;なんとかしてSwiftで&lt;code&gt;NSException&lt;/code&gt;の例外を処理する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった感じになると思うが、サードパーティのライブラリとかだと1や2の方法が取れない場合がある。
3も該当のメソッドが多ければ作業量が多くなるし、ソースの見通しも悪くなる。&lt;/p&gt;

&lt;p&gt;なので、今回は4の方法で例外を処理する方法についてメモしておく。&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;基本的な考えた方は3と同じで、ObjectiveCでしか処理できない部分だけラップしてしまえ〜となる。
まずは以下の様なブリッジ用のObjectiveCのクラスを作る。（&lt;code&gt;Bridging-Header&lt;/code&gt;への追加も忘れずに）&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/5add082e4f51059161ce.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;中は見ての通り、例外処理のそれぞれの中身をクロージャ（ブロック）でブリッジ用のクラスに渡している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nonnull&lt;/code&gt;や&lt;code&gt;nullable&lt;/code&gt;をつけているのは、Swift側から呼び出す時に&lt;code&gt;Optional&lt;/code&gt;になるかどうかを制御する為。&lt;code&gt;finally&lt;/code&gt;は不要なことも多々あるので&lt;code&gt;nil&lt;/code&gt;を渡せる様に&lt;code&gt;nullable&lt;/code&gt;にしている。&lt;/p&gt;

&lt;p&gt;（意図して処理がないことを明示させる為に空ブロックではなく&lt;code&gt;nil&lt;/code&gt;を渡せる様にしている）&lt;/p&gt;

&lt;h3 id=&#34;使い方:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;使い方&lt;/h3&gt;

&lt;p&gt;Swiftから呼び出す時は以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try({ _ in
  // NSExceptionが起きるかもしれない処理
},

objC_catch: { (NSException) in
  // 例外発生時の処理
},

objC_finally: { _ in
  // 後処理とか...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;finally&lt;/code&gt;が不要であれば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try({ _ in
  // NSExceptionが起きるかもしれない処理
},

objC_catch: { (NSException) in
  // 例外発生時の処理
},

objC_finally: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もし複数の&lt;code&gt;catch&lt;/code&gt;が使いたい場合は、これを元に拡張すればOK。&lt;/p&gt;

&lt;h3 id=&#34;nonnullやnullableのアノテーションについて:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;nonnullやnullableのアノテーションについて&lt;/h3&gt;

&lt;p&gt;ObjectiveC側でアノテーションを指定すると、Swiftとの連携時のメソッドの型にも反映される。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ObjC&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Swift&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;変換前(ObjC)&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;変換後(Swift)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;未指定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)!&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;nonull&lt;br&gt;_Nonnull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge* _Nonnull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;nullable&lt;br&gt;_Nullable&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(型)?&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge* _Nullable&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hoge?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;例えば、今回のメソッドをSwiftから呼び出す時は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjC_Exception.objC_try(objC_try: () -&amp;gt; Void, objC_catch: (NSException) -&amp;gt; Void, objC_finally: (() -&amp;gt; Void)?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形式になっていて、&lt;code&gt;objC_finally&lt;/code&gt;を&lt;code&gt;nullable&lt;/code&gt;にしたので、ちゃんと&lt;code&gt;?&lt;/code&gt;のついた&lt;code&gt;Optional&lt;/code&gt;になっているし、それ以外は&lt;code&gt;nonnull&lt;/code&gt;なので型がそのまま使われている。&lt;/p&gt;

&lt;h1 id=&#34;開発環境:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:42c35dd4df3ba60bfe736cb25290afa1&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/ObjC_Exception&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugoのshortcodeのメモ</title>
      <link>https://mike-neko.github.io/blog/hugo-shortcode/</link>
      <pubDate>Tue, 16 Feb 2016 23:07:23 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/hugo-shortcode/</guid>
      <description>

&lt;p&gt;Hugoの&lt;code&gt;shortcode&lt;/code&gt;を使って、記事の中でHTMLのタグをべた書きしなくて良い様にする方法のメモ。あと、おまけで&lt;code&gt;shortcode&lt;/code&gt;をMarkdownの中でエスケープして表示する方法。&lt;/p&gt;

&lt;h2 id=&#34;画像を貼り付けるshortcode:82b443db7a6a95ed9bb9f499c6e51b27&#34;&gt;画像を貼り付けるshortcode&lt;/h2&gt;

&lt;p&gt;Hugoで画像を表示するには、&lt;code&gt;static&lt;/code&gt;の中に置く必要がある。この中は全サイト共通になっているので、整理しやすいように以下のディレクトリ構成にした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- static
    - media
        - 2016-02-16-sprite-shader
            - comp.png
            - beta.gif
        - 2016-02-18-hugo-shortcode
            - sample.jpg
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;media&lt;/code&gt;の中に、記事毎に&lt;code&gt;[作成日付]-[slug]&lt;/code&gt;というディレクトリを作り、その中に画像などのコンテンツを置いている。&lt;/p&gt;

&lt;p&gt;この状態で記事の中で画像を表示させるには、&lt;code&gt;{{&amp;lt; figure src=&amp;quot;/media/2016-02-18-hugo-shortcode/sample.jpg&amp;quot; &amp;gt;}}&lt;/code&gt;となる。&lt;/p&gt;

&lt;p&gt;これを毎回書くのは面倒だが&lt;code&gt;shortcode&lt;/code&gt;を使うと、&lt;code&gt;{{&amp;lt; img &amp;quot;sample.jpg&amp;quot; &amp;gt;}}&lt;/code&gt;とだけ書けばよい。&lt;/p&gt;

&lt;h3 id=&#34;作り方:82b443db7a6a95ed9bb9f499c6e51b27&#34;&gt;作り方&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;site-name&amp;gt;/layouts/shortcodes/img.html&lt;/code&gt;を作成&lt;/li&gt;
&lt;li&gt;1のファイルに
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/593de54e0ba8f5db4c6b.js&#34;&gt;&lt;/script&gt;
を貼り付けて保存&lt;/li&gt;
&lt;li&gt;あとは使いたい場所で&lt;code&gt;{{&amp;lt; img &amp;quot;ファイル名&amp;quot; &amp;gt;}}&lt;/code&gt;とすればOK&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;エスケープ方法:82b443db7a6a95ed9bb9f499c6e51b27&#34;&gt;エスケープ方法&lt;/h2&gt;

&lt;p&gt;記事の中で、&lt;code&gt;shortcode&lt;/code&gt;などを表示させたい場合に、そのまま書くと当然ながらそのコードが実行されてしまうので、エスケープが必要となる。&lt;/p&gt;

&lt;p&gt;このエスケープ方法は幾つかある（他にもあるかも）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt;をつける方法&lt;br /&gt;
&lt;code&gt;\{\{&amp;lt; コード &amp;gt;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt;を&lt;code&gt;&amp;amp;lt;&lt;/code&gt;と入力する方法&lt;br /&gt;
&lt;code&gt;{{&amp;amp;lt; コード &amp;gt;}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/**/&lt;/code&gt;のコメントにする方法&lt;br /&gt;
&lt;code&gt;{{/* コード */}}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;で、一番おすすめなのは3の方法。他の方法だと``で囲った時にうまく表示されないので。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:82b443db7a6a95ed9bb9f499c6e51b27&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;Hugo - Shortcodes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>UnityのSprite用シェーダ(2本)</title>
      <link>https://mike-neko.github.io/blog/sprite-shader/</link>
      <pubDate>Tue, 16 Feb 2016 04:13:47 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/sprite-shader/</guid>
      <description>

&lt;h2 id=&#34;概要:5faa08a3423ea1353ad8985880ae422e&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Unity公式のスプライトシェーダをベースにした、スプライトにエフェクトをつけるシェーダ2本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定色でベタ塗りにするシェーダ：&lt;code&gt;SpriteBetaMask&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定色でアウトラインと影をつけるシェーダ：&lt;code&gt;SpriteOutline&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ベタ塗りシェーダ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;ベタ塗りシェーダ&lt;/h3&gt;

&lt;p&gt;未取得のアイテムをシルエット表示にしておきたいといった場合に、
わざわざ画像を別に用意しなくても良いように作ったシェーダ&lt;/p&gt;

&lt;h4 id=&#34;プロパティ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;プロパティ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mask Color&lt;/code&gt;：ベタ塗りにする時の色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mask On&lt;/code&gt;：&lt;code&gt;true&lt;/code&gt;でベタ塗り状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tint&lt;/code&gt;：乗算する頂点色（SpriteRendererのColorと同じ）&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/beta.gif&#34; /&gt;
&lt;/figure&gt;


&lt;h3 id=&#34;アウトラインシェーダ:5faa08a3423ea1353ad8985880ae422e&#34;&gt;アウトラインシェーダ&lt;/h3&gt;

&lt;p&gt;枠をつけてちょっと目立たせたいとか簡単な影を落としたいといった場合に、
画像を別に用意しなくても良い＆ある程度動的に変化できるように作ったシェーダ&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/outline.gif&#34; /&gt;
&lt;/figure&gt;


&lt;h4 id=&#34;プロパティ-1:5faa08a3423ea1353ad8985880ae422e&#34;&gt;プロパティ&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OutLine Spread&lt;/code&gt;：アウトラインの幅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Outline Color&lt;/code&gt;：アウトラインの色&lt;br /&gt;
&lt;em&gt;α値は無視される&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shadow Offset X&lt;/code&gt;/&lt;code&gt;Shadow Offset Y&lt;/code&gt;：影の位置&lt;br /&gt;
&lt;em&gt;アウトラインの幅がある場合は、&lt;code&gt;アウトラインの幅 + 影の位置&lt;/code&gt;を設定&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shadow Color&lt;/code&gt;：影の色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alpha&lt;/code&gt;：全体のα値&lt;br /&gt;
&lt;em&gt;スプライト全体のαを変化させたい時は、SpriteRendererではなくこの値を使って変化させる&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;制約事項:5faa08a3423ea1353ad8985880ae422e&#34;&gt;制約事項&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;本来のスプライトのサイズより小さくなるので注意&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Multiple Spriteでの使用は非推奨&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;キャラのように複雑な形状とかの場合は途切れる可能性あり&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※手抜きしたい時用なので、特に3つ目などの場合は画像自体を作るか2パスとかの正攻法での対応を。。。&lt;/p&gt;

&lt;h4 id=&#34;説明:5faa08a3423ea1353ad8985880ae422e&#34;&gt;説明&lt;/h4&gt;

&lt;p&gt;スプライトにアウトラインや影を簡単につけるには、参考リンクにあるような方法があるが、uGUIでしか使えないのと、太めの線をつけることができなかったので、自作した。&lt;/p&gt;

&lt;p&gt;アウトラインや影も特別なことをしている訳ではなく、フラグメントシェーダで指定された分の幅をずらしてテクスチャを見に行き、画像がある（＝αがしきい値以上）ならアウトラインないし影の色を出力しているだけ。&lt;/p&gt;

&lt;p&gt;0ではなくしきい値（コード内では&lt;code&gt;THRESHOLD&lt;/code&gt;の&lt;code&gt;0.1&lt;/code&gt;）にしたのは、縁取りをキレイにみせる為。固定値にしているが、使う画像によっては値を変えたりプロパティ化しても良いかも。それと、&lt;code&gt;lerp&lt;/code&gt;とか&lt;code&gt;sign&lt;/code&gt;を使っているのは&lt;code&gt;if&lt;/code&gt;などの分岐命令を使いたくなかったからだけど、これぐらいなら素直に分岐を使った方が楽だったかも・・・&lt;/p&gt;

&lt;p&gt;さて、アウトラインシェーダの重要なポイントは、バーテックスシェーダのテクスチャのUV座標を縮小させている（下の13-14行目あたりの）ところ。
&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/f85e50d1f52d136b8e5f.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;これが無いと太めのアウトラインや影をつけた時に途中で切れてしまう。初めはこの理由が判らなくてかなりハマってしまったのだけど、シーンの描画をワイヤフレームにして一目瞭然！Unityの
スプライトは賢いことに、単に板ポリに画像を貼り付けるのではなく、ちゃんと形状に合わせてポリゴン分割をしてくれている。多分、四角形より描画範囲が狭くなるのでパフォーマンスがあがるからだろうけど、逆に余白がほぼ0に近い状態になるので太めの線だと切れてしまっていた。&lt;/p&gt;

&lt;p&gt;なので、ポリゴンはそのままで中に表示する画像を縮小することで、無理やり余白を作っている。（モデルを法線方向へ膨らます通常のアウトラインシェーダとは逆にしてみた）
&lt;figure&gt;
	&lt;img src=&#34;https://mike-neko.github.io/media/2016-02-16-sprite-shader/comp.png&#34; /&gt;
&lt;/figure&gt;

（左側が余白を作った状態なので、多少太めの線を引いても途切れない。逆に右側の通常のスプライトだと余白がほぼないのですぐに途切れてしまう。縮小する割合&lt;code&gt;1.2&lt;/code&gt;は実際に試して自分の環境でバランスのとれた値なので、必要に応じて調整を）&lt;/p&gt;

&lt;p&gt;ただ、それが逆に制約事項につながってしまっている。Multiple Spriteについては、隣のスプライトとの距離が近すぎるとそれが表示されてしまう場合があるし、ポリゴンがトゲトゲの様な感じの形状だとその部分が途切れてしまう。（が、自分の環境では特に問題にならないので&lt;del&gt;放置&lt;/del&gt;今後の課題に）&lt;/p&gt;

&lt;h2 id=&#34;感想:5faa08a3423ea1353ad8985880ae422e&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;今回のサンプルに使わせてもらったこのキャラってなんて言うんだろう？？&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:5faa08a3423ea1353ad8985880ae422e&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;公式：&lt;a href=&#34;http://unity3d.com/jp/get-unity/download/archive&#34;&gt;シェーダ置き場&lt;/a&gt;&lt;br /&gt;
（バージョン毎のダウンロードから「ビルトインシェーダ」を選択）&lt;/li&gt;
&lt;li&gt;お手軽なuGUIでの方法：&lt;a href=&#34;http://tsubakit1.hateblo.jp/entry/2014/09/10/224446&#34;&gt;テラシュールブログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:5faa08a3423ea1353ad8985880ae422e&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Unity 5.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:5faa08a3423ea1353ad8985880ae422e&#34;&gt;ソース&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample&#34;&gt;プロジェクト一式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ベタ塗りシェーダ(&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample/blob/master/Assets/Shaders/SpriteBetaMask.shader&#34;&gt;ソースのみ&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;アウトラインシェーダ(&lt;a href=&#34;https://github.com/mike-neko/SpriteShaderSample/blob/master/Assets/Shaders/SpriteOutline.shader&#34;&gt;ソースのみ&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div&gt;
	&lt;img src=&#34;http://unity-chan.com/images/imageLicenseLogo.png&#34; alt=&#34;ユニティちゃんライセンス&#34;&gt;
	&lt;p&gt;この作品は&lt;a href=&#34;http://unity-chan.com/contents/license_jp/&#34; target=&#34;_blank&#34;&gt;ユニティちゃんライセンス条項&lt;/a&gt;の元に提供されています&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MetalのGPGPUによるパーティクルデモ</title>
      <link>https://mike-neko.github.io/blog/metal-image/</link>
      <pubDate>Thu, 11 Feb 2016 09:20:27 +0900</pubDate>
      
      <guid>https://mike-neko.github.io/blog/metal-image/</guid>
      <description>

&lt;h2 id=&#34;概要:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;読み込んだテクスチャをパーティクルに分解して動かすデモ。動きは滝のように画像がパーティクルに分解して落下していくのをイメージ。&lt;/p&gt;

&lt;p&gt;画像サイズが512*512、1ピクセル=1パーティクルに分解するので、約26万個のパーティクルを動かしているが、60FPSを維持している。約100万まで増やすとiPhone6+で30FPSぐらいとなる。&lt;/p&gt;

&lt;p&gt;そんなに複雑な計算をさせていないとはいえ、さすがGPGPUといったところ。なお、処理時間のほとんどはGPGPUの部分でCPUは余力がある様子。&lt;/p&gt;

&lt;h2 id=&#34;動作イメージ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動作イメージ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-version=&#34;6&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:62.3366013072% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAAGFBMVEUiIiI9PT0eHh4gIB4hIBkcHBwcHBwcHBydr+JQAAAACHRSTlMABA4YHyQsM5jtaMwAAADfSURBVDjL7ZVBEgMhCAQBAf//42xcNbpAqakcM0ftUmFAAIBE81IqBJdS3lS6zs3bIpB9WED3YYXFPmHRfT8sgyrCP1x8uEUxLMzNWElFOYCV6mHWWwMzdPEKHlhLw7NWJqkHc4uIZphavDzA2JPzUDsBZziNae2S6owH8xPmX8G7zzgKEOPUoYHvGz1TBCxMkd3kwNVbU0gKHkx+iZILf77IofhrY1nYFnB/lQPb79drWOyJVa/DAvg9B/rLB4cC+Nqgdz/TvBbBnr6GBReqn/nRmDgaQEej7WhonozjF+Y2I/fZou/qAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;&lt;a href=&#34;https://www.instagram.com/p/BBn2nSclQZi/&#34; style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&#34; target=&#34;_blank&#34;&gt;@m_ike__が投稿した動画&lt;/a&gt; - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2016-02-10T22:35:15+00:00&#34;&gt;2016  2月 10 2:35午後 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちなみに実機で見るともっとキレイ&lt;/p&gt;

&lt;h2 id=&#34;小ネタ:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;小ネタ&lt;/h2&gt;

&lt;p&gt;処理はおおまかにわけて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事前処理として、テクスチャを読み込んで、ピクセル数分のバッファを確保&lt;/li&gt;
&lt;li&gt;テクスチャからパーティクルを生成&lt;/li&gt;
&lt;li&gt;生成したパーティクルを動かす&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となる。事前処理はCPU側で行い、以降はそれぞれ専用のシェーダを準備して、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成用シェーダ&lt;code&gt;fallImageSetup&lt;/code&gt;をセットしてパーティクルを生成&lt;/li&gt;
&lt;li&gt;実行用シェーダ&lt;code&gt;fallImageCompute&lt;/code&gt;へ切り替えてパーティクルを動かす&lt;/li&gt;
&lt;li&gt;動き終われば1へ戻る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった流れでループする。&lt;/p&gt;

&lt;p&gt;注意点として、画像の座標とMetalでの座標軸は違うので、x軸とy軸に−1のスケールをかけて補正している。テクスチャ読み込み時に何かできるかは未調査だが、そもそもこういうテクスチャの使い方は普通しないと思うのでそのまま。&lt;/p&gt;

&lt;h3 id=&#34;テクスチャからパーティクルを生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;テクスチャからパーティクルを生成&lt;/h3&gt;

&lt;h4 id=&#34;パーティクルの位置の計算:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルの位置の計算&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// ImagePiece* particles [[ buffer(0) ]]
// uint2 id [[ thread_position_in_grid ]]
// uint2 size [[ threads_per_grid ]]
// uint index = id.x + id.y * size.x;
particles[index].position = float4(id.x / (float)size.x, id.y / (float)size.y, 0, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;イメージとしては1*1の板ポリの中にすべてのパーティクルを配置する感じで、各パーティクルのローカル座標が(0, 0)から(1, 1)の中に収まるようにする。&lt;/p&gt;

&lt;h4 id=&#34;画像の対応するピクセルの色を取得:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;画像の対応するピクセルの色を取得&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// texture2d&amp;lt;float, access::read&amp;gt; image [[ texture(0) ]]
particles[index].color = image.read(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は1ピクセル=1パーティクル、スレッドも同じように分割しているので、テクスチャの対応するピクセルの座標は、そのままグリッド内のスレッド位置と同じになる。&lt;/p&gt;

&lt;h4 id=&#34;動きのパラメータの初期設定:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;動きのパラメータの初期設定&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// param.time.w : y方向のdelay
// rnd : 乱数
float rnd_d = param.time.w * (1 - (float)rnd / UINT_MAX * 0.1);  // 1

// param.delta : 各軸の1フレーム毎の移動量
particles[index].acc = float4(param.delta.x, param.delta.y, param.delta.z, rnd_d * id.y);  // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下の方から順にパーティクルが落ちるように、画像の上の方ほど遅れて落ち始めるようにで遅延を設定する(2の&lt;code&gt;rnd_d * id.y&lt;/code&gt;部分)。また落ち方がそれっぽく見えるように、遅延時間は元の指定の100%〜90%の間でばらつくように乱数を使う(1の部分)。&lt;/p&gt;

&lt;h3 id=&#34;パーティクルに動きをつける:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;パーティクルに動きをつける&lt;/h3&gt;

&lt;h4 id=&#34;位置の更新:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;位置の更新&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// particles[index].acc.w : delay
// param.time.x : スタートからの経過時間
// param.time.y : 前フレームからの経過時間
float t = fmax(0.f, param.time.x - particles[index].acc.w) * param.time.y * rnd_d;
particles[index].position += t * particles[index].acc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パーティクルの位置は、スムーズに見えるように&lt;code&gt;前回からの経過時間*時間あたりの移動量&lt;/code&gt;で計算する。ただし、各パーティクルには遅延時間があるので、それを経過するまでは経過時間は0として動かないようにする(&lt;code&gt;fmax(0.f, param.time.x - particles[index].acc.w)&lt;/code&gt;の部分)。さらに、こちらも乱数で落ち方にばらつきを与える。&lt;/p&gt;

&lt;h4 id=&#34;消滅処理:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;消滅処理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;float4 f = step(param.delta.w, particles[index].position + t * particles[index].acc);
particles[index].color.a -= (1 - f.x * f.y * f.z) * 0.1 * rnd_d * 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定距離落ちれば徐々に消滅したように見せる為に、まず&lt;code&gt;step()&lt;/code&gt;で指定した距離を超えていないかチェックする。超えていれば、該当の要素が0になるのでαが減算されて消えたように見せかける（パーティクル自体は生きている）。ここも乱数で消え方にばらつきを与える。&lt;/p&gt;

&lt;p&gt;ここでハマったのが、アルファブレンドをONにするのを忘れていて全然消えてくれなかったこと・・・&lt;br /&gt;
デフォルトではフラグメントシェーダでどれだけαを変更しても無視されるので、&lt;code&gt;pipelineDescriptor.alphaToCoverageEnabled = true&lt;/code&gt;でαの指定を有効にする。&lt;/p&gt;

&lt;p&gt;ポイントとなるのは、フラグメントシェーダ内の&lt;code&gt;if (in.color.a &amp;lt; 0.1) discard_fragment();&lt;/code&gt;という見えなくなったピクセルの破棄処理。なくてもパーティクルは消えてくれるが、この処理を行うことで若干フレームレートが改善するので入れた（&lt;del&gt;単に使ってみたかっただけ&lt;/del&gt;）。&lt;/p&gt;

&lt;h3 id=&#34;乱数の生成:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;乱数の生成&lt;/h3&gt;

&lt;p&gt;Metalではシェーダ上で使える乱数の関数は準備されていない為、使いたい場合はシェーダ上で自前で実装するかCPU側で生成したものを渡して使うかになる。今回はCPU側でほとんど処理しないので、シェーダ上で実装する方を選択した。&lt;/p&gt;

&lt;p&gt;乱数のアルゴリズムは幾つかあるし、このデモでの利用方法なら前回作ったようなノイズ関数を用いても良いが、ちょうど少し前に面白い記事(参考リンク参照)を見つけたので、&lt;code&gt;xorshift&lt;/code&gt;を採用することにした。32bitにしたのは、もしCPU側とやりとりする場合（シードの初期値など）に、64bit以上の型は直接渡せない為。&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;https://gist.github.com/b1c006b69ccb57261f7d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;今回はシードの初期値に&lt;code&gt;2463534242&lt;/code&gt;の値を直で指定している。もし本当にランダムにしたいならCPU側から現在のミリ秒あたりを渡して設定すればよい。&lt;/p&gt;

&lt;p&gt;ポイントは、生成された乱数が次回のシードになるので、アドレス空間に&lt;code&gt;threadgroup&lt;/code&gt;を指定していること。これにより同じスレッドグループ内のスレッドでこのシードが共有されるようになる。（指定しないと毎回初期値が設定されてしまう。）&lt;/p&gt;

&lt;p&gt;しかし、GPGPUでは同時にスレッドが並列で幾つも実行される為、単にシードを共有するだけでは同じシードを複数のスレッドを使うことになり、結果が偏ったものになってしまう。そこで、シードを渡す時に&lt;code&gt;rotate(rnd, id.x)&lt;/code&gt;として値をばらつかせている（フローの起きないrotateが標準で使えるのは、ほんと助かる）。&lt;/p&gt;

&lt;p&gt;得られる結果は&lt;code&gt;uint&lt;/code&gt;なので、実際のコード内では使いやすいよう&lt;code&gt;(float)rnd / UINT_MAX&lt;/code&gt;として正規化してから使っている。&lt;/p&gt;

&lt;h1 id=&#34;参考リンク:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;参考リンク&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;乱数のアルゴリズムの解説記事&lt;br /&gt;
&lt;a href=&#34;https://blog.visvirial.com/articles/575&#34;&gt;Google Chromeが採用した、擬似乱数生成アルゴリズム「xorshift」の数理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;開発環境:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;開発環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7.2&lt;/li&gt;
&lt;li&gt;iOS 9.2&lt;/li&gt;
&lt;li&gt;iPhone 6+&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ソース:ee598c9d217a1971ba9d28d3419c0378&#34;&gt;ソース&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mike-neko/MetalImage&#34;&gt;こちら&lt;/a&gt;(&lt;em&gt;iOS9 A7以降搭載機種のみ&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>